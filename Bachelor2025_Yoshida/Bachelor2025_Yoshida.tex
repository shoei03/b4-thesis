\documentclass[11pt]{jreport}
\usepackage{wuse_thesis}
\usepackage{indentfirst}
\usepackage{url}  % \url{}コマンド用．URLを表示する際に便利
\usepackage{amsmath}
\usepackage{booktabs}
\usepackage[dvipdfmx]{graphicx,xcolor}
\usepackage{subfigure}
\usepackage{listings}
\lstset{
  basicstyle={\ttfamily},
  identifierstyle={\small},
  commentstyle={\smallitshape},
  keywordstyle={\small\bfseries},
  ndkeywordstyle={\small},
  stringstyle={\small\ttfamily},
  frame={tb},
  breaklines=true,
  columns=[l]{fullflexible},
  numbers=left,
  xrightmargin=0zw,
  xleftmargin=3zw,
  numberstyle={\scriptsize},
  stepnumber=1,
  numbersep=1zw,
  lineskip=-0.5ex
}
\usepackage{siunitx}
\sisetup{group-separator={,}} % 3桁ごとにコンマを入れる設定
%\usepackage{graphicx}  % ←graphicx.styを用いてEPSを取り込む場合有効にする
% 他のパッケージ・スタイルを使う場合には適宜追加
\newcommand{\todo}[1]{\colorbox{yellow}{{\bf TODO}:}{\color{red} {\textbf{[#1]}}}}
\newcommand{\memo}[1]{\colorbox{magenta}{\textbf{MEMO}}{\color{red}\textbf{[#1]}}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%
%% 主に表紙を作成するための情報
%%

%%  タイトル(修論の場合は英語表記も指定)
\title{類似コードを有するメソッドの\\
削除に関する実証分析}
%\etitle{Test\\Test\\Test}

%%  著者名(修論の場合は英語表記も指定)
\author{吉田 将衛}
%\eauthor{Akinori Ihara}

%% 卒業論文・修士論文(以下のどちらかを選択)
\bachelar  % 卒業論文(4年生用)
%\master    % 修士論文(M2用)

%%  学科・クラスタ
\department{システム工}
%\department{デザイン情報}
%\department{デザイン科学}

%%  学生番号
\studentid{60276296}

%%  卒業年度
\gyear{2025}    % 提出年が2022年なら，2021年度

%%  論文提出日
\date{2026年2月10日}  % 修士の場合は月(2021年2月)までとし，英語表記も指定
%\edate{February 2021}  % 修士の場合，こちら(英語表記)も有効化

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

\maketitle

%%
%%  概要
%%
\begin{abstract}
ライブラリの機能追加，削除を繰り返す進化を続けているが，ソフトウェアの規模は拡大の一途をたどっている．この問題を解決するためのソフトウェア再構成として，類似する機能を持つメソッドの削除が一つの手段である．しかし，削除判断の客観的な指標が存在しないため，ソフトウェア再構成の一つとしてメソッドの削除は開発者の経験に依存せざるを得ない．
本研究では，削除されるメソッドの特徴を明らかにする．具体的には，「同じバージョンに含まれる複数のメソッド間で類似度が高いと片方が削除される」を検証する．ケーススタディとして広く利用されるライブラリを対象とした結果，類似度が高いメソッド間において片方が削除される事例を確認した．
\end{abstract}

%%  目次
\tableofcontents

%%  図目次 (図目次をいれたければ以下のコメントをはずす)
%\listoffigures

%%  表目次 (表目次をいれたければ以下のコメントをはずす)
%\listoftables

\newpage
\pagenumbering{arabic}  % 以降のページ番号を算用数字に

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%
%%  本文はここから
%%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{はじめに}
\label{chap:background}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

多くのソフトウェア開発は，ソフトウェア部品の組み合わせで行われる\cite{liblary-reuse}．
ソフトウェア部品には，ソフトウェア開発者が自身で作成し，そのソフトウェア部品を再利用する場合と，他者が再利用可能な形でまとめたソフトウェア部品を再利用する場合の2種類が存在する．
特に，特定の機能を再利用可能な形でまとめられたライブラリの利用によってソフトウェアの開発工程を大幅に削減している\cite{reduce-productivity}．
したがって，ライブラリも多くのソフトウェアと同様に，ライブラリの機能性を向上するための進化を続けている．ライブラリの進化の過程では，一般に，「機能追加」や「バグ修正」などが行われる．ただし，その進化の過程で，「ライブラリが外部へ公開しているAPIの名称変更」や「引数の変更」など，既存機能の変更や削除によって後方互換性を損失することがある\cite{detect-backward-compatibility}\cite{Brito2018WhyAH}．後方互換性の損失とは，バージョン更新後のライブラリがクライアントの振る舞いを変化させ，クライアントソフトウェアの実行時エラーを発生させるなどの影響を与えることをいう．
その中でも特に，ライブラリAPIの削除はクライアントソフトウェア（以降，クライアント）に甚大な影響を及ぼす．削除によって当該機能を使用するクライアントは同一の機能を継続して運用するために，代替APIへ切り替え，自身で実装，機能廃止などの選択が迫られる\cite{client-action-on-deprecation}．その一方で，ライブラリにとっては，ライブラリの再利用性，軽量化のために効果的な方法であるため，ライブラリ開発者は，クライアントへの影響範囲も危惧しつつ，不要なソースコードを削除する方法を検討している\cite{Vzquez2019SlimmingJA}．

従来研究では，デッドコード，未使用変数/関数，到達不能コードなどの不要なソースコード（以降，不要コード）を検出する手法が提案されている\cite{detect-dead-code}．しかし，多くのソフトウェアには不要コードが含まれているにもかかわらず，削除されるのは一部に限られる．
たとえば，リファクタリングにおける機能統合の結果として行われる場合であっても，統合直後に削除されるとは限らず，一定期間にわたり，削除予定のメソッドと統合先のメソッドに類似するソースコードが共存する．
大規模ソフトウェアから依存関係を取り除き，コンポーネントを削除する手法としてChuangら\cite{remove-dependency}はコールグラフ生成ツールを用いて，未使用の依存関係を検出し，他のコンポーネントとの論理的関係に基づく意思決定図を生成する手法を提案している．
しかし，削除の意思決定は，最終的に経験豊富な開発者の判断に委ねられる．

そこで本研究では，ソフトウェアのメソッドが削除に至るまでの過程を追跡し，類似するコードを
有する他のメソッドの有無，およびそれらメソッドとの類似度の推移を調査する．具体的には，N-gramに基づくクローン検出ツールNIL\cite{NIL}を用い，同一プロジェクト内のメソッド間の類似度を算出し，メソッド間のコードクローンの有無および類似度とメソッドの削除率の関係を分析する．

ケーススタディとして，PythonライブラリPandasにおけるメソッド43,308件を対象に分析した結果，クローンを持たないメソッドの削除率がクローンを持つメソッドより高いこと，メソッド統合前にはクローン類似度が段階的に上昇する一方，削除前にはそのような変化が見られないことを明らかにした．\todo{結果に（オチ）ついては最後に再確認}

以降，本論文では，\ref{chap:deletecode}章で不要コードの背景と関連研究，本研究の研究課題を述べる．\ref{chap:approach}章では，本研究の分析手法を述べ，\ref{chap:case-study}章では，設定したRQにおけるそれぞれの，結果を述べる．続く，\ref{chap:discussion}章では，本研究の分析による考察を述べ，\ref{chap:threat-to-validity}章では，本研究の妥当性の脅威を述べる．最後に\ref{chap:conclusion}章で本論文をまとめる．


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{不要コード}
\label{chap:deletecode}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{不要コードの種類}

ソフトウェアにとっての不要コードはステークホルダやタイミングによって異なる．クライアントにとって必要な機能であってもライブラリ開発者にとっては運用，保守を継続することを期待しないソースコードもある．例えば，後方互換性を維持するだけのソースコードはライブラリにとっては不要であるが，古いバージョンを使用するクライアントにとっては必要である．また，頻繁に使用されるライブラリのAPIであっても，より効率的な代替APIが登場すれば不要とみなされることがある．

不要コード\cite{static-analysis}\cite{increase-maintainability}の代表例として，デッドコード\cite{static-analysis}\cite{dynamic-analysis}\cite{decrease-readability}と未実行コード\cite{static-analysis}\cite{increase-maintainability}が挙げられる．デッドコードはプログラム中で到達不可能なソースコードであり，未実行コードは観測期間において一度も実行されないソースコードである．ただし，開発者がコードを削除する理由はデッドコードや未実行コードに限らない．
例えば，Pythonのpandas-dev/pandas\footnote{\url{https://github.com/pandas-dev/pandas}}プロジェクトでは，v0.25.0における\texttt{pandas/io/common.py}内のメソッド\texttt{\textunderscore stringify\textunderscore path}が，他のファイルから呼び出されていたにもかかわらず，入出力APIに関するメソッドの非公開化に伴い削除されている\footnote{\url{https://github.com/pandas-dev/pandas/commit/0df8858752}}．
このように，機能として使用されているメソッドであっても，削除されることがある．
本研究では，不要コードの中でも特に，削除されたメソッドに着目し，その削除に関わる定量的特徴を調査する．

\section{不要コードが引き起こす問題}

不要コードがコードベースに蓄積することは，保守性と可読性の両面で問題を引き起こす．Ederら\cite{increase-maintainability}は，不要コードが保守コストの増加を引き起こすことを示している．ソースコードの修正時に，未使用のソースコードも同時に修正する必要があるため，無駄なコストが発生する．また，Romanoら\cite{decrease-readability}は，コードベースを理解する際に不要コードを読んでしまうことで，ソースコード理解の有効性や効率が低下することを示している．
したがって，開発者がコード削除を適切に判断するための指標が求められる．

\section{関連研究}
\label{sec:related-work}

\subsection{不要コードの検出手法}

不要コードの検出手法として，動的解析と静的解析に基づく手法が提案されている．

動的解析に基づく手法として，観測期間において実行されていないソースコードを検出し，自動で削除する手法が提案されている\cite{dynamic-analysis}．この手法では，ソフトウェア中のさまざまなコンポーネントにログを組み込み，実環境で一定期間運用することで実行状況のログを取得する．その後，実行履歴がないコンポーネントを不要コードと判定する．
ただし，エラー処理や復旧用のソースコードのように，観測期間において実行されないため不要コードとして誤検出される場合がある．

静的解析に基づく手法として，依存関係に着目し，他との依存関係を持たないデッドコードを検出する手法が提案されている\cite{detect-dead-code}．この手法では，プログラムの制御フローや依存グラフを解析し，到達不可能なコードを特定する．ただし，リフレクションのように動的に依存関係が決まる場合には，依存関係を持たないと誤判定される可能性がある．

これらの手法は，実行状況や依存関係に基づいて不要コードを検出することを目的としている．しかし，機能的には使用されているが開発者の判断で削除対象となるコード（例えば，APIの呼び出し方法の変更や機能統合による削除）の検出に向けた議論は十分でない．

\subsection{削除コードの実証分析}

削除されたコードの特徴を事後的に分析する研究も行われている．Haasら\cite{static-analysis}は，削除されたファイルの安定性と中心性は削除されなかったファイルよりも有意に安定性が高く，中心性が低いことを示した．つまり，長期間，変更が行われず，重要でないファイルは削除されやすいということである．

Bhattaら\cite{study-of-test-deletion}は，テストコードの削除に着目し，削除されたテストメソッドの83.2\%はテストクラスごと削除され，7.0\%は冗長なテストであったことを明らかにした．さらに，削除されたテストメソッドの91.4\%はプロダクションコードの廃止による副次的な削除であった．

Sawantら\cite{why-deprecated}は，メソッドが非推奨になる理由をコミット履歴や不具合管理システムを基に調査し，分類した．その結果，「新機能の導入に伴う古い機能の非推奨化」，「機能上の欠陥による非推奨化」，「デザインパターンを活用した新バージョンへ移行するために古い実装方法を非推奨化」といった3種類で全体の約72\%を占めていた．

これらの研究は，削除の理由や特徴を事後的に分析している．ソフトウェア再構成として，メソッドを削除するためには，削除候補と判断するための予兆を明らかにすることが期待される．


\section{研究課題}

\ref{sec:related-work}節で述べたように，従来研究では不要コードの検出手法や削除理由の事後分析が行われてきた．メソッドの削除には，機能としてのサポート終了に伴うものだけでなく，リファクタリングにおける機能統合の結果として行われる場合もある．機能統合によるメソッド削除の場合，統合直後に削除が行われるとは限らず，一定期間にわたり，削除予定のメソッドと統合先のメソッドに類似するソースコードが共存すると考えられる．
そこで本研究では，ソフトウェアのメソッドが削除に至るまでの過程を追跡し，類似するコードを有する他のメソッドの有無，およびそれらメソッドとの類似度の推移を調査する．

本研究では次の2つのRQ（Research Question）を設定する．
\begin{itemize}
  % \item RQ1: メソッド間の類似度は，次バージョンにおける削除率とどのように関連しているか
  \item RQ1: 類似するコードを持つメソッドと持たないメソッドで削除率に差があるか
  \item RQ2: メソッドが削除・統合される前に，メソッド間の類似度はどのように変化するか
\end{itemize}

機能統合によるメソッド削除であれば，統合先となる類似メソッドが同一プロジェクト内に存在すると考えられる．そこで，まず類似するコードの有無と削除率の差を調査する．
次に，機能統合によるメソッド削除であれば，削除に至るまでの過程でメソッド間の類似度が変化する可能性がある．この変化パターンを明らかにすることで，メソッド削除の指標を検討する．


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{アプローチ}
\label{chap:approach}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{概要}

本章では，OSSのバージョン更新に伴い，メソッドを追跡する方法を述べる．バージョン間のメソッドの追跡方法（\ref{sec:detect-delete-method}節），バージョン更新に伴うメソッド間の類似度の算出手法（\ref{sec:clone-analysis}節），バージョン更新に伴い変更されたメソッドの中から削除されたメソッドの分類方法（\ref{sec:temporal-tracking}節）を述べる．

\section{バージョン間のメソッドの追跡方法}
\label{sec:detect-delete-method}

\noindent\emph{1. 解析対象バージョンの選定}

本研究では，ソースコードの変更履歴がGitHub\footnote{GitHub: \url{https://github.com/}}で公開されているオープンソースソフトウェア (OSS: Open Source Software) を分析対象とする．特に，OSSプロジェクトはGitHubにおいてリポジトリの特定のコミットに名前を付与する機能「タグ」にバージョン番号を付することが多く，本研究ではOSSプロジェクトがセマンティックバージョニング\footnote{\url{https://semver.org/}}の命名規則に従うメジャーおよびマイナーバージョンの変遷に着目するため，パッチバージョンが0（例：v1.2.0）であるバージョンを対象とする．パッチバージョンはリリース間隔が短いため分析対象外とする．ただし，バージョン番号の末尾にプレリリース識別子（rc，dev）を含むバージョンは対象外とする．

\noindent\emph{2. メソッドのシグネチャとボディの取得}

バージョン間でメソッドの生存，統合，削除を分類するために，取得した各バージョンにおけるソースコードを収集する．本研究ではPython言語で実装されたソースコードを対象とするため，Pythonファイル (.py) のみを収集する．収集したPythonファイルは，抽象構文木 (AST: Abstract Syntax Tree) に変換後，このASTから各メソッドの一意な識別子として「ファイルパス，クラス名.メソッド名，引数，戻り値の型」からなるシグネチャを構成する．同時に，メソッドのボディもASTから取得し，構文要素ごとのトークン列に変換してリストとして保持する．

\noindent\emph{3. バージョン間の同一メソッドの追跡と分類}

隣接するバージョン間でメソッドを追跡し，各メソッドの状態を分類する．追跡は次の2段階（\emph{3a}と\emph{3b}）で行う．

%--------------
\begin{figure}[ht]
  \centering
  \includegraphics[width=0.5\linewidth]{@Bachelor2025_Yoshida/Yoshiba_fig/classify-method.pdf}
  \caption{バージョン間での生存/統合/削除の分類}
  \label{fig:classify-method}
\end{figure}
%--------------

\noindent\emph{3a. シグネチャによる同一メソッドの判定}

隣接するバージョン（$V_{k}$と$V_{k+1}$）の間でシグネチャが完全に一致するメソッドを同一と見なし，対象のメソッドがバージョン$V_{k+1}$において削除されていない（本研究では「生存」と呼ぶ．図\ref{fig:classify-method}ケース(1)を参照）と判断する．

\noindent\emph{3b. 類似度による同一メソッドの判定}

手順3aは，メソッドのボディが同一であっても，メソッド名の変更（リネーム）やメソッドがファイルを移動する場合，シグネチャが変更されるため，を受けたメソッドはバージョン間で同一のメソッドと判定できない．
そこで，手順3aでバージョン更新後に同じシグネチャが見つからない場合でも，特に類似するメソッドが存在すれば生存と判定する（図~\ref{fig:classify-method}ケース(2)を参照）．本研究では，メソッドのボディの類似度にコードクローン検出器を用いる．

コードクローンは，ソースコード中に存在する同一または類似するコード断片を指す\cite{code-clone-survey}．コードクローンは，開発を効率化するために，既存のソースコードを複製した後に修正することで作成される．同じ修正を複数箇所に適用するための保守コストの増加や不整合の原因となる欠点がある．従来研究では，コードクローン検出器が多数提案されている\cite{code-clone-review}．
本研究では，バージョン更新前後において類似するボディを有するメソッドを追跡するためにコードクローン検出器NIL\cite{NIL}を用いる．NILは，N-gramの逆インデックスとLCS（最長共通部分列）を組み合わせることで，大規模コードベースにおいても効率的にクローンを検出する手法である．特に，多くの変更が加えられた大規模な差分クローンの検出に優れている．


コードクローン検出器を用いた，バージョン前後のメソッド間の類似度の算出方法を述べる．
バージョン $k$ ($1 \le k < K$) における $M$ 個のメソッドの集合を
$V_k = \{c_i \mid 1 \le i \le M\}$とする．
% $V_{k} = \{c_1, c_2, \dots, c_M\}$ とする．
各メソッド $c_i \in V_k$ のボディをトークンに変換しているため，そのトークン列に対して N-gram を生成する．得られた N-gram の集合を$G(c_i)$と表す．
本研究では，従来研究と同様に 5-gram を採用する\cite{NIL}．

バージョン更新後に含まれる$N$個のメソッドの集合$V_{k+1} = \{c_j \mid 1 \le j \le N\}$とするとき，$V_{k}$における各メソッド$c_i$と，$V_{k+1}$における全てのメソッド$c_j$との類似度を算出する．
類似度は次の式で算出する．
\begin{equation}
  \label{eq:sim-verif}
  \text{Sim}_{\text{verif}}(c_i) = \frac{\text{LCS}(c_i, c_j)}{|c_i|}
\end{equation}

%%%%%%%%%%%%%%%%%%%%%%%卒論用
ここで，具体的なトークン列を用いた計算例をListing~\ref{lis:method_c_i}とListing~\ref{lis:method_c_j}を用いて示す．
$c_{i}$のトークン列は
\texttt{[def, get\textunderscore data, self, :, return, self, ., value]}
となり，$c_{j}$のトークン列は
\texttt{[def, get\textunderscore cleaned \textunderscore data, self, value, :, return, self, ., \textunderscore data]}
となる．
したがって，$|c_{i}| = 8$となり，$|c_{j}| = 9$となる．
ここで，最長共通部分列は\texttt{[def, self, :, return, self, .]}である．つまり，$\text{LCS}(c_{i}, c_{j}) = 6$である．
これを，式\ref{eq:sim-verif}に当てはめると，
\[\text{Sim}_{\text{verif}}(c_i, c_j) = \frac{6}{\min(8, 9)} = 0.75\]となる．この時，これらのメソッドの類似度を0.75と判定する．

\begin{figure}[t]
  \centering
  \begin{minipage}[t]{0.47\linewidth}
    \begin{lstlisting}[
      caption=メソッド$c_{i}$,
      label=lis:method_c_i,
      captionpos=t,
      columns=flexible
    ]
def get_data(self):
    return self.value
    \end{lstlisting}
  \end{minipage}\hfill
  \begin{minipage}[t]{0.47\linewidth}
    \begin{lstlisting}[
      caption=メソッド$c_{j}$,
      label=lis:method_c_j,
      captionpos=t,
      columns=flexible
    ]
def get_cleaned_data(self, value):
    return self._data
    \end{lstlisting}
  \end{minipage}
\end{figure}
%%%%%%%%%%%%%%%%%%%%%%%卒論用

式(\ref{eq:sim-verif})の$\text{LCS}(c_i, c_j)$は，$c_i$と$c_j$におけるトークン列間で，順序を保ったまま一致する最長共通部分列の長さである．ただし，LCSの計算コストが高いため，従来研究\cite{NIL}と同様に式~\ref{eq:sim-filt}を用いたフィルタリングフェーズを導入し，明らかに異なるメソッド対を事前に除外する．このフィルタリングにより，類似度が0.1未満のメソッド対に対するLCS計算を省略し，全体の実行時間を短縮する．

\begin{equation}
  \label{eq:sim-filt}
  \text{Sim}_{\text{filt}}(c_i, c_j) = \frac{|G(c_i) \cap G(c_j)|}{|G(c_i)|}
\end{equation}

%%%%%%%%%%%%%%% 卒論用
ここで，具体例を用いてフィルタリングフェーズを説明する．Listing~\ref{lis:method_c_i}のメソッド$c_{i}$の5-gram集合は
\begin{align*}
  G(c_i) = \bigl\{ \;
    & \texttt{[def, get\_data, self, :, return]}, \\
    & \texttt{[get\_data, self, :, return, self]}, \\
    & \texttt{[self, :, return, self, .]}, \\
  & \texttt{[:, return, self, ., value]} \; \bigr\}
\end{align*}
となり，Listing~\ref{lis:method_c_j}のメソッド$c_{j}$の5-gram集合は
\begin{align*}
  G(c_j) = \bigl\{ \;
    & \texttt{[def, get\_cleaned\_data, self, value, :]}, \\
    & \texttt{[get\_cleaned\_data, self, value, :, return]}, \\
    & \texttt{[self, value, :, return, self]}, \\
    & \texttt{[value, :, return, self, .]}, \\
  & \texttt{[:, return, self, ., \_data]} \; \bigr\}
\end{align*}
となる．
これらのメソッドで共通する5-gramは存在しないため，\[\text{Sim}_{\text{filt}}(c_i, c_j) = \frac{|G(c_i) \cap G(c_j)|}{\min(|G(c_i)|, |G(c_j)|)} = \frac{0}{\min(4, 5)} = 0\]となる．
したがって，これらのメソッド対に対してLCS計算は行われない．
%%%%%%%%%%%%%%% 卒論用

本研究では，コードクローン検出器NILにおいてクローンと判断する閾値を踏襲し，メソッド間の類似度が0.7以上であるとき，バージョン更新後も機能が生存していると判定する．ただし，バージョン更新前後でシグネチャが異なり，且つバージョン変更前の複数のメソッドが更新後に同一のメソッドと類似している場合は「統合」と呼ぶ（図~\ref{fig:classify-method}ケース(3)を参照）．

\noindent\emph{4. メソッドの分類}

手順3の追跡に基づき，$V_k$に存在する各メソッドを図~\ref{fig:classify-method}のように3種類に分類する．
\begin{description}
  \item[生存メソッド: ] 手順3aにより，$V_{k+1}$にシグネチャが一致するメソッドが存在する（図~\ref{fig:classify-method}ケース(1)）．あるいは，手順3aでは対応が見つからないが，手順3bにより，$V_{k+1}$に類似するメソッドが1つのみ存在する（図~\ref{fig:classify-method}ケース(2)）．
  % 複数の候補メソッドが存在する場合は，最も類似度が高いメソッドに形を変えて生存したと判定する．
  \item[統合メソッド: ] 手順3bにより，$V_{k}$において複数のメソッドが，$V_{k+1}$において同一のメソッドと類似する場合，複数のメソッドが一つのメソッドにまとめられたと判定する（図~\ref{fig:classify-method}ケース(3)）．
  % 候補メソッドが複数存在し，かつ，最も類似度が高いメソッドが既に他の$V_{k}$のメソッドと対応付けられているもの．
  \item[削除メソッド: ] 手順3a，手順3bのいずれでも$V_{k+1}$に対応するメソッドが見つからない場合，「削除」と判定する（図~\ref{fig:classify-method}ケース(4)）．
\end{description}

\section{クローンの有無・類似度と削除の関係分析}
\label{sec:clone-analysis}

\begin{figure}[ht]
    \centering
    \includegraphics[width=0.7\linewidth]{@Bachelor2025_Yoshida/Yoshiba_fig/feature-sim.pdf}
    \caption{バージョン内におけるメソッド間の類似度の算出}
    \label{fig:calc-sim}
\end{figure}

\ref{sec:detect-delete-method}節ではバージョン間において，メソッド間の類似度を用いることで，メソッドの追跡を行ったが，本節では同一バージョン内のメソッド間の類似度に着目する．
各バージョン$V_k$に対し，コードクローン検出器NILを用いて同一バージョン内の全メソッド間の類似度を算出する．算出結果に基づき，あるバージョン内で一つ以上の類似相手を持つメソッドを「類似あり」，それ以外を「類似なし」と定義する．ここで，あるメソッドが複数の類似相手を持つ場合，そのメソッドの代表類似度$Sim$は，全ての類似相手との類似度の中央値として算出する．

次に，\ref{sec:detect-delete-method}節の手法により，各メソッドを隣接バージョン$V_k$と$V_{k+1}$の間で追跡し，「生存メソッド」または「削除メソッド」にラベル付けする．以上より，メソッドを（類似あり/なし）$\times$（生存/削除）の4群に分け，バージョンごとの削除数・生存数・削除率の分布差を検定する．ここで，各バージョン遷移における削除率は，削除メソッド数を当該群の総メソッド数で除した値として定義する．

さらに，「類似あり」群に限り，高類似度群（$90\% \leq Sim$）と低類似度群（$70\% \leq Sim < 90\%$）に分け，削除率の分布が異なるかを検定する．

本データはバージョン遷移を単位とした対応のある構造を持つため，群間差の検定にはノンパラメトリックな対応あり検定であるウィルコクソンの符号付順位検定を用いる．同検定は順位に基づく手法であり，分布の非正規性や外れ値に頑健である．効果量としては，順位に基づく効果量（matched-pairs rank-biserial correlation：$r_{\mathrm{rb}}$）を用いる．

\section{メソッドの状態分類と類似度の時系列追跡}
\label{sec:temporal-tracking}

\begin{figure}[ht]
  \centering
  \includegraphics[width=0.7\linewidth]{@Bachelor2025_Yoshida/Yoshiba_fig/sim-change.pdf}
  \caption{最終状態での生存/統合/削除群の分類}
  \label{fig:classify-survival-deleted-merged}
\end{figure}

\ref{sec:detect-delete-method}節の手順4では，各バージョン遷移においてメソッドを生存・削除の2群に分類した．本節では，各メソッドの最終的な結末に基づき，以下の3群に分類する．

\begin{description}
  \item[生存群: ] \memo{さらに，ここを吸収したメソッドと生存したメソッドに分ける}追跡対象期間の最終バージョン遷移において，生存メソッドと判定されたメソッド．すなわち，観測期間の最後まで削除されなかったメソッドである．
  \item[統合群: ] \memo{吸収されたメソッド}最終バージョン遷移において，統合メソッドと判定されたメソッド．すなわち，そのメソッドのコードが他のメソッドに吸収・統合されたと考えられるメソッドである．
  \item[削除群: ] 最終バージョン遷移において，削除メソッドと判定されたメソッド．すなわち，プロジェクトから消滅したメソッドである．
\end{description}

次に，各メソッドの全バージョン遷移にわたる履歴を相対時間で正規化する．メソッドが結末（生存/統合/削除）を迎えたバージョン遷移を$t = 0$とし，そこから過去方向へ$t = -1, -2, \dots$と遡る．各時点$t$において，当該メソッドの同一バージョン内に存在する類似相手とのメソッド間の類似度（中央値）を記録する．この正規化により，異なるバージョンで結末を迎えたメソッド同士でも，「結末の何バージョン前か」という統一的な時間軸でメソッド間の類似度の推移を比較できる．




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{ケーススタディ}
\label{chap:case-study}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{データセット}

\subsection{対象言語の選定}
本研究では，Pythonで開発されたOSSプロジェクトを分析対象とする．Pythonを選定した理由は以下の3点である．

まず，Pythonは広く普及しているプログラミング言語である．パッケージリポジトリPyPI\footnote{\url{https://pypi.org/}}には50万以上のパッケージが登録されている．Zhongら\cite{client-action-on-deprecation}もPythonエコシステムにおけるパッケージの非推奨化を研究対象としており，Pythonプロジェクトにおけるメソッド削除パターンの知見は広範なソフトウェア開発者にとって有益である．

次に，本研究のアプローチでは，Pythonファイルを抽象構文木（AST）へパースし，メソッドのシグネチャとボディを抽出する．Pythonは標準ライブラリとして\texttt{ast}モジュール\footnote{\url{https://docs.python.org/3/library/ast.html}}を提供しており，サードパーティツールに依存することなく，全ての有効なPythonソースコードを正確にパースできる．

最後に，Pythonは動的型付け言語であるため，静的解析のみではメソッドの呼び出し関係を完全に解決することが困難である．このことは，\ref{chap:deletecode}章で述べた不要コード検出手法の限界をさらに大きくする．したがって，呼び出し関係ではなくクローン類似度に基づく本研究のアプローチは，動的型付け言語において特に有効であると考えられる．

表~\ref{tab:candidate-projects}に，主要な候補プロジェクトの比較を示す．

\begin{table}[ht]
  \centering
  \caption{候補プロジェクトの比較}
  \label{tab:candidate-projects}
  \scalebox{0.85}{
    \begin{tabular}{l|rrcccl}
      \hline
      プロジェクト & Stars & メジャー遷移 & 開発期間 & Python比率 & 非推奨ポリシー & 備考 \\
      \hline
      pandas       & 47k  & 3回 & 14年 & 高 & あり & データ分析ライブラリ \\
      NumPy        & 31k  & 2回 & 18年 & 低 & あり & コアがC/Cython \\
      scikit-learn & 64k  & 2回 & 14年 & 中 & あり & 0.xが長期間 \\
      Django       & 86k  & 5回 & 19年 & 高 & あり & Webフレームワーク \\
      Flask        & 71k  & 3回 & 14年 & 高 & あり & 小規模 \\
      Requests     & 53k  & 2回 & 13年 & 高 & なし & APIが安定 \\
      \hline
    \end{tabular}
  }
\end{table}

各候補プロジェクトが本研究の対象として不適切な理由を以下に述べる．NumPyは，コア部分がC/C++やCythonで実装されており，Python比率が低い．本研究のAST解析では\texttt{.py}ファイルのみを対象とするため，NumPyの主要なメソッドの多くが分析対象外となる．scikit-learnは，バージョン0.xの期間が長く（1.0のリリースは2023年），メジャーバージョン遷移が少ない．また，Estimatorパターン（fit/predict/transform）に基づく統一的なAPI設計により，クローンパターンにドメイン特有の偏りが生じる可能性がある．Djangoは大規模かつ長期間開発されているが，Webフレームワークであるため，メソッドの性質（ビュー，ミドルウェア，ORM）や削除理由（セキュリティ起因の削除等）がデータ分析ライブラリとは根本的に異なる．Flaskは，コアのコードベースが小規模であり，統計分析に十分なメソッド数が得られない．Requestsは，意図的にミニマリストなAPI設計を採用しており，メソッドの削除がほとんど発生しない．また，明確な非推奨ポリシーも存在しない．

以上の比較から，pandasが全ての基準を最もバランスよく満たしていると判断し，対象プロジェクトとして選定した．pandasはGitHub\footnote{\url{https://github.com/pandas-dev/pandas}}上で公開されており，47,000以上のStarを持つ．0.x，1.x，2.xの3つのメジャーバージョンを有し，各メジャーバージョン遷移時にはAPIの大幅な整理が行われている．また，pandasは明確な非推奨ポリシー\cite{pandas-deprecation-policy}を持ち，\texttt{FutureWarning}による事前警告を経た上でメソッドの削除が行われるため，開発者の計画的な判断に基づく削除を分析対象とすることができる．

\subsection{分析対象データの概要}

表~\ref{tab:dataset-summary}に，pandasプロジェクトの分析対象データの概要を示す．分析対象期間はv0.4.0（2011年9月）からv2.3.0（2025年6月）までの約14年間であり，セマンティックバージョニングに従うメジャーおよびマイナーバージョン（パッチバージョンが0のタグ）を抽出した結果，32バージョンが対象となった．メソッド数はv0.4.0の1,303件からv2.3.0の21,392件へと約16倍に増加しており，全バージョンにわたって追跡された一意なメソッドは40,264件である．

\begin{table}[ht]
  \centering
  \caption{分析対象データの概要}
  \label{tab:dataset-summary}
  \scalebox{0.9}{
    \begin{tabular}{l|r}
      \toprule
      項目 & 値 \\
      \midrule
      分析期間 & 2011年9月 -- 2025年6月（約14年間） \\
      対象バージョン数 & 32 \\
      メジャーバージョン遷移 & 2回（0.x$\to$1.x, 1.x$\to$2.x） \\
      初期メソッド数（v0.4.0） & 1,303 \\
      最終メソッド数（v2.3.0） & 21,263 \\
      一意なメソッド総数 & 40,264 \\
      削除メソッド数 & 7,636 \\
      統合メソッド数 & 11,723 \\
      生存メソッド数 & 20,905 \\
      \bottomrule
    \end{tabular}
  }
\end{table}

\section{RQ1: メソッド間の類似度は，次バージョンにおける削除率とどのように関連しているか}

\subsection{概要}
ソフトウェアの規模拡大を抑制する手段の一つに，類似するコードを持つメソッドの整理・統合がある．一方で，独自の機能を持つメソッドも機能自体の廃止に伴い，削除される可能性がある．本節では，メソッド間の類似度という静的な特徴が，これら異なる要因による削除とどのように関連しているかを調査する．
具体的には，メソッドを「類似なし」「類似あり」「低類似」「高類似」に分類し，それぞれの削除率の傾向を比較分析する．

\subsection{結果}

\begin{table*}[ht]
  \centering
  \caption{ウィルコクソンの符号付き順位検定を用いた，メソッドの類似度と削除/生存の関係}
  \scalebox{0.95}{
  \begin{tabular}{l|rrcc|rrcc}
    \toprule
    & 類似なし & 類似あり & p値 & $r_{\mathrm{rb}}$ & 低類似 & 高類似 & p値 & $r_{\mathrm{rb}}$ \\
    \midrule
    平均削除数 & 155 & 92 & $6.52 \times 10^{-9}$ & 0.73 & 69 & 23 & $8.79 \times 10^{-6}$ & 0.80 \\
    平均生存数 & 5,464 & 4,286 & $9.31 \times 10^{-10}$ & 0.77 & 3,475 & 810 & $9.31 \times 10^{-10}$ & 1.10 \\
    平均削除率 & 0.033 & 0.025 & $1.45 \times 10^{-4}$ & 0.48 & 0.024 & 0.029 & $3.38 \times 10^{-2}$ & 0.38 \\
    \bottomrule
  \end{tabular}
  }
  \label{tab:test-clone}
\end{table*}

表~\ref{tab:test-clone}は，隣接バージョン遷移におけるメソッドの削除数・生存数・削除率の平均を群別に算出し，ウィルコクソンの符号付順位検定で群間差を検定した結果を示す．

まず，削除率に着目する．類似なし群のメソッドの平均削除率（0.033）は類似あり群のメソッドの平均削除率（0.025）を有意に上回っており（$p < 0.01$，$r_{\mathrm{rb}} = 0.48$，中程度の効果量），類似なしメソッドの方が削除されやすい傾向が確認された．なお，削除数・生存数の絶対値についても，類似なし群が類似あり群を有意に上回っていた（$p < 0.01$，$r_{\mathrm{rb}} = 0.73, 0.77$，大きな効果量）．

さらに，類似あり群内で高類似群（$90\% \leq Sim$）と低類似群（$70\% \leq Sim < 90\%$）を比較すると，高類似群のメソッドの平均削除率（0.029）が低類似群のメソッドの平均削除率（0.024）を有意に上回っていた（$p < 0.01$，$r_{\mathrm{rb}} = 0.38$，中程度の効果量）．なお，削除数，生存数の絶対値については，低類似群の方が平均削除数，平均生存数，共に有意に上回っていた（$p < 0.01$，$r_{\mathrm{rb}} = 0.80, 1.10$，大きな効果量）．

以上の結果から，類似するコードを持たないメソッドが最も削除されやすく，類似するコードを持つメソッドの中ではメソッド間の類似度が高いほど削除されやすいという傾向が確認された．この知見の解釈は第\ref{chap:discussion}章で議論する．

\section{RQ2: メソッドが削除・統合される前に，メソッド間の類似度はどのように変化するか}

\subsection{概要}

RQ1では，ある時点でのメソッド間の類似度の高低が削除に関係することを示した．本節では，メソッドが最終的に削除・統合のいずれの結末を迎えるかによってメソッドを分類し，結末を迎えるまでのメソッド間の類似度の推移を調査する．具体的には，\ref{sec:temporal-tracking}節の手法を用い，3種類（統合先メソッド・統合元メソッド・削除メソッド）のメソッドが持つメソッド間の類似度変化を相対時間軸で可視化し，比較する．

\subsection{結果}

図~\ref{fig:deletion-survival-all}は，メソッドが持つメソッド間の類似度の分布を示す箱ひげ図である．箱ひげ図はメソッド間の類似度の分布を種類別に示し相対時間ごとに並べる．図~\ref{fig:deletion-survival-all}は各時点における種類ごとのメソッドの総数を示す．横軸の相対時間$t = 0$はメソッドが統合/削除を迎えた時点を表す．負の値は相対時間0を基準として，過去のバージョンを示す．逆に正の値は相対時間0を基準として，未来のバージョンを示す．

\noindent\textbf{メソッド間の類似度の推移}

図~\ref{fig:boxplot-deletion}に着目する．削除メソッドのメソッド間の類似度の中央値は，$t = -16$から$t = 0$まで約75\%から85\%の範囲で安定して推移しており，削除に向けた明確な変化傾向は観察されなかった．

統合元メソッドのメソッド間の類似度の中央値は，$t = -10$付近では約83\%から85\%であるが，$t = 0$に近づくにつれて上昇し，$t = 0$では約95\%から100\%に達した．

図~\ref{fig:boxplot-absorber}に示すように，統合先メソッドのメソッド間の類似度の中央値は，統合前（$t = -16$から$t = 0$）では80\%から85\%であるのに対し，統合後（$t = 1$以降）では80\%未満に低下している．

\noindent\textbf{メソッド数の推移}

図~\ref{fig:areaplot-deletion}の統合元メソッドに着目する．$t = 0$の時点では，11,745件のメソッドが存在している．一方，$t = -1$の時点では，4,831件のメソッドが存在している．つまり，6,914件のメソッドは$t = -1$と$t = 0$の間で突如出現し，それらのメソッドが統合されたことがわかる．なお，約6,914件のメソッドは，「元々存在しており，直前でメソッド間の類似度が70\%を超えた場合」と「元々存在しておらず，メソッド間の類似度が70\%以上の状態で追加された場合」の2通りがある．分析の結果，「元々存在しておらず，メソッド間の類似度が70\%以上の状態で追加された」メソッドが6,711件であり，$t = 0$と$t = -1$の間で出現した全ての統合元メソッド6,914件のうち，約97\%であった．つまり，メソッドの統合は直前に大量の類似メソッドが追加されることがわかる．新規追加メソッドの59.7\%はメソッド間の類似度が100\%であった．また，これらのメソッド名には\texttt{f}，\texttt{wrapper}，\texttt{inner}が多く，49.5\%はテストファイルに含まれていた．

また，図~\ref{fig:areaplot-absorber}に示すように，$t = 0$の時点で1,607件のメソッドが統合先となったが，次のバージョンでは約半数の800件に減少した．図~\ref{fig:areaplot-deletion}と比較すると，統合先メソッド数は統合元メソッド数よりも少ない．

以上より，RQ2に対する回答として，統合元メソッドでは統合前にメソッド間の類似度の上昇が観察され，統合メソッドの急増は新規追加メソッドの即時統合が主因であった．統合先メソッドでは統合後に類似度の低下が観察された．一方，削除前にはメソッド間の類似度の変化は観察されなかった．


 \begin{figure}[ht]
    \centering
    \includegraphics[width=\linewidth]{@Bachelor2025_Yoshida/Yoshiba_fig/deletion_survival_boxplot_deletion.pdf}
    \caption{類似度分布（統合元メソッド / 削除メソッド）}
    \label{fig:boxplot-deletion}
  \end{figure}

  \begin{figure}[ht]
    \centering
    \includegraphics[width=\linewidth]{@Bachelor2025_Yoshida/Yoshiba_fig/deletion_survival_boxplot_absorber.pdf}
    \caption{類似度分布（統合先メソッド）}
    \label{fig:boxplot-absorber}
  \end{figure}

  \begin{figure}[ht]
    \centering
    \includegraphics[width=\linewidth]{@Bachelor2025_Yoshida/Yoshiba_fig/deletion_survival_areaplot_deletion.pdf}
    \caption{メソッド数推移（統合元メソッド / 削除メソッド）}
    \label{fig:areaplot-deletion}
  \end{figure}

  \begin{figure}[ht]
    \centering
    \includegraphics[width=\linewidth]{@Bachelor2025_Yoshida/Yoshiba_fig/deletion_survival_areaplot_absorber.pdf}
    \caption{メソッド数推移（統合先メソッド）}
    \label{fig:areaplot-absorber}
  \end{figure}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{考察}
\label{chap:discussion}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\ref{chap:case-study}章のRQの結果を踏まえ，ソフトウェア再構成の観点からメソッドの削除指標について考察する．

\section{メソッド削除における2つのメカニズム}

RQ1では，類似するコードを持たないメソッドの削除率が類似するコードを持つメソッドの削除率よりも有意に高いことが示された．この結果について，類似するコードの有無が「機能需要のシグナル」として機能している可能性を議論する．

同一プロジェクト内に類似するコードを持つメソッドが複数存在することは，その類似するコードが複数の文脈で必要とされていることを意味する．すなわち，類似するコードを持つメソッドは，プロジェクト内で繰り返し利用される実装パターンを表しており，そのパターンに対する需要が存在する限り削除されにくい．

一方，類似するコードを持たないメソッドは，特定の用途に限定された機能である可能性が高い．例えば，後方互換性を維持するためのラッパーメソッドや，一時的なテスト補助関数などは，他に類似するメソッドを持たず，その用途が不要になれば削除対象となりうる．

さらに，類似するコードを持つメソッドの中でも，より高類似（$90\% \leq Sim$）なコードを含むメソッドの削除率が低類似（$70\% \leq Sim \leq 90\%$）なコードを含むメソッドの削除率を上回っていた点について考察する．類似度が90\%を超えるコードを持つメソッドは，ほぼ同一のコードを含む別メソッドが存在することを意味し，機能の重複を示す指標と解釈できる．一方，70\%から90\%類似するコードを含むメソッドは，共通する基盤を持ちながらも各メソッドが固有の役割を担っている可能性が高く，単純な統合対象にはなりにくい．

以上より，メソッドの削除には少なくとも2つの異なるメカニズムが存在すると考えられる．第一に，類似するコードを持たないメソッドが機能自体の廃止に伴い削除される「\textbf{機能廃止型}」の削除である．第二に，高類似なコードを含むメソッドが重複整理のために一方が削除される「\textbf{冗長性解消型}」の削除である．両者はメカニズムが異なるが，いずれも削除率を高める方向に作用しており，RQ1で観察された非単調なパターン（類似するコードなしが最も高く，次いで高類似なコードあり，低類似なコードありが最も低い）を説明する．

\section{メソッド統合の予兆としての類似度上昇}
\label{sec:developer-behavior}

RQ2の結果は，統合と削除における開発者の行動パターンに質的な違いがあることを示唆している．

最終的に削除されたメソッドでは，削除に向けてメソッド間の類似度に大きな変化が観察されなかった．これは，削除がコードレベルの段階的な変化を伴わず，ある時点で突然決定されることを意味する．この行動パターンは，削除がAPIポリシーの見直しやメジャーバージョンのリリース，依存ライブラリのバージョン更新，破壊的変更といったプロジェクトレベルの意思決定に起因することと整合する．

一方，統合元メソッドでは，メソッド間の類似度が統合時点に近づくにつれて急激に上昇する傾向が観察された．このような類似度の上昇は，偶然ではなく，開発者がリファクタリングの過程でメソッドを意図的に近づけていくプロセスを反映していると考えられる．すなわち，メソッドの統合は一度の変更で完了するのではなく，計画的に進められる段階的なプロセスであることが示唆される．開発者は，類似するメソッドのロジックを少しずつ共通化し，十分にメソッド間の類似度が高まった段階で最終的な統合を実施するという行動パターンが読み取れる．

この対比は，コードメトリクスによって捕捉可能な開発者行動の範囲を示唆している．統合はコードレベルの変化として開発者の意図が反映されるため，メトリクスによる検知が可能である．しかし，削除はコード外の要因（プロジェクト方針やロードマップ）によって駆動されるため，コードメトリクス単独では検知が困難である．この差異こそが，メソッドが持つコードとの類似度が統合の予測には有効であるが削除の予測には不十分であるという本研究の知見の本質的な理由であると考えられる．

\section{統合における2つのパターン}

統合元メソッドの起源に基づくと，メソッドの統合には質的に異なる2つのパターンが存在すると考えられる．

第一のパターンは，\textbf{一時的複製型}の統合である．新規追加メソッドの多くは，メソッド間の類似度が100\%で，\texttt{f}や\texttt{wrapper}などの内部関数名を持ち，テストファイルに多く含まれていた．これらは開発過程で一時的に作成された内部関数やテスト補助関数であり，次バージョンでのリネームやファイル移動によって統合として検出されたものと考えられる．このパターンは開発プロセスの副産物であり，意図的なリファクタリングとは性質が異なる．

第二のパターンは，\textbf{段階的収束型}の統合である．2バージョン以上にわたり追跡されたメソッドは，メソッド間の類似度の段階的上昇を表しており，開発者が計画的にメソッドのコードを近づけ，最終的に統合を実施するパターンに対応する．

統合元群の$t = 0$における類似度の急上昇には，個々のメソッドの類似度が段階的に上昇した効果に加え，類似度が100\%に近い新規メソッドが$t = 0$で大量に流入した構成変化の影響が含まれている．したがって，段階的収束型のメソッドのみを対象とした分析により，統合の予測指標としての精度をさらに向上できる可能性がある．

\begin{table}[ht]
  \centering
  \caption{一時複製型のメソッド（頻度数順）}
  \label{tab:method_frequency}
  \begin{tabular}{lr}
    \hline
    メソッド名 & 頻度 \\
    \hline
    \texttt{f}                           & 236 \\
    \texttt{wrapper}                     & 208 \\
    \texttt{inner}                       & 41  \\
    \texttt{\_check}                     & 38  \\
    \texttt{TestHDFStore.check}          & 36  \\
    \texttt{wrapper\_1}                  & 28  \\
    \texttt{TestTake.\_test\_dtype\_1}   & 28  \\
    \texttt{wrapper\_2}                  & 27  \\
    \texttt{TestIntIndex.\_check\_case}  & 25  \\
    \texttt{CheckIndexing.test\_comp}    & 25  \\
    \texttt{TestTake.\_test\_dtype\_2}   & 25  \\
    \texttt{TestExpressions.testit\_1}   & 23  \\
    \texttt{TestExpressions.testit\_2}   & 23  \\
    \texttt{TestTSPlot.\_test}           & 22  \\
    \texttt{\_convert\_listlike}         & 22  \\
    \hline
  \end{tabular}
\end{table}


\section{段階的収束型メソッドの特徴}

段階的収束型の統合元メソッド4,831件の定量的特徴を，一時的複製型6,711件と対比して考察する．

段階的収束型メソッドは，平均6.3バージョン（中央値5）にわたって追跡されたのちに統合されたメソッドである．統合時点でのメソッド間の類似度の中央値は88\%であり，一時的複製型の100\%と比較して低い．また，類似度が100\%であったメソッドの割合は段階的収束型では32.7\%であるのに対し，一時的複製型では60.7\%であった．この差は，段階的収束型のメソッドが完全なコピーではなく，コードが徐々に近づいた結果として統合に至ったことを示唆している．

さらに，メソッドの生存期間（lifetime）と統合時点の類似度の関係を調査した．lifetime=2のメソッド（992件）の類似度中央値は96\%であったのに対し，lifetime=10のメソッド（117件）では83\%であった．lifetimeが長いメソッドほど，低い類似度の段階から段階的に収束していることがわかる．この傾向は，統合予測の観点から重要な示唆を持つ．すなわち，複数バージョンにわたり70\%から90\%の類似度を維持するメソッドペアは，将来の統合候補として早期に検出できる可能性がある．一方，一時的複製型のメソッドは1バージョンで消滅するため，予測対象としての意義は限定的である．したがって，統合の予測指標を構築する際には，段階的収束型に特化した分析が有効であると考えられる．

% \section{誤って統合元メソッドと判定されるケース}

% 本研究の手法では，バージョン間でメソッドを類似度により追跡し，最も類似度の高い候補メソッドが既に他のメソッドと対応付けられている場合に「統合」と判定する．しかし，統合元と判定された11,745件のうち，最終時点でクローンを持たないメソッドが757件（6.4\%）存在した．これらは統合ではなく，リファクタリングによるコード抽出の結果として誤判定された可能性がある．

% 具体的な誤判定の例として，\texttt{DataFrame.\_\_init\_\_}メソッドが挙げられる．このメソッドは25バージョンにわたりシグネチャマッチで追跡されたpandasの中核メソッドである．v1.2.0からv1.3.0への遷移時に，\texttt{construction.py}内の\texttt{sanitize\_masked\_array}に類似度0.84でマッチされ，統合元と判定された．しかし実際には，\texttt{DataFrame.\_\_init\_\_}はv1.3.0以降も存在し続けている．初期化ロジックの一部が\texttt{sanitize\_masked\_array}として抽出されたことで，類似度マッチにより誤って別メソッドに対応付けられたものと考えられる．

% クローンを持たない統合元757件のうち，648件は2バージョン以上追跡されたメソッドであり，そのlifetimeの中央値は7であった．また，これらの65.6\%がテストファイルに含まれていた．テストファイルではリファクタリングに伴うテストメソッドの再構成が頻繁に行われるため，誤判定が生じやすいと考えられる．ただし，誤判定率は全体の6.4\%であり，RQ1およびRQ2の統計的結論に大きな影響を与えない可能性が高い．

\section{統合先メソッドが統合前にメソッド間の類似度が上昇しない理由}

図~\ref{fig:boxplot-absorber}に示すように，統合先メソッドのメソッド間の類似度は統合前には上昇せず，統合後に低下する傾向が観察された．統合先メソッドが統合前に類似度が上昇する傾向がみられない理由を以下で考察する．

メソッドは生存期間に複数回統合される可能性がある．したがって，図~\ref{fig:boxplot-absorber}では，メソッドが最後に統合先となった時点を$t = 0$としているため，過去の統合時点ではメソッド間の類似度が上昇していた可能性がある．
しかし，メソッドによっては$t = 0$より前の時点での統合のタイミングが様々であるため，過去の統合時点での類似度上昇が平均化されてしまい，図~\ref{fig:boxplot-absorber}では観察されなかったと考えられる．

また，統合先メソッドの類似度低下については，統合元メソッドのコードが統合先に取り込まれた結果，統合先メソッドの構造が変化し，他の類似メソッドとの類似度が低下したためと考えられる．


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{妥当性の脅威}
\label{chap:threat-to-validity}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

本章では，本研究における結果の信頼性に影響を及ぼす可能性のある要因を，内的妥当性および外的妥当性の観点から述べる．

\section{内的妥当性}

本研究で使用したコードクローンの検出ツールは閾値でコードクローンを判定しているため，閾値によっては，メソッドの分類件数が異なる可能性がある．類似度を判定するための閾値に関しては，従来研究で検証されている0.7を使用することを信頼性を担保した．

全てのコミット間隔ではなく，マイナーバージョンの間隔に絞って分析しているため，バージョン間で生成・削除された短命メソッドについては，見逃してしまう．しかし，これら短命のメソッドは開発者が一時的に導入するメソッドであるため，ソフトウェアにとって負債となり得ない．

\section{外的妥当性}
本研究はPythonのpandasプロジェクトのみを対象としている．データサイエンス分野に特化したライブラリ特有の進化パターンが存在する可能性があり，他のドメイン（例：Webフレームワーク，組み込みシステム）や他のプログラミング言語（例：Java, C++）で開発されたプロジェクトにおいても同様の削除パターンやクローン整理の傾向が見られるかは不明である．今後はより多様なOSSプロジェクトを対象とした大規模な調査が求められる．

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{おわりに}
\label{chap:conclusion}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

本研究では，メソッド間の類似度が削除の判断指標として機能するかを検証した．Pythonライブラリpandasの40,264件のメソッドを対象に，2つのリサーチクエスチョンに基づき分析を行った．

RQ1の分析では，他と類似するコードを持たないメソッドの削除率（3.3\%）が他と類似するコードを持つメソッド（2.5\%）より有意に高く，他と類似するコードを持つメソッドの中では高類似なコードを含むほど削除されやすいことを示した．RQ2の分析では，メソッドの統合前にはメソッド間の類似度が急激に上昇する一方，削除前にはメソッド間の類似度が変化しないことを明らかにした．

以上の結果から，メソッド間の類似度の動的な変化はメソッド統合の予測指標として有効であるが，メソッド削除の予測には単独では不十分であり，削除はプロジェクトレベルの意思決定に依存していることが示唆された．

今後の課題として，メソッド間の類似度に加え，依存関係や変更頻度などの他のメトリクスとの組合せによる削除指標の精緻化，および対象プロジェクトの多様化による知見の一般性の検証が挙げられる．近年，AIによるコード生成の普及に伴い，不要コードがソフトウェアに混入する機会が増加しており，メソッド削除の判断を支援する定量的な指標の重要性は今後さらに高まると考えられる．

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


% 謝辞

\begin{acknowledgements}
本研究を進めるにあたり，多くの方にご指導，ご協力，ご支援を賜りました．ここにお世話になった方々への感謝の意を記させていただきます．

はじめに，指導教員である和歌山大学システム工学部の伊原彰紀准教授に深く御礼申し上げます．研究室配属以来，研究方針についての相談や論文執筆，発表資料の作成など，多くの時間を割いてご指導いただきました．特に，対外発表の機会を設けていただいたことで，研究の面白さや難しさ，やりがいを知ることができ，研究に対する知見を深めることができました．先生のご尽力に敬意を表し，心より感謝いたします．

次に，和歌山大学システム工学部を修了された飯田智輝氏，そしてソーシャルソフトウェア工学研究室の先輩方には，研究において多くのご指導とご助言をいただきました．お忙しい中，研究内容の相談や論文執筆についての支援など，大変お世話になりました．心より感謝いたします．

また，和歌山大学ソーシャルソフトウェア工学研究室の皆様には，研究に関する客観的なご意見やご指導を常日頃から多くいただきました．特に同期の皆様には，研究活動のみならず，大学生活全般においても大変お世話になりました．心より感謝申し上げます．

最後に，日頃から温かく見守ってくれか家族に心より感謝いたします．
\end{acknowledgements}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%
%% 参考文献
%%
\bibliographystyle{junsrt}
\bibliography{@Bachelor2025_Yoshida/yoshida_refs}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%
%% 付録
%%
% \appendix
%
% \chapter{サンプルプログラム}
%
% プログラムリストや実行結果など，本論を補足する上で必要と思われるものが
% あれば付録として付ける．
%
% {
% \footnotesize
% \begin{verbatim}
% #include <stdio.h>
% int main(void)
% {
%     printf("Hello, World!\n");
%     return 0;
% }
% \end{verbatim}
% }

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\end{document}

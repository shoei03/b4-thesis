\documentclass[11pt]{jreport}
\usepackage{wuse_thesis}
\usepackage{indentfirst}
\usepackage{url}  % \url{}コマンド用．URLを表示する際に便利
\usepackage{amsmath}
\usepackage{booktabs}
\usepackage[dvipdfmx]{graphicx,xcolor}
\usepackage{listings}
\lstset{
  basicstyle={\ttfamily},
  identifierstyle={\small},
  commentstyle={\smallitshape},
  keywordstyle={\small\bfseries},
  ndkeywordstyle={\small},
  stringstyle={\small\ttfamily},
  frame={tb},
  breaklines=true,
  columns=[l]{fullflexible},
  numbers=left,
  xrightmargin=0zw,
  xleftmargin=3zw,
  numberstyle={\scriptsize},
  stepnumber=1,
  numbersep=1zw,
  lineskip=-0.5ex
}
\usepackage{siunitx}
\sisetup{group-separator={,}} % 3桁ごとにコンマを入れる設定
%\usepackage{graphicx}  % ←graphicx.styを用いてEPSを取り込む場合有効にする
% 他のパッケージ・スタイルを使う場合には適宜追加
\newcommand{\todo}[1]{\colorbox{yellow}{{\bf TODO}:}{\color{red} {\textbf{[#1]}}}}
\newcommand{\memo}[1]{\colorbox{magenta}{\textbf{MEMO}}{\color{red}\textbf{[#1]}}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%
%% 主に表紙を作成するための情報
%%

%%  タイトル(修論の場合は英語表記も指定)
\title{類似コードを有するメソッドの\\
削除に関する実証分析}
%\etitle{Test\\Test\\Test}

%%  著者名(修論の場合は英語表記も指定)
\author{吉田 将衛}
%\eauthor{Akinori Ihara}

%% 卒業論文・修士論文(以下のどちらかを選択)
\bachelar  % 卒業論文(4年生用)
%\master    % 修士論文(M2用)

%%  学科・クラスタ
\department{システム工}
%\department{デザイン情報}
%\department{デザイン科学}

%%  学生番号
\studentid{60276296}

%%  卒業年度
\gyear{2025}    % 提出年が2022年なら，2021年度

%%  論文提出日
\date{2026年2月10日}  % 修士の場合は月(2021年2月)までとし，英語表記も指定
%\edate{February 2021}  % 修士の場合，こちら(英語表記)も有効化

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

\maketitle

%%
%%  概要
%%
\begin{abstract}
  \todo{デブロートという単語をどこかに入れる}
  ライブラリは，機能追加や削除を繰り返しながら進化を続けている．その進化の過程で規模が拡大し，不要なコードが蓄積する．この問題に対処するため，開発者はソフトウェア再構成の一環としてメソッドの削除を行うことがある．
  しかし，削除するメソッドを客観的に判断することは容易ではなく，最終的に開発者の経験に依存せざるを得ない．本研究では，メソッド間のクローン類似度に着目し，類似度がメソッド削除の判断指標として機能するかを検証する．具体的には，クローンの有無および類似度の高低と削除率の関係，ならびにメソッドが削除・統合に至る過程でのクローン類似度の推移を分析する．
  ケーススタディとして，広く利用されるPythonライブラリ1件における削除されたメソッド7,636件を対象に分析した結果，クローンを持たないメソッドの削除率がクローンを持つメソッドより高いこと，メソッド統合前にはクローン類似度が段階的に上昇する一方，削除前にはそのような変化が見られないことを明らかにした．以上より，クローン類似度はメソッド統合の予測に有効であるが，削除の予測には他の指標との組合せが必要であることが示唆される．

\end{abstract}

%%  目次
\tableofcontents

%%  図目次 (図目次をいれたければ以下のコメントをはずす)
%\listoffigures

%%  表目次 (表目次をいれたければ以下のコメントをはずす)
%\listoftables

\newpage
\pagenumbering{arabic}  % 以降のページ番号を算用数字に

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%
%%  本文はここから
%%

% \chapter{はじめに}

% 現代のソフトウェア開発はソフトウェア部品の組み合わせで行われる\cite{liblary-reuse}．ソフトウェア部品は再利用可能な形でまとめられ，ライブラリと呼ばれる．ライブラリの利用によって，ソフトウェア開発者はソフトウェアの開発工程を大幅に削減することができる\cite{reduce-productivity}．ライブラリ開発者は，さらに上流のライブラリを使用することもあり，ソフトウェアエコシステム\cite{software-wcosystem}を形成する．

% 一方で，ライブラリを利用してソフトウェア開発を行うことのデメリットも存在する．ライブラリ自体も機能追加やバグ修正を行いながら成長するため，破壊的変更を引き起こす可能性がある．「ライブラリが外部へ公開しているAPIの名称変更」や「引数の変更」など，様々な要因によって，破壊的変更が引き起こされる\cite{detect-backward-compatibility}．中でも，ライブラリAPIの削除はクライアントに甚大な影響を及ぼす．ライブラリAPIが削除されると，クライアントは，代替APIへ切り替える必要がある．しかし，代替APIが存在しない場合は自前で実装するか，機能自体を廃止するかの選択を迫られる．

% APIの削除という大きな変更に関しては，急に行うと，ソフトウェアエコシステム全体に負荷がかかる．したがって，多くのライブラリでは，セマンティックバージョニング\footnote{\url{https://semver.org}}という戦略を採用している．セマンティックバージョニングにしたがっているライブラリは一般的にメジャーバージョンのリリース時のみで破壊的変更を加える．この仕組みによって，クライアントはメジャーバージョンのアップデート時には，破壊的変更の対策を取ることができる．また，APIの削除は急に行われるわけではなく，削除よりも一定期間前から非推奨という警告を出し，クライアントが十分に対策を行える猶予を作った上で，削除を行うという仕組みが備わっている．

% 一般に，ソフトウェアには，不要と考えられるソースコードが蓄積されている．一方，開発者が全ての不要コードを全て見つけ出すことは難しい．なぜなら不要コードには，様々な種類があるからである．

% 一つ目は，ソースコード中から不要コードを見つけ出す手法である．例えば，プログラム中で到達することができないプログラムはデッドコードと呼ばれ，不要コードと考えられる．デッドコードに関しては，静的解析と動的解析を組み合わせることでおおよそ検出ができる．静的解析では，動的な依存関係を取得することが難しいため，見逃しが発生してしまう．また，動的解析では，エッジケースの入力や年に1回だけ実行されるようなケースを誤って陽性と判断してしまう．このように，デッドコードの検出は，まだまだ課題が残っている．

% 二つ目は，ソースコードの変更履歴における削除に着目する方法である．変更履歴において，削除されたコードは不要であると考える．変更履歴から削除されたコードを収集し，共通する特徴を抽出するという方法である．しかし，この分析方法では，ノイズが多く混ざってしまう．例えば，リファクタリングの一環として開発者がソースコードを移動した場合，履歴上では，削除と追加という変更として記録されてしまう．したがって，本質的な削除のみを抽出する手法が必要である．
% そこで，RefactoringMiner\cite{Alikhanifard:TOSEM:2024:RefactoringMiner3.0}のようなリファクタリング検出手法によりノイズを減らす工夫がされている．しかし，RefactoringMinerは全ての変更コミットを探索するため，大規模なOSSで適用するには非常に計算コストがかかってしまう．また，リファクタリングが複数コミットに渡る場合，RefactoringMinerでも検出ができなくなる．

% そこで，本研究では，バージョンごとにソフトウェア中に存在するメソッドを全て抽出し，バージョン間で同じシグネチャのメソッドが存在せず，かつ，類似するメソッドが存在しなかった場合に削除されたメソッドであると判定する．バージョンごとのコミットだけに着目することで計算コストを削減し，類似メソッドで削除を判定することで，複数コミットにわたるリファクタリングも検出できるようになる．さらに，一時的に追加されたコードクローンが削除されるケースも発生するため，コードクローンに関連するケースについても検出する．

% 以降，本論文では，\ref{chap:deletecode}章で不要コードの種類と不要コードが与える影響，関連研究と本研究の位置付けを述べる．\ref{chap:pre-analysis}章では，本研究の動機となる事前分析を述べ，\ref{chap:RQ1}章，\ref{chap:RQ2}章では，設定したRQにおけるそれぞれの分析手法，結果，考察を述べる．続く\ref{chap:thread-to-validity}章では，本研究の妥当性の脅威を述べる．最後に\ref{chap:conclusion}章で本論文をまとめる．

% \chapter{不要コードの削除}
% \label{chap:deletecode}

% \chapter{不要コードの種類}
% ソフトウェアにとっての不要コードはステークホルダやタイミングによって異なる．クライアントにとって必要な機能であってもライブラリ開発者にとっては，保持したくないソースコードもある．例えば，後方互換性を維持するためのソースコードはライブラリにとっては保持したくない不要コードであるが，古いバージョンを使用するクライアントにとっては必要である．他にも，頻繁に使用されるライブラリのAPIは必要であるが，より効率的でクリーンな実装の代替APIが登場すれば，現状のAPIは価値が落ち，不要とみなされることがある．その中でも普遍的に不要であると判断されるソースコードは存在し，活発に研究で議論されてきた．表~\ref{tab:unnecessary-code}に不要コードの分類を示す．
% デッドコードや未実行コードに関しては，定義しやすいため，比較的観測しやすい．一方，不要コードは定義自体に曖昧さを伴うため，観測することは比較的難しい．
% 以後，単に不要コードと記述する場合，これらのコードを統括的に含んだ意味を示すものとする．

% \begin{table}[ht]
%     \centering
%     \caption{不要コードの分類}
%     \begin{tabular}{l|l|l} \hline
%         種類 & 定義 & 関連研究 \\ \hline
%         デッドコード & プログラム中で到達不可能なソースコード & \cite{static-analysis}\cite{dynamic-analysis}\cite{decrease-readability} \\
%         未実行コード & 観測期間において，実行されないソースコード & \cite{static-analysis}\cite{increase-maintainability} \\
%         不要コード & システムの目的を果たすために必要ではないソースコード & \cite{static-analysis}\cite{increase-maintainability} \\
%         削除コード & 削除されたソースコード \\ \hline
%     \end{tabular}
%     \label{tab:unnecessary-code}
% \end{table}

% \chapter{不要コードが引き起こす問題}
% 不要コードがコードベースに蓄積することは様々な問題を引き起こす．Sebastianら\cite{increase-maintainability}の研究では，不要コードは保守コストの増加を引き起こすと言われている．ソースコードの修正時に，未使用のソースコードも同時に修正する必要があるため，無駄なコストを作り出してしまう．また，Simoneら\cite{decrease-readability}の研究では，コードベースを理解する際に，不要コードを読んでしまうことで，ソースコード理解の有効性や効率を下げてしまうと言われている．
% したがって，不要コードは検出し，削除することで，コードベースから取り除く必要がある．

% \chapter{関連研究}

% \subchapter{不要コードの検出}

% 観測期間において，実行されていないソースコードを検出し，自動で削除する研究が提案されている\cite{dynamic-analysis}．ソフトウェア中のさまざまなコンポーネントにログを組み込み，実環境で一定期間運用することで実行状況のログを取得する．実行状況のログの中で実行履歴がないコンポーネントを不要コードと判定する．
% しかし，ソフトウェアの使用状況に基づく不要コードの検出では，偽陽性が発生する．例えば，エラー処理のソースコードや復旧用のソースコード，移行のためのソースコードは観測期間において，実行されなければ，不要コードであると検出される．このようなソースコードは実行されていなくとも，他のコンポーネントとの依存関係があるので，削除してはいけない．したがって，実行状況の監視と共に依存関係の取得も必要である．

% そこで，依存関係に着目し，他との依存関係を持たないデッドコードを静的に検出する手法が提案されている\cite{detect-dead-code}．\todo{デッドコードの検出手法の説明}しかし，リフレクションのように動的に依存関係が決まる場合，偽陽性を発生させてしまう．

% これらは普遍的な不要コードを検出することを目的としている．本研究では，普遍的な不要コードよりも広い概念での不要コードの特徴を調査することを目的としている．

% \subchapter{削除コードの実証的研究}
% 削除ファイルの特徴を分析した研究では，「最近変更されておらず，依存の中心にいない特徴を持つファイル」が「生存するファイル」に比べ，有意に差があるということを発見した\cite{static-analysis}．

% テストコードの削除に着目した研究\cite{study-of-test-deletion}では，削除されたテストメソッドの83.2\%はテストクラスごと削除され，7\%は冗長なテストであった．さらに，削除されたテストメソッドの91.4\%はプロダクションコードの廃止による副次的な削除であることがわかった．

% Ashokら\cite{why-deprecated}は，メソッドが非推奨になる理由をコミット履歴やイシュートラッカーなどを基に調査，分類した．その結果，「新機能の導入」，「機能上の欠陥」，「デザインパターン」の3種類で全体の約72\%を占めていた．

% \subchapter{自動削除の研究}
% \todo{Meta\cite{dynamic-analysis}やUberの自動削除の研究}\memo{書くか迷っている}

% \chapter{本研究の位置付け}
% 既存研究は主に，デッドコードや未実行コードといった「狭義の不要コード」の自動検出に特化してきた．しかし，静的解析によるデッドコードの検出では，動的依存関係の把握が困難であり，さらに，動的解析では，動作期間に依存するという偽陽性の問題を抱えている．これに対し，本研究では，以下の独自性を有する．

% \vspace{5pt}
% \noindent\emph{開発者の判断に基づく削除履歴への着目}
% \vspace{5pt}

% 既存の不要コード検出手法での課題を回避するため，本研究では，「開発者が実際に削除した」という確定した事実をGround Truthとし，分析対象とする．これにより，狭義の不要コードだけでなく，広義の不要コードの削除実態を網羅的に調査することができる．

% \vspace{5pt}
% \noindent\emph{コードクローンを用いたメソッドの比較}
% \vspace{5pt}

% 単なる削除メソッドの分析ではなく，コードクローンを持つメソッドを分析上，切り分ける．これによって，コードクローンという冗長な実装がある中で，削除されたメソッドと生存したメソッドを抽出することができる．これによって，メソッドを相対的に比較し，どちらのメソッドの品質が高いかを議論することを可能にする．

% \chapter{事前分析：削除されたコードの特徴}
% \label{chap:pre-analysis}

% \chapter{概要}
% 本章では，削除されたメソッドの実態を目視で調査し，削除の動機を明らかにすることである．特に，削除されたメソッドが狭義の不要コードだけであるのか，それとも，広義の不要コードが原因で削除を行うのかを分析する．

% \chapter{分析手法}
% 対象プロジェクトの変更履歴から削除されたメソッドを無作為に抽出し，以下の観点で目視調査を行う．

% \vspace{5pt}
% \noindent\emph{依存関係の有無}

% 削除される直前のバージョンにおいて，当該メソッドが他のプログラムから呼び出されていたかどうかを調査する．

% \vspace{5pt}
% \noindent\emph{削除理由の分析}

% 削除時のコミットメッセージや関連するIssueを確認し，削除理由を分類する．

% \chapter{データセット}
% GitHub\footnote{\url{https://github.com}}上でソースコードが公開されているpandas\footnote{\url{https://github.com/pandas-dev/pandas}}プロジェクトを使用した．プロジェクトの選定方法は以下である．
% Pythonのプロジェクトであること．大規模なライブラリであり，ユーザが多数存在すること．開発年数が長期であること．メジャーリリースが2つ以上存在すること．

% \chapter{分析結果}
% v0.25.0における\texttt{pandas/io/common.py}内のメソッド\texttt{\textunderscore stringify\textunderscore path}はioに関するプライベートメソッドである．これは削除直前までは，他のファイルから呼び出されていた．しかし，0df8858752のコミットにおいて，削除されている\footnote{\url{https://github.com/pandas-dev/pandas/commit/0df8858752}}．このコミットに関しては，Pull Requestは見つけられたが，Issueは見つかっていないため，削除理由に関しては不明である．しかし，Pull Requestのタイトルで，io関連のメソッドを非公開化する趣旨の内容が記載されていた．

% \chapter{事前分析から得られた示唆と研究課題}
% 事前分析から次の知見が得られた．まず，削除の動機は狭義の不要コードだけに留まらないということ．デッドコードであるから削除するといった理由だけでなく，デッドコードでなくともメソッドが削除される例が存在することがわかった．

% 以上の示唆に基づき，本研究では，以下のリサーチクエスチョン（Research Questions）を設定する．
% \begin{itemize}
%     \item RQ1: クローンセットの有無はメソッドの生存と削除にどのような影響を与えるか
%     \item RQ2: メソッドの統合や分割に着目することでコードベースから完全に削除されたメソッドを特定できるか
% \end{itemize}

% \chapter{RQ1：クローンセットの生存と削除にはどのような特徴があるか}
% \label{chap:RQ1}
% % \chapter{RQ1: どのようなメソッドが削除されるか}

% \chapter{概要}

% 本章では，OSSプロジェクトの進化過程におけるメソッドの削除要因を明らかにするため，ソースコードの変遷を追跡し，クローンセットとの関係性に基づいた分類を行う．手順1から3は，対象プロジェクトの特定バージョンからメソッドを抽出し，抽象構文木を用いてシグネチャとボディを取得する．手順4で，隣接するバージョン間で同一メソッドを紐づける．手順5でメソッドの削除時のクローンセットの存続状況を確認することで，削除の要因をパターン化する．

% \begin{figure}[t]
%     \centering
%     \includegraphics[width=0.75\linewidth]{@Bachelor2025_Yoshida/Yoshiba_fig/approach.pdf}
%     \caption{メソッドの分類}
%     \label{fig:overview-of-approach}
% \end{figure}

% \chapter{分析手法}

% \noindent\emph{1. 解析対象バージョンの選定}

% 対象とするOSSのGitHub\footnote{\url{https://github.com/}}リポジトリから，タグを含むコミットを全て取得する．タグを含むコミットからセマンティックバージョニングを使用しているコミットのみをフィルタリングする．
% さらに，セマンティックバージョニングの末尾に「rc」や「dev」といったプレリリースが含まれるタグについては，正規表現で排除する．
% また，本研究では，メジャーおよびマイナーバージョンの変遷に着目するため，パッチバージョンが「0」であるタグ（例：「v1.2.0」）のみを対象とする．
% これらの操作によって，マイナーバージョン，メジャーバージョンのタグとそのコミットのみを時系列順にK個抽出する．

% \noindent\emph{2. メソッドのシグネチャとボディの取得}

% 取得したバージョンへ順次チェックアウトを行い，当該バージョンに含まれる全てのPythonファイル（.py）を対象に抽象構文木（Abstract Syntax Tree）へパースする（以降，ASTとする）．このASTからメソッドのシグネチャを取得し，一意のメソッド名を構築する（「ファイルパス，クラス名.メソッド名，引数，戻り値」という形式）．
% 同時にメソッドのボディもASTから取得しておき，トークンで分割し，リストとして保存する．

% \noindent\emph{3. メソッドのN-gram化}

% バージョン $k$ ($1 \le k < K$) における $M$ 個のメソッドの集合を $V_{k} = \{c_1, c_2, \dots, c_M\}$ とする．
% 各メソッド $c_m \in V_k$ に対して N-gram 化を行い，抽出された N-gram の集合を $G(c_m)$ と表す．
% 本研究では，従来研究と同様に 5-gram を採用する．

% \noindent\emph{A. バージョン間でのシグネチャの一致}

% 隣接するバージョン$V_{k}$と$V_{k+1}$の間でシグネチャが完全に一致するメソッドを同一と見なし，共通のIDを割り当てる．

% \noindent\emph{B. バージョン間での類似度の計算}

% コードクローン検出器 NIL を使用して，バージョン間でのクローンメソッドを検出する．
% $V_{k}$ における各メソッド $c_i$ に対し，$V_{k+1}$ における全てのメソッド $c_j$ との類似度を計測する．
% この際，類似度が閾値を超えたメソッドを候補メソッドとする．従来研究と同様に類似度の閾値は 0.7 を使用する．
% $V_{k}$ における特定のメソッドに対し，$V_{k+1}$ における複数のメソッドが閾値を超えた場合は，最大の類似度をもつメソッドを候補メソッドとし，同一IDを割り当てる．

% NIL による詳細な類似度計算（検証フェーズ）では，以下の式を用いる．
% \begin{equation}
%     \text{Sim}_{\text{verif}}(c_i, c_j) = \frac{\text{LCS}(c_i, c_j)}{\min(|c_i|, |c_j|)}
% \end{equation}
% ここで，
% \begin{description}
%     \item[$c_i, c_j$:] 比較対象となる2つのメソッドのトークン列
%     \item[$|c_i|, |c_j|$:] 各トークン列の長さ
%     \item[$\text{LCS}(c_i, c_j)$:] 2つのトークン列間で、順序を保ったまま一致している最長共通部分列（Longest Common Subsequence）の長さ
% \end{description}

% 本手法の特徴は，分母に最小値（$\min$）を用いている点にある．
% これにより，一方がもう一方を包含している場合に類似度が高く算出される．
% 例えば，片方のメソッドに大量の新しいコードが追加されて全体の長さが大きく変化した場合でも，元のロジックが保存されていればクローンとして検出可能である．

% しかし，LCS による類似度計算は計算コストが非常に高いため，以下の式を用いたフィルタリングフェーズを導入し，明らかに異なるメソッド対を事前に除外する．
% \begin{equation}
%     \text{Sim}_{\text{filt}}(c_i, c_j) = \frac{|G(c_i) \cap G(c_j)|}{\min(|G(c_i)|, |G(c_j)|)}
% \end{equation}
% ここで，$G(c)$ はメソッド $c$ の N-gram 集合を表し，$|G(c_i) \cap G(c_j)|$ は $c_i$ と $c_j$ で共通する N-gram の要素数を表す．
% このフィルタリングにより，類似度が 0.1 未満のメソッド対に対する LCS 計算を省略し，全体の実行時間を削減している．

% \noindent\emph{4. 同一メソッドの追跡}

% まず，Aを用いて，同一メソッドを判定する．このとき，メソッドの中身やロジックは同一でも，リネームや，ファイルの移動を受けたメソッドは同一メソッドと判定できない．
% したがって，Aによる同一メソッドの判定後に残ったメソッドについて，Bを用いることで同一メソッドを判定する．これによって，リネームやファイル移動したメソッドでも追跡することができる．
% このIDの変遷を比較することで，メソッドを以下の3つに分類する．$V_{k+1}$で初めて出現したIDを持つメソッドを「追加メソッド」，$V_{k}$と$V_{k+1}$の両方に存在するIDを「生存メソッド」，$V_{k}$のみに存在するIDを「削除メソッド」とする．

% \noindent\emph{5. メソッドの変遷パターンの分類}

% 本研究では，削除メソッドが「機能の完全な削除」によるものか，あるいは，「冗長なコードの整理」によるものかを区別するため，削除メソッドをさらに詳細に分類する．

% まず，バージョン$V_{k}$内において，3-Bと同様の手法を用いてメソッド間のコードクローン検出を行う．コードクローンは通常，2つのメソッドのペアとして検出されるため，これらのペアに対して推移律（メソッドaとb，bとcがクローンであれば，aとcも同一グループとする）を適用し，クローン集合（以降，クローンセットとする）を構築する．
% 次に，各クローンセットに属するメソッドの$V_{k+1}$における生存状況を確認し，以下の3つに分類する．

% \begin{description}
%     \item[全削除: ] あるクローンセットに含まれる全てのメソッドが，$V_{k+1}$において，「削除メソッド」と判定された場合．これは，クローンセットが提供していた機能自体がプロジェクトから消滅したことを意味する．
% \end{description}

% \begin{description}
%     \item[部分削除: ] あるクローンセットに含まれるメソッドのうち，一部が$V_{k+1}$ で「削除メソッド」となり，少なくとも1つ以上のメソッドが「生存メソッド」として残っている場合．この場合，削除されたメソッドは「部分削除」，生存したメソッドは「部分生存」と定義する．これは，重複していたコードが統合されたり，特定の箇所のみが不要になったりする「リファクタリング」に近い挙動を示していると考えられる．
% \end{description}

% \begin{description}
%     \item[独立削除: ] バージョン$V_{k}$において，他のどのメソッドともクローン関係にない（すなわち，どのクローンセットにも属さない）メソッドが $V_{k+1}$ で削除された場合．これは，そのメソッドが担っていた固有の機能がプロジェクトから取り除かれたことを示す．
% \end{description}

% \chapter{分析結果}
% \subchapter{メソッドの生存実態}

% 表~\ref{tab:pattern-method}は，各バージョンにいて，追加されたメソッドの数，削除されたメソッドの数（クローンセット内のすべてのメソッドが削除，クローンセット内の一部のメソッドが削除，独立してメソッドが削除），生存したメソッドの数をそれぞれ表している．

% \begin{table}[ht]
%     \centering
%     \caption{メソッドの変遷パターン}
%     \begin{tabular}{l|rrrrrrr} \hline
%     & & \multicolumn{3}{c}{削除} & \\ \cline{3-5}
%     バージョン & 追加 & 全削除 & 部分削除 & 独立削除 & 生存 \\ \hline \hline
%     v0.4.0 & 1303 & 0 & 0 & 0 & 0 \\
%     v0.5.0 & 281 & 7 & 0 & 18 & 1272 \\
%     v0.6.0 & 169 & 4 & 0 & 12 & 1529 \\
%     v0.7.0 & 606 & 71 & 0 & 167 & 1457 \\
%     v0.8.0 & 908 & 100 & 0 & 145 & 1809 \\
%     v0.9.0 & 288 & 20 & 0 & 9 & 2670 \\
%     v0.10.0 & 428 & 51 & 0 & 138 & 2750 \\
%     v0.11.0 & 376 & 59 & 6 & 144 & 2949 \\
%     v0.12.0 & 414 & 12 & 0 & 17 & 3269 \\
%     v0.13.0 & 2380 & 63 & 0 & 57 & 3542 \\
%     v0.14.0 & 806 & 51 & 5 & 113 & 5706 \\
%     v0.15.0 & 909 & 71 & 1 & 67 & 6325 \\
%     v0.16.0 & 455 & 36 & 5 & 32 & 7113 \\
%     v0.17.0 & 1217 & 49 & 4 & 57 & 7410 \\
%     v0.18.0 & 743 & 68 & 4 & 79 & 8434 \\
%     v0.19.0 & 1476 & 168 & 3 & 206 & 8766 \\
%     v0.20.0 & 1276 & 503 & 11 & 542 & 9150 \\
%     v0.21.0 & 670 & 56 & 4 & 67 & 10255 \\
%     v0.22.0 & 129 & 1 & 1 & 1 & 10876 \\
%     v0.23.0 & 1725 & 478 & 14 & 430 & 10044 \\
%     v0.24.0 & 2593 & 504 & 12 & 601 & 10612 \\
%     v0.25.0 & 1111 & 326 & 6 & 473 & 12372 \\ \hline
%     v1.0.0 & 1284 & 496 & 10 & 522 & 12430 \\
%     v1.1.0 & 1407 & 196 & 12 & 280 & 13198 \\
%     v1.2.0 & 1544 & 279 & 7 & 217 & 14064 \\
%     v1.3.0 & 2067 & 294 & 12 & 285 & 14984 \\
%     v1.4.0 & 1477 & 260 & 15 & 170 & 16568 \\
%     v1.5.0 & 1423 & 104 & 7 & 87 & 17788 \\ \hline
%     v2.0.0 & 1376 & 345 & 17 & 416 & 18270 \\
%     v2.1.0 & 1398 & 197 & 11 & 147 & 19153 \\
%     v2.2.0 & 1105 & 128 & 6 & 166 & 20123 \\
%     v2.3.0 & 319 & 16 & 3 & 15 & 21045 \\ \hline
%     合計 & 34968 & 5313 & 184 & 5304 & 275734 \\ \hline
%     \end{tabular}
%     \label{tab:pattern-method}
% \end{table}

% 観測開始地点のバージョン0.4.0は，プロジェクトの初期なので，多くのメソッドが追加されている．メソッドは基本的には，追加が続けられており，全体の総数としては上昇する．例えば，v1.0.0のリリース時は，グループの全削除が496件，独立削除が522件起こっている．さらに，v2.0.0のメジャーバージョンのリリース時にも全削除が345件，独立削除が416件起こっている．これは，メジャーバージョンの1においては，最大の削除数となっている．
% このことから，メジャーバージョンのリリース時には，多くのメソッドが削除されることがわかる．

% % \subchapter{メソッドの生存期間}
% % \begin{figure*}[t]
% %     \centering
% % \includegraphics[width=1.0\textwidth]{./Yoshida_fig/state_plot.pdf}
% %     \caption{メソッドの生存期間}
% %     \label{fig:result}
% % \end{figure*}
% % メソッドごとの生存期間は図4.1に示す．\todo{この図は差し替える}

% \subchapter{クローンセットの部分削除}

% pandasプロジェクトにおいて，v0.19.0がリリースされた時点でのメソッドの例をListing~\ref{lis:include-deprecated-API}とListing~\ref{lis:include-inplace-API}に示す．これら二つのメソッドはコードクローン検出器によると類似度\todo{〇〇\%}となっており，コードクローンタイプ3である．どちらもPanelオブジェクトを生成しているという点では類似している．

% %----------------------------------
% \vspace{10pt}
% \begin{lstlisting}[caption=非推奨な記述方法を含むメソッド（次バージョンで削除）, label=lis:include-deprecated-API, captionpos=t, columns=flexible]
% def test_backwards_compat_without_term_object(self):
%     with ensure_clean_store(self.path) as store:

%         wp = Panel(np.random.randn(2, 5, 4), items=['Item1', 'Item2'],
%                    major_axis=date_range('1/1/2000', periods=5),
%                    minor_axis=['A', 'B', 'C', 'D'])
%         store.append('wp', wp)
%         with assert_produces_warning(expected_warning=FutureWarning,
%                                      check_stacklevel=False):
%             result = store.select('wp', [('major_axis>20000102'),
%                                          ('minor_axis', '=', ['A', 'B'])])
%         expected = wp.loc[:,
%                           wp.major_axis > Timestamp('20000102'),
%                           ['A', 'B']]
%         assert_panel_equal(result, expected)
% \end{lstlisting}
% \vspace{10pt}
% %----------------------------------
% Listing~\ref{lis:include-deprecated-API}は，古い形式のクエリの書き方が後方互換性を維持し，かつ，正しく動作するかを検証するメソッドである．
% コード内で\texttt{wp = Panel(...)}とある．ここでは，条件を\texttt{('カラム名','演算子','値')}というタプルのリストで渡している．そして，\texttt{with assert\textunderscore produces\textunderscore warning(FutureWarning)}を使って，「この記述方法が将来的に消える」という警告が出ることをテストしている．

% %----------------------------------
% \vspace{10pt}
% \begin{lstlisting}[caption=推奨APIを含むメソッド（次バージョンで生存）, label=lis:include-inplace-API, captionpos=t, columns=flexible]
% def test_panel_assignment(self):
%     # GH3777
%     wp = Panel(
%         randn(2, 5, 4), items=['Item1', 'Item2'],
%         major_axis=date_range('1/1/2000', periods=5),
%         minor_axis=['A', 'B', 'C', 'D'])
%     wp2 = Panel(
%         randn(2, 5, 4), items=['Item1', 'Item2'],
%         major_axis=date_range('1/1/2000', periods=5),
%         minor_axis=['A', 'B', 'C', 'D'])

%     # TODO: unused?
%     # expected = wp.loc[['Item1', 'Item2'], :, ['A', 'B']]

%     def f():
%         wp.loc[['Item1', 'Item2'], :, ['A', 'B']] = wp2.loc[
%             ['Item1', 'Item2'], :, ['A', 'B']]

%     self.assertRaises(NotImplementedError, f)
% \end{lstlisting}
% \vspace{10pt}
% %----------------------------------

% Listing~\ref{lis:include-inplace-API}は，まだ実装されていない操作に対して，適切にエラーを発生させているかを検証するテストメソッドである．
% 実行したい処理を内部関数\texttt{f()}の中で，\texttt{wp.loc[...] = wp2.loc[...]}という代入処理を記述している．そして，\texttt{self.assertRaises(NotImplementedError, f)}により関数\texttt{f()}を実行した際に，未実装のエラーが発生することをテストしている．

% Listing~\ref{lis:include-deprecated-API}における\texttt{test\textunderscore backwards\textunderscore compat\textunderscore without\textunderscore term\textunderscore object}メソッドは，v0.20.0リリース時には削除された．つまり，v0.19.0の時点では必要であったメソッドがv0.20.0の時点では不要であったため，削除されたと言える．
% 一方，Listing~\ref{lis:include-inplace-API}における\texttt{test\textunderscore panel\textunderscore assignment}メソッドはv0.20.0の時点でも削除されずに生存していたため，v0.20.0の時点では不要ではなく，必要なメソッドであると考えられる．その後，メジャーバージョンであるv1.0.0リリース直前のv0.25.0において不要となり，削除された．

% この結果から，v0.20.0では，\texttt{store.select}メソッドの古い形式の記述方法のサポートが終了したため，それを利用している側のコードが削除されたと考えられる．さらに，v0.25.0においては，\texttt{Panel}オブジェクトが削除されたため，それを呼び出しているメソッドも削除されたと考えられる．

% \subchapter{クローンセットの全てのメソッドが削除}
% v0.18.0がリリースされた時点において，クローンセットの全てのメソッドが削除された事例をListing~\ref{lis:test-get-options-data}とListing~\ref{lis:test-get-data-with-list}に示す．

% \vspace{10pt}
% \begin{lstlisting}[caption=v0.18.0における取引機能のテストメソッド（次バージョンで削除）, label=lis:test-get-options-data, captionpos=t, columns=flexible]
% @network
% def test_get_options_data(self):
%     # regression test GH6105
%     self.assertRaises(ValueError, self.aapl.get_options_data, month=3)
%     self.assertRaises(ValueError, self.aapl.get_options_data, year=1992)

%     try:
%         options = self.aapl.get_options_data(expiry=self.expiry)
%     except RemoteDataError as e:
%         raise nose.SkipTest(e)
%     self.assertTrue(len(options) > 1)

% \end{lstlisting}
% \vspace{10pt}

% Listing~\ref{lis:test-get-options-data}はオプション取引データの取得機能が正しく動作するかを検証するためのメソッドである．まず，\texttt{self.assertRaises(ValueError, ...)}によって，\texttt{self.aapl.get\textunderscore options\textunderscore data}メソッドに不正な引数を指定した場合に，正しくエラーが発生することを確認している．さらに，その後の\texttt{try...except...}句内で実際にデータを取得し，\texttt{self.assertTrue}によって，取得したデータが1以上であることを確認している．

% \vspace{10pt}
% \begin{lstlisting}[caption=v0.18.0におけるデータ一括取得のテストメソッド（次バージョンで削除）, label=lis:test-get-data-with-list, captionpos=t, columns=flexible]
% @network
% def test_get_data_with_list(self):
%     try:
%         data = self.aapl.get_call_data(expiry=self.aapl.expiry_dates)
%     except RemoteDataError as e:
%         raise nose.SkipTest(e)
%     self.assertTrue(len(data) > 1)

% \end{lstlisting}
% \vspace{10pt}

% Listing~\ref{lis:test-get-data-with-list}は，複数のリストをまとめて指定し，データを一括取得できるかを検証するテストコードである．\texttt{self.appl.get\textunderscore call\textunderscore data(expiry=self.aapl.expiry\textunderscore dates)}によって，データのリストを引数にいれ，データを取得する．そして，\texttt{try...except...}句内で実際にデータを取得し，\texttt{self.assertTrue}によって，取得したデータが1以上であることを確認している．

% Listing~\ref{lis:test-get-options-data}とListing~\ref{lis:test-get-data-with-list}は互いに，クローンと判定されたメソッドであり，類似度は\todo{X}\%である．これらは，v0.19.0で削除された．これらのメソッドのパスは\texttt{/pandas/io/tests/test\textunderscore data.py}に存在している．このパスに注目すると，v0.18.0においては，存在しているが，v0.19.0においては存在していなかった．つまり，これらのクローンメソッド群はファイル自体が削除されたことによって，同時にクローンセットごと削除されたと判定されたことがわかる．

% 次に，クローンセットの全てが削除された別の事例をListing~\ref{lis:median}とListing~\ref{lis:f}に示す．

% \vspace{10pt}
% \begin{lstlisting}[caption=v0.6.0における上位メソッド（次バージョンで削除）, label=lis:median, captionpos=t, columns=flexible]
% def median(self, axis='major', skipna=True):
%     def f(arr):
%         mask = common.notnull(arr)
%         if skipna:
%             return _tseries.median(arr[mask])
%         else:
%             if not mask.all():
%                 return np.nan
%             return _tseries.median(arr)
%     return self.apply(f, axis=axis)

% \end{lstlisting}
% \vspace{10pt}

% Listing~\ref{lis:median}は，内部に関数を定義し，それを\texttt{apply}メソッド用いることで，指定した軸に適用している．

% \vspace{10pt}
% \begin{lstlisting}[caption=v0.6.0における下位メソッド（次バージョンで削除）, label=lis:f, captionpos=t, columns=flexible]
% def f(arr):
%     mask = common.notnull(arr)
%     if skipna:
%         return _tseries.median(arr[mask])
%     else:
%         if not mask.all():
%             return np.nan
%         return _tseries.median(arr)

% \end{lstlisting}
% \vspace{10pt}

% Listing~\ref{lis:f}は，Listing~\ref{lis:median}の内部で定義されている関数である．つまり，関数の内部で関数が定義されている場合，それらの構造は類似しているとコードクローン検出器では，判定される．したがって，上位の関数が削除された場合，下位の関数も同時に削除される．

% これらの結果より，クローンと判定されたメソッド群が同時に削除される事例は上位概念の削除による副次的作用であることがわかる．

% さらに，追加分析として，ファイル削除に伴うクローンセットの削除について分析した．プロジェクト上で削除されたことのあるファイルパスを収集し，クローンセットの削除が行われたメソッドが存在しているファイルパスと対応させた．その結果，33\% \memo{多少数字は変わるかも}ほどのクローンセットごと削除されたメソッドは，上位のファイルが削除されたことによる副次的作用であることが判明した．

% \chapter{考察}

% 削除されたメソッドの中でもクローンを持つメソッドとクローンを持たないメソッドでは，異なる特徴を持つことがわかる．
% クローンセットの一部が削除されるという事例から，機能の移行期間では，一時的に類似機能を作成し，完全な移行が完了した時点で古いメソッドを削除するというパターンがあることがわかった．
% クローンセットが同時に削除されるという事例から，削除パターンの一つとして，上位概念の削除による副次的削除が含まれることがわかる．\todo{クローンを持たずに削除されたメソッドの事例も述べるべきか？}

% クローンセットの一部が削除されるということは，削除されたメソッドは，より品質の低いメソッドであり，生存したメソッドは，より品質の高いメソッドであると考えられる．このような品質の低いメソッドを学習し，同じような特徴を持つメソッドを検出できれば，ソフトウェアの品質を向上させられる可能性がある．

% %%%%%%%%%%%%%%%%%%%%%%%%
% \chapter{RQ2：メソッドの統合や分割はコードクローンと関連しているか}
% \label{chap:RQ2}
% % \chapter{RQ2: メソッドが削除される前にどのような変更が行われているか}
% %%%%%%%%%%%%%%%%%%%%%%%%

% \begin{figure}[t]
%     \centering
%     \includegraphics[width=1.0\linewidth]{@Bachelor2025_Yoshida/Yoshiba_fig/method_group.pdf}
%     \caption{メソッドの変更タイプの分類}
%     \label{fig:merge-clone-method}
% \end{figure}

% \chapter{概要}
% 第 \ref{chap:RQ1} 章で提案した手法では，バージョン間でのメソッド追跡を「シグネチャの一致」および「メソッド単体間の類似度」に基づいて行っていた．しかし，実際のソフトウェア開発では，リファクタリングに伴い，図 \ref{fig:merge-clone-method} に示すような複雑な変遷が発生する．具体的には，以下のケースが考慮されていないという課題があった．

% \begin{description}
%     \item[意味的な変更の見逃し: ] メソッド名が同一であっても，その内部実装が大幅に刷新され，実質的に別の機能へ置き換わっている場合．
%     \item[メソッドの分割: ] 一つのメソッドが担っていた機能が分割され，複数の小さなメソッドへと分散する場合．
%     \item[メソッドの統合: ] 複数のメソッドが一つにまとめられ，より大きな機能を持つメソッドへと変化する場合．
% \end{description}

% これらのケースを無視すると，実際には形を変えて生存しているメソッドが「削除」と誤判定される恐れがある．そこで本章では，LCS（最長共通部分列）を用いた類似度計算の特徴を活用し，メソッドの統合および分割を検出する手法を導入する．

% \chapter{分析手法}

% \noindent\emph{4. 同一メソッドの追跡}

% 第~\ref{chap:RQ1} 章の手順1から3は同様に実施するが，手順4において，シグネチャの一致に頼らず，3-B で定義した類似度指標のみを用いた柔軟な追跡を行う．これにより，リネームを伴う変更も追跡対象とする．

% \noindent\emph{5. メソッドの分割，統合の検出}

% LCS を用いた類似度計算は，2つのトークン列間で順序を保ったまま一致している部分を抽出する．このとき，比較対象間のトークン数の差異に着目することで，以下のルールに基づき統合と分割を判定する．

% \begin{description}
%     \item[分割: ] バージョン$V_{k}$におけるメソッド$c_{i}$と，バージョン$V_{k+1}$におけるメソッド$c_{i+1}$の類似度が閾値を超える．かつ，トークン数において，$0.7c_{i} > c_{i+1}$を満たす場合，メソッド$c_{i}$は$c_{i+1}$を含む複数のメソッドへ分割された可能性があると判定する．
%     \item[統合: ]  バージョン$V_{k}$におけるメソッド$c_{i}$と，バージョン$V_{k+1}$におけるメソッド$c_{i+1}$の類似度が閾値を超える．かつ，トークン数において，$c_{i} < 0.7c_{i+1}$を満たす場合，メソッド$c_{i}$は他のコードを取り込み，$c_{i+1}$へと統合された可能性があると判定する．
%     \item[変更: ] バージョン$V_{k}$におけるメソッド$c_{i}$と，バージョン$V_{k+1}$におけるメソッド$c_{i+1}$の類似度が閾値を超える．かつ，トークン数において上記のどちらの条件も満たさなかった場合，単純に変更されたメソッドであると判定する．
% \end{description}

% \chapter{結果}

% \begin{figure}[ht]
%     \centering
%     \includegraphics[width=1.0\linewidth]{@IPSJ_SIGSE202603_Yoshida/Yoshida_fig/boxplots_final.pdf}
%     \caption{メソッドのバージョン間での分類タイプの件数を表す箱ひげ図}
%     \label{fig:method-classification}
% \end{figure}

% 図~\ref{fig:method-classification}は左から順に，追加，削除，分割，統合，変更されたメソッドがバージョン間で何件存在するかを箱ひげ図で示している．青い箱ひげ図はクローンを持つメソッドであり，赤い箱ひげ図はクローンを持たないメソッドである．
% バージョン間では当然，生存（分割，統合，変更）がもっとも多い結果となっている．生存に次いで，追加が多く，100件以下で行われることは滅多にない．つまり，バージョン間でメソッドが追加される時は100件以上の単位で大規模に行われるということがわかる．削除に関しても，100件以上と大規模に行われるものの，100件以下の少数で行われることもある．メジャーバージョンのリリース直前のマイナーバージョンの更新においては，削除の件数が劇的に増加する．一方，メジャーバージョンのリリース後や，離れた時期においては，削除の件数は小さい．

% それぞれの分類タイプにおけるクローンの有無を調べた結果が表~\ref{tab:has-clone}である．分割や統合を起こしたメソッドのうち，97\%以上がクローンを持っている．つまり，分割や統合が起こるための必要条件として，クローンの有無が関係していることが考えられる．

% 一方，削除されたメソッドは約37\%がクローンを持つ．この理由として，クローンを持つメソッドの場合，削除時の影響範囲が拡大するため，メソッドはクローンを持たない方が削除されやすいという結果になったと考えられる．

% 変更において，クローンを持つ割合が約64\%ほどあるが，これらは将来的に，分割や統合に向かうと考えられる．

% \begin{table}[ht]
%     \centering
%     \caption{メソッドの状態分類におけるクローンの有無}
%     \begin{tabular}{c|ccccc}
%         \hline
%          & 追加 & 削除 & 分割 & 統合 & 変更 \\
%          \hline
%         クローンなし & 26,108 & 5,472 & 2,614 & 2,668 & 166,318 \\
%         クローンあり & - & 3,228 & 71,364 & 73,656 & 302,525 \\
%         \hline
%     \end{tabular}
%     \label{tab:has-clone}
% \end{table}

% \chapter{考察}
% \memo{分割，統合されたメソッドのほとんどはクローンを持っていた．分割や統合がされた後に，メソッドのクローンは解消されたのかどうかを確認したい．}\memo{クローンが解消されていた場合→クローンが解消されてからメソッドが削除}\memo{クローンが解消されていなかった場合→変更の過程でクローンが解消orクローンを持ったままRQ1のような削除}

% \memo{変更と分類されたメソッドが，最終的に，分割や統合に向かっているのか，あるいは削除に向かっているのかを確認したい．}
% % 図~\ref{fig:method-classification}の分類はメソッド単位で頻度を計測したものである．削除や分割，統合といった変更はファイルレベルやフォルダレベルで行われ，結果として，頻度が増大している可能性がある．したがって，メソッドレベルより，大きなレベルで変更を捉える必要がある．

% \chapter{メソッド追跡手法の妥当性}
% 本研究では，NILを用いてバージョン間の類似度を測定することで，メソッドの追加，削除，生存（分割，統合，変更）を捉えた．本手法の妥当性を検証するため，本手法で追加，削除，生存と判定されたそれぞれのメソッドについて，バージョン間でのファイルパスとメソッド名の完全一致について調査した．

% 追加と判定されたメソッドのファイルパスとメソッド名が前バージョンで存在していれば不正解，削除と判定されたメソッドのファイルパスとメソッド名が次バージョンで存在していれば不正解，生存と判定されたメソッドのファイルパスとメソッド名が次バージョンで存在していれば正解，というように判定した結果が表~\ref{tab:evaluation-classification}である．追加，削除，生存のどの分類においても正解率が0.79を超えている．したがって，本手法での誤検出が小さいと言える．

% \begin{table}[ht]
%     \centering
%     \caption{メソッド追跡手法における分類ごとの正解率}
%     \begin{tabular}{c|ccc}
%         \hline
%          & 追加 & 削除 & 生存  \\
%          \hline \hline
%         正解 & 24,905 & 6,757 & 414,945\\
%         不正解 & 420 & 1,752 & 107,336 \\
%         \hline
%         正解率 & 0.98 & 0.79 & 0.79 \\
%         \hline
%     \end{tabular}
%     \label{tab:evaluation-classification}
% \end{table}

% \chapter{妥当性の脅威}
% \label{chap:thread-to-validity}

% 本章では，本研究における結果の信頼性に影響を及ぼす可能性のある要因を，内的妥当性および外的妥当性の観点から述べる．

% \chapter{内的妥当性}

% 本研究で使用したコードクローンの検出ツールは閾値でコードクローンを判定しているため，閾値によっては，メソッドの分類件数が異なる可能性がある．類似度を判定するための閾値に関しては，従来研究で検証されている0.7を使用することを信頼性を担保した．

% クローンセットの一部のメソッドが削除された事例に関しては，目視で数件を確認しているため，この結果が全てのメソッドに当てはまるとは限らない．クローンセットの全メソッドが削除された事例に関しても，ファイルごと削除，内部メソッドの削除という事例は，あくまで一例である．したがって，分類された全てのメソッドに対して当てはまるとは言えない点は注意すべきである．

% 全てのコミット間隔ではなく，マイナーバージョンの間隔に絞って分析しているため，バージョン間で生成・削除された短命メソッドについては，見逃してしまう．しかし，これら短命のメソッドは開発者が一時的に導入するメソッドであるため，ソフトウェアにとって負債となり得ない．

% \chapter{外的妥当性}
% 本研究はPythonのpandasプロジェクトのみを対象としている．データサイエンス分野に特化したライブラリ特有の進化パターンが存在する可能性があり，他のドメイン（例：Webフレームワーク，組み込みシステム）や他のプログラミング言語（例：Java, C++）で開発されたプロジェクトにおいても同様の削除パターンやクローン整理の傾向が見られるかは不明である．今後はより多様なOSSプロジェクトを対象とした大規模な調査が求められる．

% \chapter{おわりに}
% \label{chap:conclusion}
% \todo{後で書く}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{はじめに}
\label{chap:background}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

多くのソフトウェア開発は，ソフトウェア部品の組み合わせで行われる\cite{liblary-reuse}．特に，特定の機能を再利用可能な形でまとめたライブラリの利用によって，ソフトウェアの開発工程を大幅に削減している\cite{reduce-productivity}．ライブラリ開発者もまた他のライブラリを使用しており，ソフトウェアエコシステム\cite{software-wcosystem}と呼ばれる大規模な依存関係のネットワークが形成されている．

ライブラリは多くのソフトウェアと同様に，機能の追加や改善を通じて進化を続けている．ただし，その進化の過程で，「ライブラリが外部へ公開しているAPIの名称変更」や「引数の変更」など，既存機能の変更や削除によって後方互換性を損失することがある\cite{detect-backward-compatibility}\cite{Brito2018WhyAH}．その中でも特に，ライブラリAPIの削除はクライアントソフトウェア（以降，クライアント）に甚大な影響を及ぼす．削除によって当該機能を使用するクライアントは，代替APIへの切り替え，自身での実装，機能廃止などの選択を迫られる\cite{client-action-on-deprecation}．その一方で，ライブラリにとっては，再利用性の向上や軽量化のために不要なソースコードの削除は効果的な手段であるため，ライブラリ開発者はクライアントへの影響範囲を考慮しつつ削除する方法を検討している\cite{Vzquez2019SlimmingJA}．

しかし，ライブラリの進化に伴い，ソースコード中には不要と考えられるコードが蓄積していく．不要コードの蓄積は保守コストの増加\cite{increase-maintainability}や可読性の低下\cite{decrease-readability}を引き起こすことが知られている．これに対処するため，開発者はソフトウェア再構成の一環としてメソッドの削除を行うことがある．しかし，どのメソッドを削除すべきかを客観的に判断することは容易ではなく，機能の必要性やクライアントへの影響など多様な要因を考慮する必要があるため，最終的には経験豊富な開発者の判断に依存しているのが現状である．

従来研究では，デッドコードや未使用変数などの不要なソースコードを検出する手法が提案されている\cite{detect-dead-code}\cite{dynamic-analysis}．また，ソースコードの変更履歴に着目し，削除されたコードの特徴を分析する研究も行われている\cite{static-analysis}．しかし，これらの手法には限界がある．不要コード検出手法は，実行状況や依存関係に基づいて検出を行うため，機能的に使用されているが開発者の判断で削除対象となるコード（例えば，APIポリシーの変更やモジュールの再構成による削除）は検出できない．また，変更履歴に基づく分析では，リファクタリングに伴うコードの移動が履歴上は削除として記録されるため，本質的な削除のみを識別することが難しいという課題がある．

そこで本研究では，メソッド間のクローン類似度に着目し，類似度がメソッド削除の判断指標として機能するかを検証する．クローン類似度に着目する理由は，類似機能を持つメソッドがプロジェクト内に複数存在する場合，開発者が機能の統合・整理のために一方を削除する可能性があるためである．具体的には，N-gramに基づくクローン検出ツールNIL\cite{NIL}を用い，OSSプロジェクトのバージョンごとにメソッドを抽出し，同一プロジェクト内のメソッド間の類似度を算出する．その上で，クローンの有無および類似度の高低とメソッドの削除率の関係，ならびにメソッドが削除・統合に至る過程での類似度の時系列的な推移を分析する．バージョン単位でメソッドを追跡することにより，コミットごとの解析と比較して計算コストを抑えつつ，複数コミットにわたるリファクタリングも捕捉できるという利点がある．

ケーススタディとして，広く利用されるPythonライブラリ1件における40,264件のメソッドを対象に分析した結果，クローンを持たないメソッドの削除率がクローンを持つメソッドより高いこと，メソッド統合前にはクローン類似度が段階的に上昇する一方，削除前にはそのような変化が見られないことを明らかにした．以上の結果から，クローン類似度の動的な変化はメソッド統合の予測に有効であるが，メソッド削除の予測には他の指標との組合せが必要であることが示唆される．

以降，本論文では，\ref{chap:deletecode}章で不要コードの背景と関連研究，本研究の研究課題を述べる．\ref{chap:approach}章では，本研究の分析手法を述べ，\ref{chap:case-study}章では，設定したRQにおけるそれぞれの結果を述べる．続く，\ref{chap:discussion}章では，本研究の分析による考察を述べ，\ref{chap:thread-to-validity}章では，本研究の妥当性の脅威を述べる．最後に\ref{chap:conclusion}章で本論文をまとめる．

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{不要コード}
\label{chap:deletecode}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{不要コードの種類}
ソフトウェアにとっての不要コードはステークホルダやタイミングによって異なる．クライアントにとって必要な機能であってもライブラリ開発者にとっては保持したくないソースコードもある．例えば，後方互換性を維持するだけのソースコードはライブラリにとっては不要であるが，古いバージョンを使用するクライアントにとっては必要である．また，頻繁に使用されるライブラリのAPIであっても，より効率的な代替APIが登場すれば不要とみなされることがある．
\todo{破壊的変更，後方互換生の話をする}

不要コード\cite{static-analysis}\cite{increase-maintainability}の代表例として，デッドコード\cite{static-analysis}\cite{dynamic-analysis}\cite{decrease-readability}と未実行コード\cite{static-analysis}\cite{increase-maintainability}が挙げられる．デッドコードはプログラム中で到達不可能なソースコードであり，未実行コードは観測期間において一度も実行されないソースコードである．

しかし，開発者がコードを削除する理由はデッドコードや未実行コードに限らない．例えば，Pythonのpandas-dev/pandas\footnote{\url{https://github.com/pandas-dev/pandas}}プロジェクトでは，v0.25.0における\texttt{pandas/io/common.py}内のメソッド\texttt{\textunderscore stringify\textunderscore path}が，他のファイルから呼び出されていたにもかかわらず，io関連メソッドの非公開化に伴い削除されていた\footnote{\url{https://github.com/pandas-dev/pandas/commit/0df8858752}}．このように，機能的に使用されているメソッドであっても，APIポリシーの変更やモジュールの再構成といったプロジェクトレベルの判断によって削除されることがある．

本研究では，不要コードの中でも特に，開発者の判断に基づいて削除されたメソッドに着目し，その削除に関わる定量的特徴量を調査する．

\section{不要コードが引き起こす問題}
不要コードがコードベースに蓄積することは，保守性と可読性の両面で問題を引き起こす．Ederら\cite{increase-maintainability}は，不要コードが保守コストの増加を引き起こすことを示している．ソースコードの修正時に，未使用のソースコードも同時に修正する必要があるため，無駄なコストが発生する．また，Romanoら\cite{decrease-readability}は，コードベースを理解する際に不要コードを読んでしまうことで，ソースコード理解の有効性や効率が低下することを示している．
したがって，開発者がコード削除を適切に判断するための定量的な指標が求められる．
\todo{ここをもっと増やす}

\section{関連研究}

\subsection{不要コードの検出手法}
不要コードの検出手法として，動的解析と静的解析に基づく手法が提案されている．

動的解析に基づく手法として，観測期間において実行されていないソースコードを検出し，自動で削除する手法が提案されている\cite{dynamic-analysis}．この手法では，ソフトウェア中のさまざまなコンポーネントにログを組み込み，実環境で一定期間運用することで実行状況のログを取得する．その後，実行履歴がないコンポーネントを不要コードと判定する．ただし，エラー処理や復旧用のソースコードのように，観測期間において実行されなくとも必要なコードが不要コードとして誤検出される場合がある．

静的解析に基づく手法として，依存関係に着目し，他との依存関係を持たないデッドコードを検出する手法が提案されている\cite{detect-dead-code}．この手法では，プログラムの制御フローや依存グラフを解析し，到達不可能なコードを特定する．ただし，リフレクションのように動的に依存関係が決まる場合には，依存関係を持たないと誤判定される可能性がある．

これらの手法は，実行状況や依存関係に基づいて不要コードを検出することを目的としている．しかし，機能的には使用されているが開発者の判断で削除対象となるコード（例えば，APIポリシーの変更や機能統合による削除）は，これらの手法では検出できない．

\subsection{削除コードの実証分析}
削除されたコードの特徴を事後的に分析する研究も行われている．Haasら\cite{static-analysis}は，削除ファイルの特徴を分析し，「最近変更されておらず，依存の中心にいない特徴を持つファイル」が「生存するファイル」に比べ有意に差があることを発見した．

Bhattaら\cite{study-of-test-deletion}は，テストコードの削除に着目し，削除されたテストメソッドの83.2\%はテストクラスごと削除され，7\%は冗長なテストであったことを明らかにした．さらに，削除されたテストメソッドの91.4\%はプロダクションコードの廃止による副次的な削除であった．

Sawantら\cite{why-deprecated}は，メソッドが非推奨になる理由をコミット履歴やイシュートラッカーを基に調査・分類した．その結果，「新機能の導入」「機能上の欠陥」「デザインパターン」の3種類で全体の約72\%を占めていた．

これらの研究は，削除の理由や特徴を事後的に分析している．しかし，メソッドの定量的なコード特徴量から削除を事前に予測可能かという問いについては未解明である．

\subsection{コードクローンと類似度分析}
コードクローンとは，ソースコード中に存在する同一または類似するコード断片のことである\cite{code-clone-survey}．コードクローンの存在は，保守コストの増加や不整合の原因となるため，クローンの検出やリファクタリング支援に関する研究が活発に行われている．

本研究で用いるNIL\cite{NIL}は，N-gramの逆インデックスとLCS（最長共通部分列）を組み合わせることで，大規模コードベースにおいても効率的にクローンを検出する手法である．特に，コピー後に多くの変更が加えられた大差分クローン（large-variance clone）の検出に優れている．

コードクローンと削除の関係について，類似機能を持つメソッドが同一プロジェクト内に複数存在する場合，開発者が機能の統合・整理のために一方を削除する可能性がある．逆に，クローンを持たない独立したメソッドは，機能自体の廃止によって削除される可能性がある．しかし，クローン類似度がメソッドの削除とどのように関連するかについては，従来研究では調査されていない．

\section{研究課題}

前節で述べたように，従来研究では不要コードの検出手法や削除理由の事後分析が行われてきた．しかし，メソッドの定量的なコード特徴量，特にクローン類似度が，削除の判断指標として機能するかは明らかにされていない．

本研究では，「開発者が削除した」という確定した事実をGround Truthとし，クローン類似度とメソッド削除の関係を定量的に分析する．実行履歴や依存関係に基づく検出ではなく，開発者が削除を行ったメソッドを対象とすることで，プロジェクトレベルの判断を含む多様な削除要因を包括的に捉える．

具体的には，類似するメソッドを持つか否か，および類似度の高低が，メソッドの削除にどのように関係するかを調査する．クローン類似度が単独で削除の判断指標として十分であるか，あるいは他の要因との組合せが必要であるかを含めて検証する．

以上に基づき，本研究では以下のリサーチクエスチョン（Research Questions）を設定する．
\begin{itemize}
  \item RQ1: メソッド間の類似度は，次バージョンにおける削除率とどのように関連しているか
  \item RQ2: メソッドが削除・統合される前に，メソッド間の類似度はどのように変化するか
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{アプローチ}
\label{chap:approach}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{概要}
本章では，OSSプロジェクトの進化過程における，メソッドの削除を分析するための手法を述べる．
まず，\ref{sec:detect-delete-method}節では，対象プロジェクトの特定バージョンからメソッドを抽出し，隣接バージョン間でメソッドを追跡することで，削除されたメソッドを特定する手法を説明する．
次に，\ref{sec:clone-analysis}節では，同一バージョン内のメソッド間の類似度と削除率の関係を分析する手法を述べる．
最後に，\ref{sec:temporal-tracking}節では，メソッドが削除・統合に至るまでのメソッド間類似度の時系列変化を追跡する手法を述べる．

\section{削除メソッドの特定方法}
\label{sec:detect-delete-method}

\noindent\emph{1. 解析対象バージョンの選定}

対象とするOSSのGitHub\footnote{\url{https://github.com/}}リポジトリから，全てのタグを取得する．取得したタグのうち，セマンティックバージョニングの命名規則に従うもののみを抽出する．
さらに，末尾に「rc」や「dev」といったプレリリース識別子を含むタグは正規表現で除外する．
また，本研究では，メジャーおよびマイナーバージョンの変遷に着目するため，パッチバージョンが0であるタグ（例：v1.2.0）のみを対象とする．パッチバージョン間隔では削除メソッドが0件となる場合があり，十分な変更量を確保するためにパッチバージョンを除外している．
これらのフィルタリングにより，メジャーおよびマイナーバージョンのタグを時系列順にK個抽出する．

\noindent\emph{2. メソッドのシグネチャとボディの取得}

取得したバージョンへ順次チェックアウトを行い，当該バージョンに含まれる全てのPythonファイル（.py）を対象に抽象構文木（Abstract Syntax Tree; 以降，AST）へパースする．このASTからメソッドのシグネチャを取得し，メソッドの一意な識別子を構成する（「ファイルパス，クラス名.メソッド名，引数，戻り値」という形式）．
同時にメソッドのボディもASTから取得し，トークン列に分割してリストとして保存する．

\noindent\emph{3. メソッドのN-gram化}

バージョン $k$ ($1 \le k < K$) における $M$ 個のメソッドの集合を $V_{k} = \{c_1, c_2, \dots, c_M\}$ とする．
各メソッド $c_m \in V_k$ に対して N-gram 化を行い，抽出された N-gram の集合を $G(c_m)$ と表す．
本研究では，従来研究と同様に 5-gram を採用する\cite{NIL}．

\noindent\emph{4. 同一メソッドの追跡と分類}

隣接するバージョン間でメソッドを追跡し，各メソッドの状態を分類する．追跡は以下の二段階で行う．

\noindent\emph{4a. シグネチャによる同一メソッドの判定}

隣接するバージョン$V_{k}$と$V_{k+1}$の間でシグネチャが完全に一致するメソッドを同一と見なし，共通のIDを割り当てる．

\noindent\emph{4b. 類似度による同一メソッドの判定}

手順4aでは，メソッドの中身やロジックが同一であっても，リネームやファイルの移動を受けたメソッドは同一と判定できない．
そこで，手順4aで対応が見つからなかったメソッドに対し，コードクローン検出器NILを用いて$c_m \in V_k$と$c_m \in V_{k+1}$間の類似度を計算する．
$V_{k}$における各メソッド$c_i$に対し，$V_{k+1}$における全てのメソッド$c_j$との類似度を計算する．
メソッド間の類似度を計算するとき，類似度が閾値を超えたメソッドを候補メソッドとする．従来研究と同様に類似度の閾値は0.7を使用する．
$V_{k}$における特定のメソッドに対し，$V_{k+1}$における複数のメソッドが閾値を超えた場合は，最大の類似度をもつメソッドを候補メソッドとする．

NILによる詳細な類似度計算（検証フェーズ）では，式~\ref{eq:sim-verif}を用いる．
\begin{equation}
\label{eq:sim-verif}
  \text{Sim}_{\text{verif}}(c_i, c_j) = \frac{\text{LCS}(c_i, c_j)}{\min(|c_i|, |c_j|)}
\end{equation}
なお，それぞれの記号は以下の意味を持つ．
\begin{description}
  \item[$c_i, c_j$:] 比較対象となる2つのメソッドのトークン列
  \item[$|c_i|, |c_j|$:] 各トークン列の長さ
  \item[$\text{LCS}(c_i, c_j)$:] 2つのトークン列間で、順序を保ったまま一致している最長共通部分列（Longest Common Subsequence）の長さ
\end{description}

ここで，具体的なトークン列を用いた計算例をListing~\ref{lis:method_c_i}とListing~\ref{lis:method_c_j}に示す．
$c_{i}$のトークン列は
\texttt{[def, get\textunderscore data, self, :, return, self, ., value]}
となり，$c_{j}$のトークン列は
\texttt{[def, get\textunderscore cleaned \textunderscore data, self, value, :, return, self, ., \textunderscore data]}
となる．
したがって，$|c_{i}| = 8$となり，$|c_{j}| = 9$となる．
ここで，最長共通部分列は\texttt{[def, self, :, return, self, .]}である．つまり，$\text{LCS}(c_{i}, c_{j}) = 6$である．
これを，式\ref{eq:sim-verif}に当てはめると，
\[\text{Sim}_{\text{verif}}(c_i, c_j) = \frac{6}{\min(8, 9)} = 0.75\]となる．この時，これらのメソッドの類似度は75\%と設定する．

\begin{figure}[t]
  \centering
  \begin{minipage}[t]{0.47\linewidth}
    \begin{lstlisting}[
      caption=メソッド$c_{i}$,
      label=lis:method_c_i,
      captionpos=t,
      columns=flexible
    ]
def get_data(self):
    return self.value
    \end{lstlisting}
  \end{minipage}\hfill
  \begin{minipage}[t]{0.47\linewidth}
    \begin{lstlisting}[
      caption=メソッド$c_{j}$,
      label=lis:method_c_j,
      captionpos=t,
      columns=flexible
    ]
def get_cleaned_data(self, value):
    return self._data
    \end{lstlisting}
  \end{minipage}
\end{figure}

本手法の特徴は，分母に最小値を用いている点にある．
これにより，一方がもう一方を包含している場合に類似度が高く算出される．
例えば，片方のメソッドに大量の新しいコードが追加されて全体の長さが大きく変化した場合でも，元のロジックが保存されていればクローンとして検出可能である．

しかし，LCSによる類似度計算は計算コストが高いため，式~\ref{eq:sim-filt}を用いたフィルタリングフェーズを導入し，明らかに異なるメソッド対を事前に除外する．
\begin{equation}
\label{eq:sim-filt}
  \text{Sim}_{\text{filt}}(c_i, c_j) = \frac{|G(c_i) \cap G(c_j)|}{\min(|G(c_i)|, |G(c_j)|)}
\end{equation}
なお，それぞれの記号は以下の意味を持つ．
\begin{description}
    \item[$G(c)$:]  メソッド$c$のN-gram集合
    \item[$|G(c_i) \cap G(c_j)|$] $c_i$と$c_j$で共通するN-gramの要素数
\end{description}

このフィルタリングにより，類似度が0.1未満のメソッド対に対するLCS計算を省略し，全体の実行時間を削減する．

例えば，Listing~\ref{lis:method_c_i}のメソッド$c_{i}$の5-gram集合は
\begin{align*}
  G(c_i) = \bigl\{ \;
    & \texttt{[def, get\_data, self, :, return]}, \\
    & \texttt{[get\_data, self, :, return, self]}, \\
    & \texttt{[self, :, return, self, .]}, \\
  & \texttt{[:, return, self, ., value]} \; \bigr\}
\end{align*}
となり，Listing~\ref{lis:method_c_j}のメソッド$c_{j}$の5-gram集合は
\begin{align*}
  G(c_j) = \bigl\{ \;
    & \texttt{[def, get\_cleaned\_data, self, value, :]}, \\
    & \texttt{[get\_cleaned\_data, self, value, :, return]}, \\
    & \texttt{[self, value, :, return, self]}, \\
    & \texttt{[value, :, return, self, .]}, \\
  & \texttt{[:, return, self, ., \_data]} \; \bigr\}
\end{align*}
となる．
これらのメソッドで共通する5-gramは存在しないため，\[\text{Sim}_{\text{filt}}(c_i, c_j) = \frac{|G(c_i) \cap G(c_j)|}{\min(|G(c_i)|, |G(c_j)|)} = \frac{0}{\min(4, 5)} = 0\]となる．
したがって，これらのメソッド対に対してLCS計算は行われない．

\noindent\textbf{メソッドの分類}

以上の追跡結果に基づき，$V_k$に存在する各メソッドを以下の3つに分類する．
\begin{description}
  \item[生存メソッド: ] 手順4aにより，$V_{k+1}$にシグネチャが一致するメソッドが存在するもの．あるいは，手順4aでは対応が見つからないが，手順4bにより，$V_{k+1}$に候補メソッドが存在するもの．
  \item[削除メソッド: ] 手順4a・4bのいずれでも$V_{k+1}$に対応するメソッドが見つからないもの．
\end{description}

\begin{figure}[ht]
  \centering
  \includegraphics[width=1.0\linewidth]{@Bachelor2025_Yoshida/Yoshiba_fig/classify-method}
  \caption{バージョン間での生存/統合/削除の分類}
  \label{fig:classify-survival-deleted}
\end{figure}

例えば，バージョン$V_{k}$において，Listing~\ref{lis:method_c_i}のメソッド$c_{i}$とListing~\ref{lis:method_ci+1}のメソッド$c_{i+1}$が存在し，バージョン$V_{k+1}$において，Listing~\ref{lis:method_c_j}のメソッド$c_{j}$が存在するときを考える．
$\text{Sim}_{\text{filt}}(c_{i}, c_j) = 0.75$である．同時に，$\text{Sim}_{\text{filt}}(c_{i+1}, c_j) = 0.70$であり，$c_{i+1}$が他に類似するメソッドが存在しない場合を考える．この場合，$c_{i}$の類似度の方が高いため，生存と判定し，$c_{i+1}$は統合と判定する．

\begin{lstlisting}[caption=メソッド$c_{i+1}$, label=lis:method_ci+1, captionpos=t, columns=flexible]
def earn_data(self):
    return self._data
\end{lstlisting}

\section{クローンの有無・類似度と削除の関係分析}
\label{sec:clone-analysis}

\ref{sec:detect-delete-method}節ではバージョン間において，メソッド間の類似度を用いることで，メソッドの追跡を行ったが，本節では同一バージョン内のメソッド間の類似度に着目する．
各バージョン$V_k$に対し，コードクローン検出器NILを用いて同一バージョン内の全メソッド間の類似度を算出する．算出結果に基づき，あるバージョン内で一つ以上の類似相手を持つメソッドを「類似あり」，それ以外を「類似なし」と定義する．ここで，あるメソッドが複数の類似相手を持つ場合，そのメソッドの代表類似度$Sim$は，全ての類似相手との類似度の中央値として算出する．

次に，\ref{sec:detect-delete-method}節の手法により，各メソッドを隣接バージョン$V_k$と$V_{k+1}$の間で追跡し，「生存メソッド」または「削除メソッド」にラベル付けする．以上より，メソッドを（類似あり/なし）$\times$（生存/削除）の4群に分け，バージョンごとの削除数・生存数・削除率の分布差を検定する．ここで，各バージョン遷移における削除率は，削除メソッド数を当該群の総メソッド数で除した値として定義する．

さらに，「類似あり」群に限り，高類似度群（$90\% \leq Sim$）と低類似度群（$70\% \leq Sim < 90\%$）に分け，削除率の分布が異なるかを検定する．

本データはバージョン遷移を単位とした対応のある構造を持つため，群間差の検定にはノンパラメトリックな対応あり検定であるウィルコクソンの符号付順位検定を用いる．同検定は順位に基づく手法であり，分布の非正規性や外れ値に頑健である．効果量としては，順位に基づく効果量（matched-pairs rank-biserial correlation：$r_{\mathrm{rb}}$）を用いる．

\section{メソッドの状態分類と類似度の時系列追跡}
\label{sec:temporal-tracking}

\ref{sec:detect-delete-method}節の手順4では，各バージョン遷移においてメソッドを生存・削除の2群に分類した．本節では，各メソッドの最終的な結末に基づき，以下の3群に分類する．

\begin{description}
  \item[生存群: ] \memo{さらに，ここを吸収したメソッドと生存したメソッドに分ける}追跡対象期間の最終バージョン遷移において，生存メソッドと判定されたメソッド．すなわち，観測期間の最後まで削除されなかったメソッドである．
  \item[統合群: ] \memo{吸収されたメソッド}最終バージョン遷移において，統合メソッドと判定されたメソッド．すなわち，そのメソッドのコードが他のメソッドに吸収・統合されたと考えられるメソッドである．
  \item[削除群: ] 最終バージョン遷移において，削除メソッドと判定されたメソッド．すなわち，プロジェクトから消滅したメソッドである．
\end{description}

次に，各メソッドの全バージョン遷移にわたる履歴を相対時間で正規化する．メソッドが結末（生存/統合/削除）を迎えたバージョン遷移を$t = 0$とし，そこから過去方向へ$t = -1, -2, \dots$と遡る．各時点$t$において，当該メソッドの同一バージョン内に存在する類似相手とのメソッド間の類似度（中央値）を記録する．この正規化により，異なるバージョンで結末を迎えたメソッド同士でも，「結末の何バージョン前か」という統一的な時間軸でメソッド間の類似度の推移を比較できる．

\begin{figure}[ht]
  \centering
  \includegraphics[width=1.0\linewidth]{@Bachelor2025_Yoshida/Yoshiba_fig/classify-group}
  \caption{最終状態での生存/統合/削除群の分類}
  \label{fig:classify-survival-deleted-merged}
\end{figure}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{ケーススタディ}
\label{chap:case-study}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{データセット}

\subsection{対象言語の選定}
本研究では，Pythonで開発されたOSSプロジェクトを分析対象とする．Pythonを選定した理由は以下の3点である．

第一に，Pythonは広く普及しているプログラミング言語である．TIOBE Index\cite{tiobe-index}において継続的に上位にランクされており，パッケージリポジトリPyPI\footnote{\url{https://pypi.org/}}には50万以上のパッケージが登録されている．Zhongら\cite{client-action-on-deprecation}もPythonエコシステムにおけるパッケージの非推奨化を研究対象としており，Pythonプロジェクトにおけるメソッド削除パターンの知見は広範なソフトウェア開発者にとって有益である．

第二に，本研究のアプローチでは，Pythonファイルを抽象構文木（AST）へパースし，メソッドのシグネチャとボディを抽出する．Pythonは標準ライブラリとして\texttt{ast}モジュール\footnote{\url{https://docs.python.org/3/library/ast.html}}を提供しており，サードパーティツールに依存することなく，全ての有効なPythonソースコードを正確にパースできる．

第三に，Pythonは動的型付け言語であるため，静的解析のみではメソッドの呼び出し関係を完全に解決することが困難である．このことは，\ref{chap:deletecode}章で述べた不要コード検出手法の限界をさらに大きくする．したがって，呼び出し関係ではなくクローン類似度に基づく本研究のアプローチは，動的型付け言語において特に有効であると考えられる．

表~\ref{tab:candidate-projects}に，主要な候補プロジェクトの比較を示す．

\begin{table}[ht]
  \centering
  \caption{候補プロジェクトの比較}
  \label{tab:candidate-projects}
  \scalebox{0.9}{
    \begin{tabular}{l|rrcccl}
      \hline
      プロジェクト & Stars & メジャー遷移 & 開発期間 & Python比率 & 非推奨ポリシー & 備考 \\
      \hline
      pandas       & 44k  & 3回 & 14年 & 高 & あり & データ分析ライブラリ \\
      NumPy        & 28k  & 2回 & 18年 & 低 & あり & コアがC/Cython \\
      scikit-learn & 61k  & 2回 & 14年 & 中 & あり & 0.xが長期間 \\
      Django       & 82k  & 5回 & 19年 & 高 & あり & Webフレームワーク \\
      Flask        & 69k  & 3回 & 14年 & 高 & あり & 小規模 \\
      Requests     & 52k  & 2回 & 13年 & 高 & なし & APIが安定 \\
      \hline
    \end{tabular}
  }
\end{table}

各候補プロジェクトが本研究の対象として不適切な理由を以下に述べる．NumPyは，コア部分がC/C++やCythonで実装されており，Python比率が低い．本研究のAST解析では\texttt{.py}ファイルのみを対象とするため，NumPyの主要なメソッドの多くが分析対象外となる．scikit-learnは，バージョン0.xの期間が長く（1.0のリリースは2023年），メジャーバージョン遷移が少ない．また，Estimatorパターン（fit/predict/transform）に基づく統一的なAPI設計により，クローンパターンにドメイン特有の偏りが生じる可能性がある．Djangoは大規模かつ長期間開発されているが，Webフレームワークであるため，メソッドの性質（ビュー，ミドルウェア，ORM）や削除理由（セキュリティ起因の削除等）がデータ分析ライブラリとは根本的に異なる．Flaskは，コアのコードベースが小規模であり，統計分析に十分なメソッド数が得られない．Requestsは，意図的にミニマリストなAPI設計を採用しており，メソッドの削除がほとんど発生しない．また，明確な非推奨ポリシーも存在しない．

以上の比較から，pandasが全ての基準を最もバランスよく満たしていると判断し，対象プロジェクトとして選定した．pandasはGitHub\footnote{\url{https://github.com/pandas-dev/pandas}}上で公開されており，44,000以上のStarを持つ．0.x，1.x，2.xの3つのメジャーバージョンを有し，各メジャーバージョン遷移時にはAPIの大幅な整理が行われている．また，pandasは明確な非推奨ポリシー\cite{pandas-deprecation-policy}を持ち，\texttt{FutureWarning}による事前警告を経た上でメソッドの削除が行われるため，開発者の計画的な判断に基づく削除を分析対象とすることができる．

\subsection{分析対象データの概要}

表~\ref{tab:dataset-summary}に，pandasプロジェクトの分析対象データの概要を示す．分析対象期間はv0.4.0（2011年9月）からv2.3.0（2025年6月）までの約14年間であり，セマンティックバージョニングに従うメジャーおよびマイナーバージョン（パッチバージョンが0のタグ）を抽出した結果，32バージョンが対象となった．メソッド数はv0.4.0の1,303件からv2.3.0の21,392件へと約16倍に増加しており，全バージョンにわたって追跡された一意なメソッドは40,264件である．

\begin{table}[ht]
  \centering
  \caption{分析対象データの概要}
  \label{tab:dataset-summary}
  \scalebox{0.9}{
    \begin{tabular}{l|r}
      \toprule
      項目 & 値 \\
      \midrule
      分析期間 & 2011年9月 -- 2025年6月（約14年間） \\
      対象バージョン数 & 32 \\
      メジャーバージョン遷移 & 2回（0.x$\to$1.x, 1.x$\to$2.x） \\
      初期メソッド数（v0.4.0） & 1,303 \\
      最終メソッド数（v2.3.0） & 21,263 \\
      一意なメソッド総数 & 40,264 \\
      削除メソッド数 & 7,636 \\
      統合メソッド数 & 11,723 \\
      生存メソッド数 & 20,905 \\
      \bottomrule
    \end{tabular}
  }
\end{table}

\section{RQ1: メソッド間の類似度は，次バージョンにおける削除率とどのように関連しているか}

\subsection{概要}
ソフトウェアの規模拡大を抑制する手段の一つに，類似するコードを持つメソッドの整理・統合がある．一方で，独自の機能を持つメソッドも機能自体の廃止に伴い，削除される可能性がある．本節では，メソッド間の類似度という静的な特徴が，これら異なる要因による削除とどのように関連しているかを調査する．
具体的には，メソッドを「類似なし」「類似あり」「低類似」「高類似」に分類し，それぞれの削除率の傾向を比較分析する．

\subsection{結果}

\begin{table*}[ht]
  \centering
  \caption{ウィルコクソンの符号付き順位検定を用いた，メソッドの類似度と削除/生存の関係}
  \scalebox{0.95}{
  \begin{tabular}{l|rrcc|rrcc}
    \toprule
    & 類似なし & 類似あり & p値 & $r_{\mathrm{rb}}$ & 低類似 & 高類似 & p値 & $r_{\mathrm{rb}}$ \\
    \midrule
    平均削除数 & 155 & 92 & $6.52 \times 10^{-9}$ & 0.73 & 69 & 23 & $8.79 \times 10^{-6}$ & 0.80 \\
    平均生存数 & 5,464 & 4,286 & $9.31 \times 10^{-10}$ & 0.77 & 3,475 & 810 & $9.31 \times 10^{-10}$ & 1.10 \\
    平均削除率 & 0.033 & 0.025 & $1.45 \times 10^{-4}$ & 0.48 & 0.024 & 0.029 & $3.38 \times 10^{-2}$ & 0.38 \\
    \bottomrule
  \end{tabular}
  }
  \label{tab:test-clone}
\end{table*}

表~\ref{tab:test-clone}は，隣接バージョン遷移におけるメソッドの削除数・生存数・削除率の平均を群別に算出し，ウィルコクソンの符号付順位検定で群間差を検定した結果を示す．

まず，削除率に着目する．類似なし群のメソッドの平均削除率（0.033）は類似あり群のメソッドの平均削除率（0.025）を有意に上回っており（$p < 0.01$，$r_{\mathrm{rb}} = 0.48$，中程度の効果量），類似なしメソッドの方が削除されやすい傾向が確認された．なお，削除数・生存数の絶対値についても，類似なし群が類似あり群を有意に上回っていた（$p < 0.01$，$r_{\mathrm{rb}} = 0.73, 0.77$，大きな効果量）．

さらに，類似あり群内で高類似群（$90\% \leq Sim$）と低類似群（$70\% \leq Sim < 90\%$）を比較すると，高類似群のメソッドの平均削除率（0.029）が低類似群のメソッドの平均削除率（0.024）を有意に上回っていた（$p < 0.01$，$r_{\mathrm{rb}} = 0.38$，中程度の効果量）．なお，削除数，生存数の絶対値については，低類似群の方が平均削除数，平均生存数，共に有意に上回っていた（$p < 0.01$，$r_{\mathrm{rb}} = 0.80, 1.10$，大きな効果量）．

以上の結果から，類似するコードを持たないメソッドが最も削除されやすく，類似するコードを持つメソッドの中ではメソッド間の類似度が高いほど削除されやすいという傾向が確認された．この知見の解釈は第\ref{chap:discussion}章で議論する．

\section{RQ2: メソッドが削除・統合される前に，メソッド間の類似度はどのように変化するか}

\subsection{概要}

RQ1では，ある時点でのメソッド間の類似度の高低が削除に関係することを示した．本節では，メソッドが最終的に削除・統合・生存のいずれの結末を迎えるかによって，その過程におけるメソッド間の類似度の推移に特徴的な差異が存在するかを調査する．具体的には，\ref{sec:temporal-tracking}節の手法を用い，3群（生存群・統合群・削除群）におけるメソッド間の類似度変化を相対時間軸で可視化し，比較する．

\subsection{結果}

図~\ref{fig:deletion-survival}は，メソッドが持つメソッド間の類似度の全メソッドでの分布を示す箱ひげ図である．箱ひげ図はメソッド間の類似度の分布を群別に示し相対時間ごとに並べる．図~\ref{fig:deletion-survival-sample}は各時点における群ごとのメソッドの総数を示す．横軸の相対時間$t = 0$はメソッドが結末\memo{終点？}を迎えた時点を表し，負の値ほど過去に遡る．

\begin{figure*}[ht]
  \centering
  \includegraphics[width=1.0\linewidth]{@Bachelor2025_Yoshida/Yoshiba_fig/deletion_survival_boxplot}
  \caption{各相対時間でのメソッド間の類似度を示すメソッドの分布}
  \label{fig:deletion-survival}
  \includegraphics[width=1.0\linewidth]{@Bachelor2025_Yoshida/Yoshiba_fig/deletion_survival_lineplot}
  \caption{各相対時間での各群のメソッドの総数を示す折れ線グラフ}
  \label{fig:deletion-survival-sample}
\end{figure*}

\noindent\textbf{知見1: 統合群は結末に近づくにつれメソッド間類似度が上昇する}

統合群のメソッド間の類似度の中央値は，$t = -10$付近では約83\%から85\%であるが，$t = 0$に近づくにつれて上昇し，$t = 0$では約95\%から100\%に達する．この傾向は，メソッドが他のメソッドに吸収・統合される前に，当該メソッドと類似メソッドの間でコードの収束が進んでいることを示唆する．すなわち，開発者がリファクタリングや機能統合を段階的に進める過程で，メソッド間の類似度が徐々に高まり，最終的に統合に至るというパターンが読み取れる．

\noindent\textbf{知見2: 削除群と生存群のメソッド間の類似度は同様の推移を示す}

削除群と生存群のメソッド間の類似度は，いずれも約75\%から85\%の範囲で安定して推移しており，結末に向けた明確な変化傾向は観察されない．この結果は，メソッド間の類似度の水準だけでは，削除されるメソッドと生存するメソッドを区別できないことを意味する．

以上より，RQ2に対する回答として，メソッドの統合前にはメソッド間の類似度の上昇が観察される一方，削除前にはそのようなメソッド間の類似度の変化は観察されないことがわかった．

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{考察}
\label{chap:discussion}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{なぜ類似するコードの有無が削除傾向を分けるか}

RQ1では，類似するコードを持たないメソッドの削除率が類似するコードを持つメソッドの削除率よりも有意に高いことが示された．この結果について，類似するコードの有無が「機能需要のシグナル」として機能している可能性を議論する．

同一プロジェクト内に類似するコードを持つメソッドが複数存在することは，その類似するコードが複数の文脈で必要とされていることを意味する．すなわち，類似するコードを持つメソッドは，プロジェクト内で繰り返し利用される実装パターンを体現しており，そのパターンに対する需要が存在する限り削除されにくい．

一方，類似するコードを持たないメソッドは，特定の用途に限定された機能である可能性が高い．例えば，後方互換性を維持するためのラッパーメソッドや，一時的なテスト補助関数などは，他に類似するメソッドを持たず，その用途が不要になれば削除対象となりうる．

さらに，類似するコードを持つメソッドの中でも，より高類似（$90\% \leq Sim$）なコードを含むメソッドの削除率が低類似（$70\% \le Sim \leq 90\%$）なコードを含むメソッドの削除率を上回っていた点について考察する．類似度が90\%を超えるコードを持つメソッドは，ほぼ同一のコードを含む別メソッドが存在することを意味し，機能の重複を示す指標と解釈できる．一方，70\%から90\%類似するコードを含むメソッドは，共通する基盤を持ちながらも各メソッドが固有の役割を担っている可能性が高く，単純な統合対象にはなりにくい．

以上より，メソッドの削除には少なくとも2つの異なるメカニズムが存在すると考えられる．第一に，類似するコードを持たないメソッドが機能自体の廃止に伴い削除される「機能廃止型」の削除である．第二に，高類似なコードを含むメソッドが重複整理のために一方が削除される「冗長性解消型」の削除である．両者はメカニズムが異なるが，いずれも削除率を高める方向に作用しており，RQ1で観察された非単調なパターン（類似するコードなしが最も高く，次いで高類似なコードあり，低類似なコードありが最も低い）を説明する．

\section{なぜメソッド間の類似度変化の違いが削除と統合を分けるか}
\label{sec:developer-behavior}

RQ2の結果は，統合と削除における開発者の行動パターンに質的な違いがあることを示唆している．

最終的に統合されたメソッドでは，メソッド間の類似度が結末に近づくにつれて急激に上昇する傾向が観察された．このような類似度の上昇は，偶然ではなく，開発者がリファクタリングの過程でメソッドを意図的に近づけていくプロセスを反映していると考えられる．すなわち，メソッドの統合は一度の変更で完了するのではなく，計画的に進められる段階的なプロセスであることが示唆される．開発者は，類似するメソッドのロジックを少しずつ共通化し，十分にメソッド間の類似度が高まった段階で最終的な統合を実施するという行動パターンが読み取れる．

一方，最終的に削除されたメソッドでは，結末に向けてメソッド間の類似度に大きな変化が観察されなかった．これは，削除がコードレベルの段階的な変化を伴わず，ある時点で突然決定されることを意味する．この行動パターンは，削除がAPIポリシーの見直しやメジャーバージョンのリリース，依存ライブラリのバージョン更新，破壊的変更といったプロジェクトレベルの意思決定に起因することと整合する．

この対比は，コードメトリクスによって捕捉可能な開発者行動の範囲を示唆している．統合はコードレベルの変化として開発者の意図が反映されるため，メトリクスによる検知が可能である．しかし，削除はコード外の要因（プロジェクト方針やロードマップ）によって駆動されるため，コードメトリクス単独では検知が困難である．この差異こそが，メソッドが持つコードとの類似度が統合の予測には有効であるが削除の予測には不十分であるという本研究の知見の本質的な理由であると考えられる．


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{妥当性の脅威}
\label{chap:thread-to-validity}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

本章では，本研究における結果の信頼性に影響を及ぼす可能性のある要因を，内的妥当性および外的妥当性の観点から述べる．

\section{内的妥当性}

本研究で使用したコードクローンの検出ツールは閾値でコードクローンを判定しているため，閾値によっては，メソッドの分類件数が異なる可能性がある．類似度を判定するための閾値に関しては，従来研究で検証されている0.7を使用することを信頼性を担保した．

全てのコミット間隔ではなく，マイナーバージョンの間隔に絞って分析しているため，バージョン間で生成・削除された短命メソッドについては，見逃してしまう．しかし，これら短命のメソッドは開発者が一時的に導入するメソッドであるため，ソフトウェアにとって負債となり得ない．

\section{外的妥当性}
本研究はPythonのpandasプロジェクトのみを対象としている．データサイエンス分野に特化したライブラリ特有の進化パターンが存在する可能性があり，他のドメイン（例：Webフレームワーク，組み込みシステム）や他のプログラミング言語（例：Java, C++）で開発されたプロジェクトにおいても同様の削除パターンやクローン整理の傾向が見られるかは不明である．今後はより多様なOSSプロジェクトを対象とした大規模な調査が求められる．

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{おわりに}
\label{chap:conclusion}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

本研究では，メソッド間の類似度が削除の判断指標として機能するかを検証した．Pythonライブラリpandasの40,264件のメソッドを対象に，2つのリサーチクエスチョンに基づき分析を行った．

RQ1の分析では，他と類似するコードを持たないメソッドの削除率（3.3\%）が他と類似するコードを持つメソッド（2.5\%）より有意に高く，他と類似するコードを持つメソッドの中では高類似なコードを含むほど削除されやすいことを示した．RQ2の分析では，メソッドの統合前にはメソッド間の類似度が急激に上昇する一方，削除前にはメソッド間の類似度が変化しないことを明らかにした．

以上の結果から，メソッド間の類似度の動的な変化はメソッド統合の予測指標として有効であるが，メソッド削除の予測には単独では不十分であり，削除はプロジェクトレベルの意思決定に依存していることが示唆された．

今後の課題として，メソッド間の類似度に加え，依存関係や変更頻度などの他のメトリクスとの組合せによる削除指標の精緻化，および対象プロジェクトの多様化による知見の一般性の検証が挙げられる．近年，AIによるコード生成の普及に伴い，不要コードがソフトウェアに混入する機会が増加しており，メソッド削除の判断を支援する定量的な指標の重要性は今後さらに高まると考えられる．

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%
%% 謝辞
%%
%% \begin{acknowledgements}
%% 感謝します．
%% \end{acknowledgements}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%
%% 参考文献
%%
\bibliographystyle{junsrt}
\bibliography{@Bachelor2025_Yoshida/yoshida_refs}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%
%% 付録
%%
% \appendix
%
% \chapter{サンプルプログラム}
%
% プログラムリストや実行結果など，本論を補足する上で必要と思われるものが
% あれば付録として付ける．
%
% {
% \footnotesize
% \begin{verbatim}
% #include <stdio.h>
% int main(void)
% {
%     printf("Hello, World!\n");
%     return 0;
% }
% \end{verbatim}
% }

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\end{document}

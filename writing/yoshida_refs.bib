@article{Alikhanifard:TOSEM:2024:RefactoringMiner3.0,
  author     = {Alikhanifard, Pouria and Tsantalis, Nikolaos},
  title      = {A Novel Refactoring and Semantic Aware Abstract Syntax Tree Differencing Tool and a Benchmark for Evaluating the Accuracy of Diff Tools},
  year       = {2025},
  issue_date = {February 2025},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {34},
  number     = {2},
  issn       = {1049-331X},
  url        = {https://doi.org/10.1145/3696002},
  doi        = {10.1145/3696002},
  journal    = {ACM Transactions on Software Engineering and Methodology},
  month      = jan,
  articleno  = {40},
  numpages   = {63},
  keywords   = {Source code differencing, Abstract Syntax Trees, Benchmark}
}

@article{Brito2018WhyAH,
  title   = {Why and how Java developers break APIs},
  author  = {Aline Brito and Laerte Xavier and Andr{\'e} C. Hora and Marco T{\'u}lio Valente},
  journal = {2018 IEEE 25th International Conference on Software Analysis, Evolution and Reengineering (SANER)},
  year    = {2018},
  pages   = {255-265},
  url     = {https://api.semanticscholar.org/CorpusID:4618865}
}

@inproceedings{client-action-on-deprecation,
  author    = {Zhong, Zhiqing and He, Shilin and Wang, Haoxuan and Yu, Boxi and Yang, Haowen and He, Pinjia},
  title     = {An Empirical Study on Package-Level Deprecation in Python Ecosystem},
  year      = {2025},
  isbn      = {9798331505691},
  publisher = {IEEE Press},
  url       = {https://doi.org/10.1109/ICSE55347.2025.00046},
  doi       = {10.1109/ICSE55347.2025.00046},
  abstract  = {Open-source software (OSS) plays a crucial role in modern software development. Utilizing OSS code can greatly accelerate software development, reduce redundancy, and enhance reliability. Python, a widely adopted programming language, is renowned for its extensive and diverse third-party package ecosystem. However, a significant number of OSS packages within the Python ecosystem are in poor maintenance, leading to potential risks in functionality and security. Consequently, it is essential to establish a deprecation mechanism to assist package developers and users in managing packages effectively.To facilitate the establishment of the package-level deprecation mechanism, this paper presents a mixed-method empirical study, including data analysis and surveys. We investigate the current practices of announcing, receiving, and handling package-level deprecation in the Python ecosystem. We also assess the benefits of having deprecation announcements for inactively maintained packages. Furthermore, we investigate the challenges faced by package developers and users and their expectations for future deprecation practices. Our findings reveal that 75.4\% of inactive package developers have no intention of releasing deprecation declarations for various reasons, while 89.5\% of users express a desire to be notified about the deprecation, highlighting a gap between developers and users; in many cases, no alternative solutions are available when deprecation occurs, emphasizing the need to explore practical approaches that enable seamless package handover and require less maintenance effort. Our work aims to enhance the understanding of existing package-level deprecation patterns within the Python OSS realm and facilitate the development of deprecation practices for the Python community in the future.},
  booktitle = {Proceedings of the IEEE/ACM 47th International Conference on Software Engineering},
  pages     = {66–77},
  numpages  = {12},
  keywords  = {deprecation, open source, empirical study},
  location  = {Ottawa, Ontario, Canada},
  series    = {ICSE '25}
}

@article{code-clone-survey,
  author     = { Abdullah Sheneamer, Jugal Kalita },
  title      = { A Survey of Software Clone Detection Techniques },
  journal    = { International Journal of Computer Applications },
  issue_date = { March 2016 },
  volume     = { 137 },
  number     = { 10 },
  month      = { March },
  year       = { 2016 },
  issn       = { 0975-8887 },
  pages      = { 1-21 },
  numpages   = {9},
  url        = { https://ijcaonline.org/archives/volume137/number10/24308-2016908896/ },
  doi        = { 10.5120/ijca2016908896 },
  publisher  = {Foundation of Computer Science (FCS), NY, USA},
  address    = {New York, USA}
}

@article{decrease-readability,
  author   = {Romano, Simone and Vendome, Christopher and Scanniello, Giuseppe and Poshyvanyk, Denys},
  journal  = {IEEE Transactions on Software Engineering},
  title    = {A Multi-Study Investigation into Dead Code},
  year     = {2020},
  volume   = {46},
  number   = {1},
  pages    = {71-99},
  keywords = {Software systems;Maintenance engineering;Software engineering;Interviews;Tools;Open source software;Dead code;unreachable code;unused code;bad smell;empirical investigation;multi-study},
  doi      = {10.1109/TSE.2018.2842781}
}

@article{detect-backward-compatibility,
  author    = {Akinori, Ihara and Daiki, Maekawa and Kazuki, Matsuda},
  title     = {JavaScriptライブラリのテストコード変更に基づく後方互換性を損失するバージョン検出},
  journal   = {情報処理学会論文誌},
  issn      = {1882-7764},
  publisher = {情報処理学会},
  year      = {2025},
  month     = {05},
  volume    = {66},
  number    = {5},
  pages     = {808-818},
  doi       = {10.20729/0002002130},
  url       = {https://cir.nii.ac.jp/crid/1390867278057382016}
}

@article{detect-dead-code,
  author   = {Malavolta, Ivano and Nirghin, Kishan and Scoccia, Gian Luca and Romano, Simone and Lombardi, Salvatore and Scanniello, Giuseppe and Lago, Patricia},
  journal  = {IEEE Transactions on Software Engineering},
  title    = {JavaScript Dead Code Identification, Elimination, and Empirical Assessment},
  year     = {2023},
  volume   = {49},
  number   = {7},
  pages    = {3692-3714},
  keywords = {Codes;Optimization;Libraries;Energy consumption;Costs;Loading;Source coding;Dead code;JavaScript},
  doi      = {10.1109/TSE.2023.3267848}
}

@inproceedings{dynamic-analysis,
  author    = {Shackleton, Will and Cohn-Gordon, Katriel and Rigby, Peter C. and Abreu, Rui and Gill, James and Nagappan, Nachiappan and Nakad, Karim and Papagiannis, Ioannis and Petre, Luke and Megreli, Giorgi and Riggs, Patrick and Saindon, James},
  title     = {Dead Code Removal at Meta: Automatically Deleting Millions of Lines of Code and Petabytes of Deprecated Data},
  year      = {2023},
  isbn      = {9798400703270},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/3611643.3613871},
  doi       = {10.1145/3611643.3613871},
  abstract  = {Software constantly evolves in response to user needs: new features are built, deployed, mature and grow old, and eventually their usage drops enough to merit switching them off. In any large codebase, this feature lifecycle can naturally lead to retaining unnecessary code and data. Removing these respects users’ privacy expectations, as well as helping engineers to work efficiently. In prior software engineering research, we have found little evidence of code deprecation or dead-code removal at industrial scale. We describe Systematic Code and Asset Removal Framework (SCARF), a product deprecation system to assist engineers working in large codebases. SCARF identifies unused code and data assets and safely removes them. It operates fully automatically, including committing code and dropping database tables. It also gathers developer input where it cannot take automated actions, leading to further removals. Dead code removal increases the quality and consistency of large codebases, aids with knowledge management and improves reliability. SCARF has had an important impact at Meta. In the last year alone, it has removed petabytes of data across 12.8 million distinct assets, and deleted over 104 million lines of code.},
  booktitle = {Proceedings of the 31st ACM Joint European Software Engineering Conference and Symposium on the Foundations of Software Engineering},
  pages     = {1705–1715},
  numpages  = {11},
  keywords  = {Automated refactoring, Code transformation, Data cleanup, Data purging},
  location  = {San Francisco, CA, USA},
  series    = {ESEC/FSE 2023}
}

@inproceedings{increase-maintainability,
  author    = {Eder, Sebastian and Junker, Maximilian and Jürgens, Elmar and Hauptmann, Benedikt and Vaas, Rudolf and Prommer, Karl-Heinz},
  booktitle = {2012 34th International Conference on Software Engineering (ICSE)},
  title     = {How much does unused code matter for maintenance?},
  year      = {2012},
  volume    = {},
  number    = {},
  pages     = {1102-1111},
  keywords  = {Maintenance engineering;Assembly;Software systems;Business;Information systems;Production;Software maintenance;dynamic analysis;unnecessary code;unused code},
  doi       = {10.1109/ICSE.2012.6227109}
}

@article{Lacuna,
  title   = {JavaScript Dead Code Identification, Elimination, and Empirical Assessment},
  author  = {I. Malavolta and Kishan Nirghin and Gian Luca Scoccia and Simone Romano and Salvatore Lombardi and G. Scanniello and Patricia Lago},
  journal = {IEEE Transactions on Software Engineering},
  year    = {2023},
  volume  = {49},
  pages   = {3692-3714},
  doi     = {10.1109/tse.2023.3267848}
}

@article{liblary-reuse,
  author     = {Kula, Raula Gaikovina and German, Daniel M. and Ouni, Ali and Ishio, Takashi and Inoue, Katsuro},
  title      = {Do developers update their library dependencies?},
  year       = {2018},
  issue_date = {February  2018},
  publisher  = {Kluwer Academic Publishers},
  address    = {USA},
  volume     = {23},
  number     = {1},
  issn       = {1382-3256},
  url        = {https://doi.org/10.1007/s10664-017-9521-5},
  doi        = {10.1007/s10664-017-9521-5},
  abstract   = {Third-party library reuse has become common practice in contemporary software development, as it includes several benefits for developers. Library dependencies are constantly evolving, with newly added features and patches that fix bugs in older versions. To take full advantage of third-party reuse, developers should always keep up to date with the latest versions of their library dependencies. In this paper, we investigate the extent of which developers update their library dependencies. Specifically, we conducted an empirical study on library migration that covers over 4,600 GitHub software projects and 2,700 library dependencies. Results show that although many of these systems rely heavily on dependencies, 81.5\% of the studied systems still keep their outdated dependencies. In the case of updating a vulnerable dependency, the study reveals that affected developers are not likely to respond to a security advisory. Surveying these developers, we find that 69\% of the interviewees claimed to be unaware of their vulnerable dependencies. Moreover, developers are not likely to prioritize a library update, as it is perceived to be extra workload and responsibility. This study concludes that even though third-party reuse is common practice, updating a dependency is not as common for many developers.},
  journal    = {Empirical Softw. Engg.},
  month      = feb,
  pages      = {384–417},
  numpages   = {34},
  keywords   = {Security vulnerabilities, Software maintenance, Software reuse}
}

@inproceedings{NIL,
  author    = {Nakagawa, Tasuku and Higo, Yoshiki and Kusumoto, Shinji},
  title     = {NIL: large-scale detection of large-variance clones},
  year      = {2021},
  isbn      = {9781450385626},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/3468264.3468564},
  doi       = {10.1145/3468264.3468564},
  abstract  = {A code clone (in short, clone) is a code fragment that is identical or similar to other code fragments in source code. Clones generated by a large number of changes to copy-and-pasted code fragments are called large-variance (modifications are scattered) or large-gap (modifications are in one place) clones. It is difficult for general clone detection techniques to detect such clones and thus specialized techniques are necessary. In addition, with the rapid growth of software development, scalable clone detectors that can detect clones in large codebases are required. However, there are no existing techniques for quickly detecting large-variance or large-gap clones in large codebases. In this paper, we propose a scalable clone detection technique that can detect large-variance clones from large codebases and describe its implementation, called NIL. NIL is a token-based clone detector that efficiently identifies clone candidates using an N-gram representation of token sequences and an inverted index. Then, NIL verifies the clone candidates by measuring their similarity based on the longest common subsequence between their token sequences. We evaluate NIL in terms of large- variance clone detection accuracy, general Type-1, Type-2, and Type- 3 clone detection accuracy, and scalability. Our experimental results show that NIL has higher accuracy in terms of large-variance clone detection, equivalent accuracy in terms of general clone detection, and the shortest execution time for inputs of various sizes (1–250 MLOC) compared to existing state-of-the-art tools.},
  booktitle = {Proceedings of the 29th ACM Joint Meeting on European Software Engineering Conference and Symposium on the Foundations of Software Engineering},
  pages     = {830–841},
  numpages  = {12},
  keywords  = {Scalability, Large-Variance Clone, Clone Detection},
  location  = {Athens, Greece},
  series    = {ESEC/FSE 2021}
}

@inproceedings{reduce-productivity,
  author    = {Abdalkareem, Rabe and Nourry, Olivier and Wehaibi, Sultan and Mujahid, Suhaib and Shihab, Emad},
  title     = {Why do developers use trivial packages? an empirical case study on npm},
  year      = {2017},
  isbn      = {9781450351058},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/3106237.3106267},
  doi       = {10.1145/3106237.3106267},
  abstract  = {Code reuse is traditionally seen as good practice. Recent trends have pushed the concept of code reuse to an extreme, by using packages that implement simple and trivial tasks, which we call `trivial packages'. A recent incident where a trivial package led to the breakdown of some of the most popular web applications such as Facebook and Netflix made it imperative to question the growing use of trivial packages.  Therefore, in this paper, we mine more than 230,000 npm packages and 38,000 JavaScript applications in order to study the prevalence of trivial packages. We found that trivial packages are common and are increasing in popularity, making up 16.8\% of the studied npm packages. We performed a survey with 88 Node.js developers who use trivial packages to understand the reasons and drawbacks of their use. Our survey revealed that trivial packages are used because they are perceived to be well implemented and tested pieces of code. However, developers are concerned about maintaining and the risks of breakages due to the extra dependencies trivial packages introduce. To objectively verify the survey results, we empirically validate the most cited reason and drawback and find that, contrary to developers' beliefs, only 45.2\% of trivial packages even have tests. However, trivial packages appear to be `deployment tested' and to have similar test, usage and community interest as non-trivial packages. On the other hand, we found that 11.5\% of the studied trivial packages have more than 20 dependencies. Hence, developers should be careful about which trivial packages they decide to use.},
  booktitle = {Proceedings of the 2017 11th Joint Meeting on Foundations of Software Engineering},
  pages     = {385–395},
  numpages  = {11},
  keywords  = {Node.js, JavaScript, Empirical Studies, Code Reuse},
  location  = {Paderborn, Germany},
  series    = {ESEC/FSE 2017}
}

@inproceedings{software-wcosystem,
  author    = {Santos, Rodrigo Pereira dos},
  title     = {ReuseSEEM: an approach to support the definition, modeling, and analysis of software ecosystems},
  year      = {2014},
  isbn      = {9781450327688},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/2591062.2591094},
  doi       = {10.1145/2591062.2591094},
  abstract  = {Software Engineering (SE) community has discussed economic and social issues as a challenge for the next years. Companies and organizations have directly (or not) opened up their software platforms and assets to others, including partners and 3rd party developers, creating software ecosystems (SECOs). This scenario changes the traditional software industry because it requires mature research in SE dealing with an environment where business models and socio-technical networks can impact systems engineering and management, and reuse approaches. However, one strong inhibitor is the complexity in defining and modeling SECO elements to improve their comprehension and analysis. The main reason is the fact that this topic is emerging and no common sense on its concepts and relations exists yet. Thus, it is difficult to understand its real impacts in the SE industry. In this context, we propose an approach to support the definition, modeling and analysis of SECOs by exploring Software Reuse concepts in techniques in this area and treating nontechnical aspects in SE.},
  booktitle = {Companion Proceedings of the 36th International Conference on Software Engineering},
  pages     = {650–653},
  numpages  = {4},
  keywords  = {Conceptual Map, Domain, Software Ecosystems, Software Reuse},
  location  = {Hyderabad, India},
  series    = {ICSE Companion 2014}
}

@article{static-analysis,
  author     = {Haas, Roman and Niedermayr, Rainer and Roehm, Tobias and Apel, Sven},
  title      = {Is Static Analysis Able to Identify Unnecessary Source Code?},
  year       = {2020},
  issue_date = {January 2020},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {29},
  number     = {1},
  issn       = {1049-331X},
  url        = {https://doi.org/10.1145/3368267},
  doi        = {10.1145/3368267},
  abstract   = {Grown software systems often contain code that is not necessary anymore. Such unnecessary code wastes resources during development and maintenance, for example, when preparing code for migration or certification. Running a profiler may reveal code that is not used in production, but it is often time-consuming to obtain representative data in this way.We investigate to what extent a static analysis approach, which is based on code stability and code centrality, is able to identify unnecessary code and whether its recommendations are relevant in practice. To study the feasibility and usefulness of our approach, we conducted a study involving 14 open-source and closed-source software systems. As there is no perfect oracle for unnecessary code, we compared recommendations for unnecessary code with historical cleanups, runtime usage data, and feedback from 25 developers of five software projects. Our study shows that recommendations generated from stability and centrality information point to unnecessary code that cannot be identified by dead code detectors. Developers confirmed that 34\% of recommendations were indeed unnecessary and deleted 20\% of the recommendations shortly after our interviews. Overall, our results suggest that static analysis can provide quick feedback on unnecessary code and is useful in practice.},
  journal    = {ACM Trans. Softw. Eng. Methodol.},
  month      = jan,
  articleno  = {6},
  numpages   = {23},
  keywords   = {Unnecessary code, code centrality, code stability}
}

@inproceedings{study-of-test-deletion,
  author    = { Bhatta, Suraj and Kendemah, Frank and Jha, Ajay Kumar },
  booktitle = { 2025 IEEE/ACM 22nd International Conference on Mining Software Repositories (MSR) },
  title     = {{ Understanding Test Deletion in Java Applications }},
  year      = {2025},
  volume    = {},
  issn      = {},
  pages     = {408-420},
  abstract  = { Obsolete and redundant tests increase regression testing costs. Therefore, developers should remove them from test suites; however, identifying these tests is non-trivial. Automated techniques for identifying obsolete and redundant tests could help developers reduce regression testing costs. Nonetheless, we have limited empirical evidence of how and why developers delete tests. Therefore, in this work, we first create DelTest, a dataset of 24,431 manually confirmed deleted tests, by analyzing 449,592 commits from seven open-source Java projects. We then perform an empirical study on DelTest to understand test deletion. Our findings show that test deletion frequency and the number of deleted tests vary significantly across projects, suggesting that test deletion is more likely driven by project-specific needs than the broader development cycle. Developers delete only one or two tests in most commits, suggesting test deletion is mostly small and incremental. In DelTest, 83.2% of tests are deleted along with the corresponding test classes, while $16.8 \%$ are deleted individually. We find that $91.4 \%$ of deleted tests in six projects are obsolete tests (i.e., production code is deleted), $7 \%$ are redundant tests (i.e., passing tests), and $1.6 \%$ are failing tests. The deletion of $20 \%$ of redundant tests reduces code coverage or mutation scores. We also evaluate test suite reduction (TSR) approaches on DelTEST and find that a TSR approach identifies up to 54% of the redundant tests. Our findings can help improve automated techniques for identifying obsolete and redundant tests. },
  keywords  = {Java;Codes;Costs;Production;Software;Maintenance;Data mining;Testing;Software development management},
  doi       = {10.1109/MSR66628.2025.00071},
  url       = {https://doi.ieeecomputersociety.org/10.1109/MSR66628.2025.00071},
  publisher = {IEEE Computer Society},
  address   = {Los Alamitos, CA, USA},
  month     = apr
}

@article{Vzquez2019SlimmingJA,
  title   = {Slimming javascript applications: An approach for removing unused functions from javascript libraries},
  author  = {Hern{\'a}n Ceferino V{\'a}zquez and Alexandre Bergel and Santiago A. Vidal and Jorge Andr{\'e}s D{\'i}az Pace and Claudia A. Marcos},
  journal = {Inf. Softw. Technol.},
  year    = {2019},
  volume  = {107},
  pages   = {18-29},
  url     = {https://api.semanticscholar.org/CorpusID:59605111}
}

@inproceedings{why-deprecated,
  author    = {Sawant, Anand Ashok and Huang, Guangzhe and Vilen, Gabriel and Stojkovski, Stefan and Bacchelli, Alberto},
  booktitle = {2018 IEEE International Conference on Software Maintenance and Evolution (ICSME)},
  title     = {Why are Features Deprecated? An Investigation Into the Motivation Behind Deprecation},
  year      = {2018},
  volume    = {},
  number    = {},
  pages     = {13-24},
  keywords  = {Java;Software;Documentation;Tools;History;Libraries;Taxonomy;API;documentation;deprecation},
  doi       = {10.1109/ICSME.2018.00011}
}

\documentclass[submit,techrep,noauthor]{ipsj}

% パッケージ読み込み
\usepackage[dvipdfmx]{graphicx}
\usepackage{latexsym}
\usepackage{url}
\usepackage{xcolor}
\usepackage{listings}
\usepackage{amsmath,amssymb}
\usepackage{subcaption}
\usepackage{tabularx}
\usepackage{stfloats}
\usepackage{booktabs}
\usepackage{threeparttable}
\usepackage{caption}
\usepackage{ascmac}


% カウンタ定義
\newcounter{patternID}

% コード例用の色定義
\definecolor{lightred}{RGB}{255,230,230}
\definecolor{lightgreen}{RGB}{230,255,230}

% listings設定
\lstset{
  basicstyle=\small\ttfamily,
  abovecaptionskip=0pt,
  captionpos=b,
  frame=tb,
  framexleftmargin=2em,
  numbers=left,
  numberstyle={\scriptsize},
  xleftmargin=\parindent,
  escapechar=|
}

% ListingのキャプションがFigureになる問題の修正
\makeatletter
\let\MYcaption\@makecaption
\let\@makecaption\MYcaption
\makeatother

% レビュー用コマンド
\newcommand{\todo}[1]{\colorbox{yellow}{{\bf TODO}:}{\color{red} {\textbf{[#1]}}}}
\newcommand{\memo}[1]{\colorbox{magenta!30}{{\bf MEMO}:}{\color{red!50} {\textbf{[#1]}}}}
\newcommand{\ihara}[1]{\colorbox{green}{{\bf IHARA}:}{\color{blue} {\textbf{[#1]}}}}
\newcommand{\iida}[1]{\colorbox{cyan}{{\bf Iida}:}{\color{red} {\textbf{[#1]}}}}

% 下線コマンド
\def\Underline{\setbox0\hbox\bgroup\let\\\endUnderline}
\def\endUnderline{\vphantom{y}\egroup\smash{\underline{\box0}}\\}
\def\|{\verb|}

\newcommand{\newblock}{\hskip .11em plus .33em minus .07em}

\begin{document}

\title{ソフトウェア再構成における\\
  メソッド削除の判断指標の検討
}

\affiliate{WU}{和歌山大学\\
Wakayama University, 930 Sakaedani, Wakayama 640--8510, Japan}

\author{吉田 将衛}{Yoshida Shoei}{WU}[s276296@wakayama-u.ac.jp]
\author{伊原 彰紀}{Ihara Akinori}{WU}[ihara@wakayama-u.ac.jp]
\author{飯田 智輝}{Iida Tomoki}{WU}[s266016@wakayama-u.ac.jp]

\begin{abstract}
  % \todo{デブロートという単語をどこかに入れる}
  ライブラリは，機能追加や削除を繰り返しながら進化を続けている．その進化の過程でソフトウェアの規模が拡大し，不要なコードが蓄積する．この問題に対処するため，開発者はソフトウェア再構成の一環としてメソッドの削除を行うことがある．メソッドの削除には，機能としてのサポート終了に伴うものだけでなく，リファクタリングにおける機能統合の結果として行われる場合もある．機能統合によるメソッド削除の場合，統合直後に削除が行われるとは限らず，一定期間にわたり，削除予定のメソッドと統合先のメソッドに類似するソースコードが共存すると考えられる．そこで本研究では，ソフトウェアのメソッドが削除に至るまでの過程を追跡し，類似するソースコードを有する他のメソッドの有無，およびそれらメソッドとの類似度の推移を調査する．ケーススタディを通して，開発者がメソッドの削除判断に関する特徴を明らかにする．
%  しかし，削除するメソッドを客観的に判断することは容易ではなく，最終的に開発者の経験に依存せざるを得ない．本研究では，メソッド間のクローン類似度に着目し，類似度がメソッド削除の判断指標として機能するかを検証する．具体的には，クローンの有無および類似度の高低と削除率の関係，ならびにメソッドが削除・統合に至る過程でのクローン類似度の推移を分析する．
  % ケーススタディとして，PythonライブラリPandasにおける削除されたメソッド7,636件を対象に分析した結果，クローンを持たないメソッドの削除率がクローンを持つメソッドより高いこと，メソッド統合前にはクローン類似度が段階的に上昇する一方，削除前にはそのような変化が見られないことを明らかにした．
\end{abstract}

\maketitle

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{はじめに}
\label{sec:background}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% 現代のソフトウェア開発はソフトウェア部品の組み合わせで行われる\cite{liblary-reuse}．ソフトウェア部品は再利用可能な形でまとめられ，ライブラリと呼ばれる．ライブラリの利用によって，ソフトウェア開発者はソフトウェアの開発工程を大幅に削減することができる\cite{reduce-productivity}．ライブラリ開発者は，さらに上流のライブラリを使用することもあり，ソフトウェアエコシステム\cite{software-wcosystem}を形成する\iida{ライブラリもライブラリを使って制作しているよといいたい？依存関係の波及とかの話いる？削除時の影響の話があるなら書いてもいいと思う}．

多くのソフトウェア開発は，ソフトウェア部品の組み合わせで行われる\cite{liblary-reuse}．特に，特定の機能を再利用可能な形でまとめられたライブラリの利用によってソフトウェアの開発工程を大幅に削減している\cite{reduce-productivity}．
% \memo{ソフトウェアの規模が大きくなる→課題→（従来研究）→本研究での目的}
したがって，ライブラリも多くのソフトウェアと同様に，ライブラリの機能性を向上するための進化を続けている．ただし，その進化の過程で，「ライブラリが外部へ公開しているAPIの名称変更」や「引数の変更」など，既存機能の変更や削除によって後方互換性を損失することがある\cite{detect-backward-compatibility}\cite{Brito2018WhyAH}．
% ため，破壊的変更を引き起こす可能性がある．「ライブラリが外部へ公開しているAPIの名称変更」や「引数の変更」など，様々な要因によって，破壊的変更が引き起こされる\todo{引用}\cite{detect-backward-compatibility}．
その中でも特に，ライブラリAPIの削除はクライアントソフトウェア（以降，クライアント）に甚大な影響を及ぼす．削除によって当該機能を使用するクライアントは同一の機能を継続して運用するために，代替APIへ切り替え，自身で実装，機能廃止などの選択が迫られる\cite{client-action-on-deprecation}．その一方で，ライブラリにとっては，ライブラリの再利用性，軽量化のために効果的な方法であるため，ライブラリ開発者は，クライアントへの影響範囲も危惧しつつ，不要なソースコードを削除する方法を検討している\cite{Vzquez2019SlimmingJA}．

% APIの削除という大きな変更に関しては，急に行うと，ソフトウェアエコシステム全体に負荷がかかる．したがって，多くのライブラリでは，セマンティックバージョニング\footnote{\url{https://semver.org}}という戦略を採用している．セマンティックバージョニングに従っているライブラリは一般的にメジャーバージョンのリリース時のみで破壊的変更を加える．この仕組みによって，クライアントはメジャーバージョンのアップデート時には，破壊的変更の対策を取ることができる．また，APIの削除は急に行われるわけではなく，削除よりも一定期間前から非推奨という警告を出し，クライアントが十分に対策を行える猶予を作った上で，削除を行うという仕組みが備わっている\iida{引用}．

% \iida{本題のここまでが遠い，上の内容は一部2章に持って行ってもいいのでは？また下のデッドコードも2章で軽く触れて結果で再登場くらいで良さそう}
% 多くのソフトウェアには，不要と考えられるソースコードが含まれる\todo{引用}．しかし，開発者が膨大なソースコードの中から不要コードを見つけることができても，それを削除することは難しい．なぜなら不要コードには，様々な種類があるからである．そこで、従来研究では、不要なソースコードを検出する手法がいくつか提案されている\todo{引用}．

従来研究では，デッドコード，未使用変数/関数，到達不能コードなどの不要なソースコード（以降，不要コード）を検出する手法が提案されている\cite{detect-dead-code}．しかし，多くのソフトウェアには不要コードが含まれているにもかかわらず，削除されるのは一部に限られる．
たとえば，リファクタリングにおける機能統合の結果として行われる場合であっても，統合直後に削除されるとは限らず，一定期間にわたり，削除予定のメソッドと統合先のメソッドに類似するソースコードが共存する．
大規模ソフトウェアから依存関係を取り除き，コンポーネントを削除する手法としてChuangら\cite{remove-dependency}はコールグラフ生成ツールを用いて，未使用の依存関係を検出し，他のコンポーネントとの論理的関係に基づく意思決定図を生成する手法を提案している．
しかし，削除の意思決定は，最終的に経験豊富な開発者の判断に委ねられる．


% \todo{従来の研究を軽く入れる}
% 一つ目は，ソースコード中から不要コードを見つけ出す手法である．例えば，プログラム中で到達することができないプログラムはデッドコードと呼ばれ，不要コードと考えられる．デッドコードに関しては，静的解析と動的解析を組み合わせることでおおよそ検出ができる．静的解析では，動的な依存関係を取得することが難しいため，見逃しが発生してしまう．また，動的解析では，エッジケースの入力や年に1回だけ実行されるようなケースを誤って陽性と判断してしまう．このように，デッドコードの検出は，まだまだ課題が残っている．\iida{課題が残るというと吉田研究で取り組むみたいにみえるけど，取り組むの？}

% 二つ目は，ソースコードの変更履歴における削除に着目する方法である．変更履歴において，削除されたコードは不要であると考える．そこで、変更履歴から削除されたコードを収集し，共通する特徴を抽出するという方法である．\iida{抽出で終わり？}しかし，この分析方法では，ノイズが多く混ざってしまう．例えば，リファクタリングの一環として開発者がソースコードを移動した場合，履歴上では，削除と追加という変更として記録されてしまう．したがって，本質的な削除のみを抽出する手法が必要である．
% そこで，RefactoringMiner\cite{Alikhanifard:TOSEM:2024:RefactoringMiner3.0}のようなリファクタリング検出手法によりノイズを減らす工夫がされている．しかし，RefactoringMinerは全ての変更コミットを探索するため，大規模なOSSで適用するには非常に計算コストがかかってしまう．また，リファクタリングが複数コミットに渡る場合，RefactoringMinerでも検出ができなくなる．

そこで本研究では，ソフトウェアのメソッドが削除に至るまでの過程を追跡し，類似するコードを
有する他のメソッドの有無，およびそれらメソッドとの類似度の推移を調査する．具体的には，N-gramに基づくコードクローン検出ツールNIL\cite{NIL}を用い，同一プロジェクト内のメソッド間の類似度を算出し，メソッド間のコードクローンの有無および類似度とメソッドの削除率の関係を分析する．

% \iida{本研究では，〜〜することで、〜〜を実現or要因を見つけるみたいに１文目は書きたい}
% \todo{サクッと一文で言い切ってから，その詳細を書くイメージにする}
% そこで，本研究では，バージョンごとにソフトウェア中に存在するメソッドを全て抽出し，バージョン間で同じシグネチャのメソッドが存在せず，かつ，類似するメソッドが存在しなかった場合に削除されたメソッドであると判定する．バージョンごとのコミットだけに着目することで計算コストを削減し，類似メソッドで削除を判定することで，複数コミットにわたるリファクタリングも検出できるようになる．さらに，一時的に追加されたコードクローンが削除されるケースも発生するため，コードクローンに関連するケースについても検出する．

% ケーススタディとして，PythonライブラリPandasにおけるメソッド43,308件を対象に分析した結果，コードクローンを持たないメソッドの削除率がコードクローンを持つメソッドより高いこと，メソッド統合前にはコードクローン類似度が段階的に上昇する一方，削除前にはそのような変化が見られないことを明らかにした．
% \todo{結果に（オチ）ついては最後に再確認}
ケーススタディとして，PythonライブラリPandasにおけるメソッド43,308件を対象に分析した結果，類似度の高いメソッドほど統合されやすいこと，メソッド統合前にはメソッド間の類似度が段階的に上昇する一方，削除前にはそのような変化が見られないことを明らかにした．以上の結果から，メソッド間の類似度の変化はメソッド統合の予測指標として有効である可能性が示唆された．

以降，本論文では，\ref{sec:deletecode}章で不要コードの背景と関連研究，本研究の研究課題を述べる．\ref{sec:approach}章では，本研究の分析手法を述べ，\ref{sec:case-study}章では，設定したRQにおけるそれぞれの結果を述べる．続く\ref{sec:discussion}章では，本研究の分析による考察を述べ，\ref{sec:threat-to-validity}章では，本研究の妥当性の脅威を述べる．最後に\ref{sec:conclusion}章で本論文をまとめる．

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{不要コード}
\label{sec:deletecode}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{不要コードの種類}
ソフトウェアにとっての不要コードはステークホルダやタイミングによって異なる．クライアントにとって必要な機能であってもライブラリ開発者にとっては運用，保守を継続することを期待しないソースコードもある．例えば，後方互換性を維持するだけのソースコードはライブラリにとっては不要であるが，古いバージョンを使用するクライアントにとっては必要である．また，頻繁に使用されるライブラリのAPIであっても，より効率的な代替APIが登場すれば不要とみなされることがある．

不要コード\cite{static-analysis}\cite{increase-maintainability}の代表例として，デッドコード\cite{static-analysis}\cite{dynamic-analysis}\cite{decrease-readability}と未実行コード\cite{static-analysis}\cite{increase-maintainability}が挙げられる．デッドコードはプログラム中で到達不可能なソースコードであり，未実行コードは観測期間において一度も実行されないソースコードである．ただし，開発者がコードを削除する理由はデッドコードや未実行コードに限らない．
例えば，Pythonのpandas-dev/pandas\footnote{\url{https://github.com/pandas-dev/pandas}}プロジェクトでは，v0.25.0における\texttt{pandas/io/common.py}内のメソッド\texttt{\textunderscore stringify\textunderscore path}が，他のファイルから呼び出されていたにもかかわらず，入出力APIに関するメソッドの非公開化に伴い削除されている\footnote{\url{https://github.com/pandas-dev/pandas/commit/0df8858752}}．
このように，機能として使用されているメソッドであっても，削除されることがある．
本研究では，不要コードの中でも特に，削除されたメソッドに着目し，その削除に関わる定量的特徴を調査する．

\subsection{不要コードが引き起こす問題}
不要コードがコードベースに蓄積することは，保守性と可読性の両面で問題を引き起こす．Ederら\cite{increase-maintainability}は，不要コードが保守コストの増加を引き起こすことを示している．ソースコードの修正時に，未使用のソースコードも同時に修正する必要があるため，無駄なコストが発生する．また，Romanoら\cite{decrease-readability}は，コードベースを理解する際に不要コードを読んでしまうことで，ソースコード理解の有効性や効率が低下することを示している．
したがって，開発者がコード削除を適切に判断するための指標が求められる．

\subsection{関連研究}
\label{sec:related-work}

\subsubsection{不要コードの検出手法}
不要コードの検出手法として，動的解析と静的解析に基づく手法が提案されている．

動的解析に基づく手法として，観測期間において実行されていないソースコードを検出し，自動で削除する手法が提案されている\cite{dynamic-analysis}．この手法では，ソフトウェア中のさまざまなコンポーネントにログを組み込み，実環境で一定期間運用することで実行状況のログを取得する．その後，実行履歴がないコンポーネントを不要コードと判定する．
ただし，エラー処理や復旧用のソースコードは，観測期間において実行されないため不要コードとして誤検出される場合がある．

静的解析に基づく手法として，依存関係に着目し，他との依存関係を持たないデッドコードを検出する手法が提案されている\cite{detect-dead-code}．この手法では，プログラムの制御フローや依存グラフを解析し，到達不可能なコードを特定する．ただし，リフレクションのように動的に依存関係が決まる場合には，依存関係を持たないと誤判定される可能性がある．

これらの手法は，実行状況や依存関係に基づいて不要コードを検出することを目的としている．しかし，機能的には使用されているが開発者の判断で削除対象となるソースコード（例えば，APIの呼び出し方法の変更や機能統合による削除）の検出に向けた議論は十分でない．

\subsubsection{削除コードの実証分析}
削除されたソースコードの特徴を事後的に分析する研究も行われている．Haasら\cite{static-analysis}は，削除されたファイルの安定性と中心性は削除されなかったファイルよりも有意に安定性が高く，中心性が低いことを示した．つまり，長期間，変更が行われず，重要でないファイルは削除されやすいということである．
% 削除ファイルの特徴を分析し，長期間変更がなく，依存の中心にいない特徴を持つファイルは，削除されていないファイルに比べ統計的に有意な差があることを発見した．

Bhattaら\cite{study-of-test-deletion}は，テストコードの削除に着目し，削除されたテストメソッドの83.2\%はテストクラスごと削除され，7.0\%は冗長なテストであったことを明らかにした．さらに，削除されたテストメソッドの91.4\%はプロダクションコードの廃止による副次的な削除であった．

Sawantら\cite{why-deprecated}は，メソッドが非推奨になる理由をコミット履歴や不具合管理システムを基に調査し，分類した．その結果，「新機能の導入に伴う古い機能の非推奨化」，「機能上の欠陥による非推奨化」，「デザインパターンを活用した新バージョンへ移行するために古い実装方法を非推奨化」といった3種類で全体の約72\%を占めていた．

これらの研究は，削除の理由や特徴を事後的に分析している．ソフトウェア再構成として，メソッドを削除するためには，削除候補と判断するための予兆を明らかにすることが期待される．

% \subsubsection{コードクローンと類似度分析}
% コードクローンとは，ソースコード中に存在する同一または類似するコード断片のことである\cite{code-clone-survey}．コードクローンの存在は，保守コストの増加や不整合の原因となるため，クローンの検出やリファクタリング支援に関する研究が活発に行われている．

% 本研究では，コードの類似度を計測するためにNIL\cite{NIL}を用いる．NILは，N-gramの逆インデックスとLCS（最長共通部分列）を組み合わせることで，大規模コードベースにおいても効率的にクローンを検出する手法である．特に，多くの変更が加えられた大差分クローン（large-variance clone）の検出に優れている．

% コードクローンと削除の関係について，類似機能を持つメソッドが同一プロジェクト内に複数存在する場合，開発者が機能の統合・整理のために一方を削除する可能性がある．逆に，クローンを持たない独立したメソッドは，機能自体の廃止によって削除される可能性がある．しかし，クローン類似度がメソッドの削除とどのように関連するかについては，従来研究では調査されていない．


\subsection{研究課題}

\ref{sec:related-work}節で述べたように，従来研究では不要コードの検出手法や削除理由の事後分析が行われてきた．メソッドの削除には，機能としてのサポート終了に伴うものだけでなく，リファクタリングにおける機能統合の結果として行われる場合もある．機能統合によるメソッド削除の場合，統合直後に削除が行われるとは限らず，一定期間にわたり，削除予定のメソッドと統合先のメソッドに類似するソースコードが共存すると考えられる．そこで本研究では，ソフトウェアのメソッドが削除に至るまでの過程を追跡し，類似するソースコードを
有する他のメソッドの有無，およびそれらメソッドとの類似度の推移を調査する．
% しかし，メソッドの定量的なコード特徴量，特にメソッド間の類似度が，削除の判断指標として機能するかは明らかにされていない．

% 本研究では，開発者がメソッドを削除する以前に，他のメソッドとの類似度を定量的に分析する．実行履歴や依存関係に基づく検出ではなく，開発者が削除を行ったメソッドを対象とすることで，プロジェクトレベルの判断を含む多様な削除要因を包括的に捉える．

% 具体的には，類似するコードを含むメソッドが存在するか否か，およびメソッド間の類似度の高低が，メソッドの削除にどのように関係するかを調査する．メソッド間の類似度が単独で削除の判断指標として十分であるか，あるいは他の要因との組合せが必要であるかを含めて検証する．

本研究では次の2つのRQ（Research Question）を設定する．
\begin{itemize}
  % \item RQ1: メソッド間の類似度は，次バージョンにおける削除率とどのように関連しているか
  \item RQ1: 類似するソースコードを持つメソッドと持たないメソッドで削除率に差があるか
  \item RQ2: メソッドが削除・統合される前に，メソッド間の類似度はどのように変化するか
\end{itemize}

機能統合によるメソッド削除であれば，統合先となる類似メソッドが同一プロジェクト内に存在すると考えられる．そこで，まず類似するソースコードの有無と削除率の差を調査する．
次に，機能統合によるメソッド削除であれば，削除に至るまでの過程でメソッド間の類似度が変化する可能性がある．この変化パターンを明らかにすることで，メソッド削除の指標を検討する．

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{アプローチ}
\label{sec:approach}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{概要}
本章では，OSSのバージョン更新に伴い，メソッドを追跡する方法を述べる．バージョン間のメソッドの追跡方法（\ref{sec:detect-delete-method}節），バージョン更新前に類似するメソッドの特定方法（\ref{sec:clone-analysis}節），バージョン更新前に類似するメソッドの有無や類似度の高低が次バージョンでの削除とどのように関わるかを分析する方法（\ref{sec:temporal-tracking}節）を述べる．

% まず，\ref{sec:detect-delete-method}節では，特定バージョンからメソッドを抽出し，隣接バージョン間でメソッドを追跡することで，削除されたメソッドを特定する手法を説明する．
% 次に，\ref{sec:clone-analysis}節では，同一バージョン内のメソッド間の類似度と削除率の関係を分析する手法を述べる．
% 最後に，\ref{sec:temporal-tracking}節では，メソッドが削除・統合に至るまでのメソッド間類似度の時系列変化を追跡する手法を述べる．

\subsection{バージョン間のメソッドの追跡方法}
\label{sec:detect-delete-method}

\noindent\emph{1. 解析対象バージョンの選定}

本研究では，ソースコードの変更履歴がGitHub\footnote{GitHub: \url{https://github.com/}}で公開されているオープンソースソフトウェア (OSS: Open Source Software) を分析対象とする．特に，OSSプロジェクトはGitHubにおいてリポジトリの特定のコミットに名前を付与する機能「タグ」にバージョン番号を付することが多く，本研究ではOSSプロジェクトがセマンティックバージョニング\footnote{\url{https://semver.org/}}の命名規則に従うメジャーおよびマイナーバージョンの変遷に着目するため，パッチバージョンが0（例：v1.2.0）であるバージョンを対象とする．
% \iida{なぜメジャーとマイナーに焦点を当てるのかはここでは書きませんか？}パッチバージョンはリリース間隔が短いため分析対象外とする．ただし，バージョン番号の末尾にプレリリース識別子（rc，dev）を含むバージョンは対象外とする．
% 対象とするOSSのGitHub\footnote{\url{https://github.com/}}リポジトリから，全てのタグを取得する．取得したタグのうち，セマンティックバージョニングの命名規則に従うもののみを抽出する．
% さらに，末尾に「rc」や「dev」といったプレリリース識別子を含むタグは正規表現で除外する．
% また，本研究では，メジャーおよびマイナーバージョンの変遷に着目するため，パッチバージョンが0であるタグ（例：v1.2.0）のみを対象とする．
% パッチバージョン間隔では間隔が狭いため，削除メソッドが含まれない場合があり，十分な間隔を確保するためにパッチバージョンを除外している．
% これらのフィルタリングにより，メジャーおよびマイナーバージョンのタグを時系列順にK個抽出する．

\noindent\emph{2. メソッドのシグネチャとボディの取得}

バージョン間でメソッドの生存，統合，削除を分類するために，取得した各バージョンにおけるソースコードを収集する．本研究ではPython言語で実装されたソースコードを対象とするため，Pythonファイル (.py) のみを収集する．収集したPythonファイルは，抽象構文木 (AST: Abstract Syntax Tree) に変換後，このASTから各メソッドの一意な識別子として「ファイルパス，クラス名.メソッド名，引数，戻り値の型」からなるシグネチャを構成する．同時に，メソッドのボディもASTから取得し，構文要素ごとのトークン列に変換してリストとして保持する．

% \noindent\emph{3. メソッドのN-gram化}

% バージョン $k$ ($1 \le k < K$) における $M$ 個のメソッドの集合を $V_{k} = \{c_1, c_2, \dots, c_M\}$ とする．
% 各メソッド $c_m \in V_k$ に対して N-gram 化を行い，抽出された N-gram の集合を $G(c_m)$ と表す．
% 本研究では，従来研究と同様に 5-gram を採用する\cite{NIL}．

\noindent\emph{3. バージョン間の同一メソッドの追跡と分類}

隣接するバージョン間でメソッドを追跡し，各メソッドの状態を分類する．追跡は次の2段階（\emph{3a}と\emph{3b}）で行う．

\noindent\emph{3a. シグネチャによる同一メソッドの判定}

隣接するバージョン（$V_{k}$と$V_{k+1}$）の間でシグネチャが完全に一致するメソッドを同一と見なし，対象のメソッドがバージョン$V_{k+1}$において削除されていない（本研究では「生存」と呼ぶ．図\ref{fig:classify-method}ケース1を参照）と判断する．
% 共通のIDを割り当てる．

\noindent\emph{3b. 類似度による同一メソッドの判定}

手順3aは，メソッドのボディが同一であっても，メソッド名の変更（リネーム）やメソッドがファイルを移動する場合，シグネチャが変更されるため，シグネチャの変更を受けたメソッドはバージョン間で同一のメソッドと判定できない．
そこで，手順3aでバージョン更新後に同じシグネチャが見つからない場合でも，特に類似するメソッドが存在すれば生存と判定する（図~\ref{fig:classify-method}ケース2を参照）．本研究では，メソッドのボディの類似度にコードクローン検出器を用いる．
% て$c_m \in V_k$と$c_m \in V_{k+1}$間の類似度を計算する．

コードクローンは，ソースコード中に存在する同一または類似するコード断片を指す\cite{code-clone-survey}．コードクローンは，開発を効率化するために，既存のソースコードを複製した後に修正することで作成される．これは，同じ修正を複数箇所に適用するための保守コストの増加や不整合の原因となる欠点がある．従来研究では，コードクローン検出器が多数提案されている\cite{code-clone-review}．
本研究では，バージョン更新前後において類似するボディを有するメソッドを追跡するためにコードクローン検出器NIL\cite{NIL}を用いる．NILは，N-gramの逆インデックスと最長共通部分列(LCS: Longest Common Subsequence)を組み合わせることで，大規模コードベースにおいても効率的にコードクローンを検出する手法である．特に，多くの変更が加えられた大規模な差分クローンの検出に優れている．

% コードクローンと削除の関係について，類似機能を持つメソッドが同一プロジェクト内に複数存在する場合，開発者が機能の統合・整理のために一方を削除する可能性がある．逆に，クローンを持たない独立したメソッドは，機能自体の廃止によって削除される可能性がある．しかし，クローン類似度がメソッドの削除とどのように関連するかについては，従来研究では調査されていない．

コードクローン検出器を用いた，バージョン前後のメソッド間の類似度の算出方法を述べる．
バージョン $k$ ($1 \le k \le K$) における $M$ 個のメソッドの集合を
$V_k = \{c_i \mid 1 \le i \le M\}$とする．
% $V_{k} = \{c_1, c_2, \dots, c_M\}$ とする．
各メソッド $c_i \in V_k$ のボディをトークンに変換しているため，そのトークン列に対して N-gram を生成する．得られた N-gram の集合を$G(c_i)$と表す．
本研究では，従来研究と同様に 5-gram を採用する\cite{NIL}．

バージョン更新後に含まれる$N$個のメソッドの集合$V_{k+1} = \{c_j \mid 1 \le j \le N\}$とするとき，$V_{k}$における各メソッド$c_i$と，$V_{k+1}$における全てのメソッド$c_j$との類似度を算出する．
類似度は次の式で算出する．
\begin{equation}
  \label{eq:sim-verif}
  \text{Sim}_{\text{verif}}(c_i) = \frac{\text{LCS}(c_i, c_j)}{|c_i|}
\end{equation}
%%%%%%%%%%%%%%%%%%%%%%%卒論用
% ここで，具体的なトークン列を用いた計算例をListing~\ref{lis:method_c_i}とListing~\ref{lis:method_c_j}を用いて示す．
% $c_{i}$のトークン列は
% \texttt{[def, get\textunderscore data, self, :, return, self, ., value]}
% となり，$c_{j}$のトークン列は
% \texttt{[def, get\textunderscore cleaned \textunderscore data, self, value, :, return, self, ., \textunderscore data]}
% となる．
% したがって，$|c_{i}| = 8$となり，$|c_{j}| = 9$となる．
% ここで，最長共通部分列は\texttt{[def, self, :, return, self, .]}である．つまり，$\text{LCS}(c_{i}, c_{j}) = 6$である．
% これを，式\ref{eq:sim-verif}に当てはめると，
% \[\text{Sim}_{\text{verif}}(c_i, c_j) = \frac{6}{\min(8, 9)} = 0.75\]となる．この時，これらのメソッドの類似度を0.75と判定する．

% \begin{figure}[t]
%   \centering
%   \begin{minipage}[t]{0.47\linewidth}
%     \begin{lstlisting}[
%       caption=メソッド$c_{i}$,
%       label=lis:method_c_i,
%       captionpos=t,
%       columns=flexible
%     ]
% def get_data(self):
%     return self.value
%     \end{lstlisting}
%   \end{minipage}\hfill
%   \begin{minipage}[t]{0.47\linewidth}
%     \begin{lstlisting}[
%       caption=メソッド$c_{j}$,
%       label=lis:method_c_j,
%       captionpos=t,
%       columns=flexible
%     ]
% def get_cleaned_data(self, value):
%     return self._data
%     \end{lstlisting}
%   \end{minipage}
% \end{figure}
%%%%%%%%%%%%%%%%%%%%%%%卒論用
式(\ref{eq:sim-verif})の$\text{LCS}(c_i, c_j)$は，$c_i$と$c_j$におけるトークン列間で，順序を保ったまま一致する最長共通部分列の長さである．ただし，LCSは計算コストが高いため，従来研究\cite{NIL}と同様に式~\ref{eq:sim-filt}を用いたフィルタリングフェーズを導入し，明らかに異なるメソッド対を事前に除外する．このフィルタリングにより，類似度が0.1未満のメソッド対に対するLCS計算を省略し，全体の実行時間を短縮する．
% \memo{メソッド追跡の場合は$V_k$から見た類似度であるので，分母はminではなく，$|G(c_i)|$になる}
\begin{equation}
  \label{eq:sim-filt}
  \text{Sim}_{\text{filt}}(c_i, c_j) = \frac{|G(c_i) \cap G(c_j)|}{|G(c_i)|}
\end{equation}

%%%%%%%%%%%%%%% 卒論用
% ここで，具体例を用いてフィルタリングフェーズを説明する．Listing~\ref{lis:method_c_i}のメソッド$c_{i}$の5-gram集合は
% \begin{align*}
%   G(c_i) = \bigl\{ \;
%     & \texttt{[def, get\_data, self, :, return]}, \\
%     & \texttt{[get\_data, self, :, return, self]}, \\
%     & \texttt{[self, :, return, self, .]}, \\
%   & \texttt{[:, return, self, ., value]} \; \bigr\}
% \end{align*}
% となり，Listing~\ref{lis:method_c_j}のメソッド$c_{j}$の5-gram集合は
% \begin{align*}
%   G(c_j) = \bigl\{ \;
%     & \texttt{[def, get\_cleaned\_data, self, value, :]}, \\
%     & \texttt{[get\_cleaned\_data, self, value, :, return]}, \\
%     & \texttt{[self, value, :, return, self]}, \\
%     & \texttt{[value, :, return, self, .]}, \\
%   & \texttt{[:, return, self, ., \_data]} \; \bigr\}
% \end{align*}
% となる．
% これらのメソッドで共通する5-gramは存在しないため，\[\text{Sim}_{\text{filt}}(c_i, c_j) = \frac{|G(c_i) \cap G(c_j)|}{\min(|G(c_i)|, |G(c_j)|)} = \frac{0}{\min(4, 5)} = 0\]となる．
% したがって，これらのメソッド対に対してLCS計算は行われない．
%%%%%%%%%%%%%%% 卒論用

% なお，それぞれの記号は以下の意味を持つ．
% \begin{description}
%   \item[$G(c)$:]  メソッド$c$のN-gram集合
%   \item[$|G(c_i) \cap G(c_j)|$:] $c_i$と$c_j$で共通するN-gramの要素数
% \end{description}

本研究では，コードクローン検出器NILにおいてコードクローンと判断する閾値を踏襲し，メソッド間の類似度が0.7以上であるとき，バージョン更新後も機能が生存していると判定する．ただし，バージョン更新前後でシグネチャが異なり，且つバージョン変更前の複数のメソッドが更新後に同一のメソッドと類似している場合は「統合」と呼ぶ（図~\ref{fig:classify-method}ケース3を参照）．

% 類似度の閾値は0.7を使用する．
% $V_{k}$における特定のメソッドに対し，$V_{k+1}$における複数のメソッドが閾値を超えた場合は，最大の類似度をもつメソッドを候補メソッドとする．コードクローン検出器NILにおける類似度計算は，式~\ref{eq:sim-verif}を用いる．\memo{メソッド追跡の場合は$V_k$から見た類似度であるので，分母はminではなく，$|c_i|$になる}
% \begin{equation}
%   \label{eq:sim-verif}
%   \text{Sim}_{\text{verif}}(c_i, c_j) = \frac{\text{LCS}(c_i, c_j)}{\min(|c_i|, |c_j|)}
% \end{equation}
% なお，それぞれの記号は以下の意味を持つ．
% \begin{description}
%   \item[$c_i, c_j$:] 比較対象となる2つのメソッドのトークン列
%   \item[$|c_i|, |c_j|$:] 各トークン列の長さ
%   \item[$\text{LCS}(c_i, c_j)$:] 2つのトークン列間で、順序を保ったまま一致している最長共通部分列（Longest Common Subsequence）の長さ
% \end{description}


\noindent\emph{4. メソッドの分類}

%--------------
\begin{figure}[t]
  \centering
  \includegraphics[width=1.0\linewidth]{./Yoshida_fig/classify-method-all}
  \caption{バージョン間におけるメソッドの生存/統合/削除の分類}
  \label{fig:classify-method}
\end{figure}
%--------------

手順3の追跡に基づき，$V_k$に存在する各メソッドを図~\ref{fig:classify-method}のように3種類に分類する．
\begin{itemize}
  \item \textbf{生存メソッド}
  \begin{itemize}
    \item （ケース1）手順3aにより，$V_{k+1}$にシグネチャが一致するメソッドが存在し，それ以降も分析対象期間中に削除されることはなく生存するメソッド．
    \item （ケース2）手順3aでシグネチャが一致するメソッドが存在しないが，手順3bにより，$V_{k+1}$に類似するメソッドが存在し，それ以降も分析対象期間中に削除されることはなく生存するメソッド．
    \item （ケース3）手順3aでシグネチャが一致するメソッドが存在し，且つ，手順3bにより$V_{k}$における他のメソッドとも類似しており，さらに分析対象期間中に削除されることはなく「統合先メソッド」として生存するメソッド．
  \end{itemize}
  \item \textbf{統合メソッド}
  \begin{itemize}
    \item （ケース4）手順3aでシグネチャが一致するメソッドが存在せず，且つ，手順3bにより$V_{k+1}$においてシグネチャの異なるメソッドと類似する，つまり統合するメソッド．
    \item （ケース5）手順3bにより，$V_{k}$の複数のメソッドが，$V_{k+1}$においてシグネチャが一致するメソッドは存在しないが，単一のメソッドにそれぞれのメソッドの類似部分が存在する場合，複数のメソッドが一つのメソッドに統合されたと判定する．当該メソッドは統合後，分析対象期間中に削除されるメソッド．
  \end{itemize}
  \item \textbf{削除メソッド}
  \begin{itemize}
    \item （ケース6）手順3a，手順3bのいずれでも$V_{k+1}$に対応するメソッドが見つからない場合，削除されるメソッド．
  \end{itemize}
\end{itemize}




\subsection{バージョン更新前に類似するメソッドの特定}
\label{sec:clone-analysis}

%------------------
\begin{figure}[t]
    \centering
    \includegraphics[width=0.9\linewidth]{./Yoshida_fig/feature-sim}
    \caption{バージョン内におけるメソッド間の類似度の算出}
    \label{fig:calc-sim}
\end{figure}
%------------------

本節では，バージョン更新に伴い変更されたメソッドについて，バージョン更新前のメソッドのボディ間の類似度を分析する方法を述べる．コードクローン検出器NILを用いて$V_k$に含まれる全メソッドの組み合わせに対し，総当たりで類似度を算出する．$V_k$で一つ以上の類似相手を持つメソッドを「類似あり」，それ以外を「類似なし」と定義する．なお，あるメソッドが複数の類似メソッドを持つ場合，そのメソッドの類似度$Sim$は，全ての類似するメソッドとの類似度の中央値を代表値として用いる（図~\ref{fig:calc-sim}参照）．

\subsection{分析方法}
\label{sec:temporal-tracking}
% \subsection{メソッドの状態分類と類似度の時系列追跡}

本研究では，分析対象とするバージョン（$V_k$）を対象に，\ref{sec:clone-analysis}節において述べた類似度算出方法によって特定した類似するメソッドが，バージョン更新後（$V_{k+1}$またはそれ以降のバージョン）に削除されるメソッド数とそのメソッドの特徴を分析する．具体的には，各バージョンに含まれる平均生存メソッド数，平均メソッド統合数（率），平均メソッド削除数（率）を計測し，類似するメソッドが存在しない場合と比べて統計的に有意な違いがあるか否かを分析する．また，バージョン更新前にメソッド間の類似度の高い（$90\% \  \leq Sim$）メソッドは，類似度の低い（$70\% \leq Sim < 90\%$）メソッドに比べて削除されるのか否かを分析する．

% バージョン更新前にメソッド間の（類似あり/なし）$\times$（生存/統合/削除）の6群に分け，\todo{XXを明らかにするために}群間の削除数・生存数・統合率・削除率の分布差の違いを分析する．各バージョン遷移における削除率は，削除メソッド数を当該群の総メソッド数で除した値として定義する．また，「類似あり」群に限り，高類似度群（$90\% \  \leq Sim$）と低類似度群（$70\% \leq Sim < 90\%$）に分け，削除率の分布の違いを分析する．

% 本データはバージョン遷移を単位とした対応のある構造を持
ソースコードの変更量は正規分布していないことが知られているため，検定にはノンパラメトリックなデータセットに適用可能なウィルコクソンの符号順位検定を用いる．同検定は順位に基づく手法であり，分布の非正規性や外れ値に頑健である．効果量としては，順位に基づく効果量（$r_{\mathrm{rb}}$: matched-pairs rank-biserial correlation）を用いる．


%-------------
% \begin{figure}[t]
%   \centering
%   \includegraphics[width=1.0\linewidth]{./Yoshida_fig/sim-change}
%   \caption{最終状態での統合/削除メソッドの分類}
%   \label{fig:classify-group}
% \end{figure}
%-------------




% \todo{図~\ref{fig:boxplot-deletion}の説明に移動予定}
% \color{red}
% 次に，各メソッドの全バージョン遷移にわたる履歴を相対時間で正規化する．メソッドが統合/削除を迎える直前のバージョンを$t = 0$とし，そこから過去方向へ$t = -1, -2, \dots$と遡る．各時点$t$において，当該メソッドの同一バージョン内に存在する類似相手とのメソッド間の類似度（中央値）を記録する．この手法により，異なるバージョンで統合/削除を迎えたメソッド同士でも，「統合/削除されたバージョンの何バージョン前か」という統一的な時間軸でメソッド間の類似度の推移を比較できる．
% \color{black}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{ケーススタディ}
\label{sec:case-study}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{データセット}

\subsubsection{対象プロジェクトの選定}
2026年2月9日現在において，GitHubで公開されているPython言語で開発されたオープンソースソフトウェアの中から，pimentelら\cite{most-popular-python-library}の研究で，importされたライブラリ数で順位付けられた上位10件に含まれる，次の基準に合致するpandasプロジェクトを対象とする．
% \iida{できれば候補がpandasに収束する理由があるといいね}\todo{agree}な選定基準は以下に示す．
\begin{description}
  \item[基準1: 大規模であること]
    統計的に有意な分析を行うためには，十分な数のメソッドが存在する必要がある．
  \item[基準2: ユーザが多数存在すること]
    多くのクライアントに利用されるライブラリでは，メソッドの削除がクライアントへ与える影響を考慮して慎重に判断される．このようなライブラリを対象とすることで，開発者の意図的な判断に基づく削除を分析できる．
  \item[基準3: 開発年数が長期であること]
    RQ2では，メソッドが削除・統合に至るまでのメソッド間の類似度の時系列変化を追跡する．十分な数のバージョン遷移が必要であり，10年以上の長期間にわたって継続的に開発されているプロジェクトが求められる．
  \item[基準4: メジャーリリースが2つ以上存在すること]
    セマンティックバージョニングでは，破壊的変更はメジャーバージョンの変更時に行われるのが一般的である．メジャーバージョンで複数回リリースしていることで，APIの廃止や機能統合に伴うメソッド削除を十分に観察できる．
\end{description}

\subsubsection{分析対象データの概要}

表~\ref{tab:dataset-summary}は，pandasプロジェクトにおいて本研究が対象とするデータセットの統計量を示す．分析対象期間はv0.4.0（2011年9月）からv2.3.0（2025年6月）までの約14年間であり，セマンティックバージョニングに従うメジャーおよびマイナーバージョン（パッチバージョンが0のタグ）に該当する32バージョンを分析対象とする．メソッド数はv0.4.0の1,303件からv2.3.0の21,263件へと約16倍に増加しており，全バージョンを対象に一意に識別されるメソッド数は43,308件である．

%------------------------
\begin{table}[t]
  \centering
  \caption{分析対象データの概要}
  \label{tab:dataset-summary}
  \scalebox{0.86}{
    \begin{tabular}{l|r}
      \toprule
      \multicolumn{1}{c|}{項目} & \multicolumn{1}{c}{値} \\
      \midrule
      分析期間 & 2011年9月から2025年6月（約14年間） \\
      対象バージョン数 & 32 \\
      メジャーバージョン遷移 & 2回（0.x$\to$1.x, 1.x$\to$2.x） \\
      初期メソッド数（v0.4.0） & 1,303 \\
      最終メソッド数（v2.3.0） & 21,263 \\
      一意なメソッド総数 & 43,308 \\
      削除メソッド数 & 9,702 \\
      統合メソッド数 & 12,732 \\
      生存メソッド数 & 20,874 \\
      \bottomrule
    \end{tabular}
  }
\end{table}
%------------------------

\subsection{RQ1: 類似するソースコードを持つメソッドと持たないメ
ソッドで削除率に差があるか}

% \subsubsection{概要}
ソフトウェア再構成の一環として行われるメソッドの削除には，機能としてのサポート終了に伴うものだけでなく，リファクタリングにおける機能統合の結果として行われる場合もある．RQ1では，
%ソフトウェアの規模拡大を抑制する手段の一つに，類似するコードを持つメソッドの統合/削除がある．一方で，独自の機能を持つメソッドも機能自体の廃止に伴い，削除される可能性がある．本節では，
同一のバージョン内で類似するソースコードを有するメソッドが存在する場合，存在しない場合に比べてどの程度削除されるか否かを分析する．
% メソッド間の類似度という静的な特徴が，これら異なる要因による削除とどのように関連しているかを調査する．


表\ref{tab:test-clone}は，3.4項にも述べている通り，各バージョンに含まれるメソッドを対象に，ソースコードが類似するメソッドの存在有無（表中の類似メソッド有り，類似メソッド無し），将来的に生存するメソッド数，統合されるメソッド数（率），削除されるメソッド数（率）を示す．さらに，類似度の高さによる違いも示す．

% 類似するソースコードを有するメソッドが存在する場合を「類似あり」，「類似あり」「低類似」「高類似」に分類し，それぞれの削除率の傾向を比較分析する．

% \subsubsection{結果}

%--------------------
\begin{table*}[ht]
  \centering
  \caption{ソースコードが類似するメソッドの存在有無による生存/統合/削除メソッド数（率）の違い}
  % \scalebox{0.95}{
  \begin{tabular}{l|rrcc|rrcc}
    \toprule
    & 類似メソッド無し & 類似メソッド有り & p値 & $r_{\mathrm{rb}}$ & 低類似 & 高類似 & p値 & $r_{\mathrm{rb}}$ \\
    \midrule
    平均生存メソッド数 & 5,387 & 3,832 & 0.00 & 1.00  & 3,291 & 540   & 0.00 & 1.00  \\
    平均統合メソッド数 & 50    & 412   & 0.00 & -1.00 & 141   & 270   & 0.00 & -0.95 \\
    平均削除メソッド数 & 180   & 132   & 0.00 & 0.90  & 101   & 30    & 0.00 & 1.00  \\
    \midrule
    平均統合メソッド率 & 0.008 & 0.110  & 0.00 & -1.00 & 0.044 & 0.320  & 0.00 & -1.00  \\
    平均削除メソッド率 & 0.037 & 0.031 & 0.15 & 0.30  & 0.032 & 0.037 & 0.03 & -0.44 \\
    \bottomrule
  \end{tabular}
  % }
  \label{tab:test-clone}
\end{table*}
%--------------------


% 表~\ref{tab:test-clone}は，隣接バージョン遷移におけるメソッドの平均統合率・平均削除率を種類別に算出し，ウィルコクソンの符号順位検定で差を検定した結果を示す．

バージョン内に類似メソッドを有するメソッドは平均4,240件，類似メソッドが存在しないメソッドは平均5,755件であった．バージョン内に類似メソッドを有するメソッド（類似メソッド有り）の平均統合メソッド率（0.110）は，類似メソッドが存在しないメソッドの平均統合メソッド率（0.008）より統計的に有意な差があり（$p < 0.05$），大きな効果量を持つ（$r_{\mathrm{rb}} = -1.00$）．
一方，類似有りメソッドの平均削除メソッド率（0.031）と類似無しメソッドの平均削除メソッド率（0.037）は統計的に有意な差は見られなかった（$p > 0.05$）．
% ，中程度の効果量を持つ（$r_{\mathrm{rb}} = 0.30$）．

さらに，高類似度のメソッドの平均統合メソッド率（0.320）は低類似のメソッドの平均統合メソッド率（0.044）より統計的に有意な差があり（$p < 0.05$），大きな効果量を持つ（$r_{\mathrm{rb}} = -1.00$）．
一方，高類似のメソッドの平均削除メソッド率（0.037）も低類似のメソッドの平均削除メソッド率（0.032）より統計的に有意な差があり（$p < 0.05$），中程度の効果量を持つ（$r_{\mathrm{rb}} = -0.44$）．

\begin{screen}
RQ1の回答：バージョン内に類似メソッドを有するメソッドは，類似メソッドが存在しないメソッドに比べて統合されることが多く，それは類似度が高いほど統合されている．この結果については第\ref{sec:discussion}章で考察する．
\end{screen}


\subsection{RQ2: メソッドが削除・統合される前に，メソッド間の類似度はどのように変化するか}


RQ1では，メソッド間の類似度の高さが次のバージョンでの削除に関係することを示した．本節では，分析対象期間においてメソッドが削除，または統合されるまでに，他のメソッドとの類似度の推移を分析する．

% メソッドのいずれの結末を迎えるかによってメソッドを分類し，結末を迎えるまでのメソッド間の類似度の推移を調査する．具体的には，\ref{sec:temporal-tracking}節の手法を用い，3種類（統合先メソッド・統合元メソッド・削除メソッド）のメソッドが持つメソッド間の類似度変化を相対時間軸で可視化し，比較する．

\subsubsection{結果}


\begin{figure*}[t]
  \centering

  \begin{subfigure}[t]{0.48\textwidth}
    \centering
    \includegraphics[width=\linewidth]{./Yoshida_fig/deletion_survival_boxplot_deletion}
    \caption{類似度分布（統合元メソッド / 削除メソッド）}
    \label{fig:boxplot-deletion}
  \end{subfigure}
  \hfill
  \begin{subfigure}[t]{0.48\textwidth}
    \centering
    \includegraphics[width=\linewidth]{./Yoshida_fig/deletion_survival_boxplot_absorber}
    \caption{類似度分布（統合先メソッド）}
    \label{fig:boxplot-absorber}
  \end{subfigure}

  \vspace{1em}

  \begin{subfigure}[t]{0.48\textwidth}
    \centering
    \includegraphics[width=\linewidth]{./Yoshida_fig/deletion_survival_areaplot_deletion}
    \caption{メソッド数推移（統合元メソッド / 削除メソッド）}
    \label{fig:areaplot-deletion}
  \end{subfigure}
  \hfill
  \begin{subfigure}[t]{0.48\textwidth}
    \centering
    \includegraphics[width=\linewidth]{./Yoshida_fig/deletion_survival_areaplot_absorber}
    \caption{メソッド数推移（統合先メソッド）}
    \label{fig:areaplot-absorber}
  \end{subfigure}

  \caption{相対時間に対するメソッド類似度分布およびメソッド数の推移}
  \label{fig:deletion-survival-all}
\end{figure*}

\noindent\textbf{メソッド間の類似度の推移}

図~\ref{fig:boxplot-deletion}はメソッドが統合あるいは削除されるまでの類似度（中央値）の推移を示す．横軸は相対時間，縦軸は類似相手とのメソッド間の類似度の中央値を示す．橙色は統合元メソッドを示し，赤色は削除メソッドを示す．各メソッドの削除，または統合される一つ前のバージョンを$t = 0$とし，そこから過去方向へ$t = -1, -2, \dots$と遡る．各時点$t$において，当該メソッドの同一バージョン内に存在する類似相手とのメソッド間の類似度（中央値）を計測した結果を示す．

削除メソッドのメソッド間の類似度の中央値は，$t = -24$から$t = 0$まで約75\%から85\%の範囲で安定して推移しており，削除に向けた明確な変化が観察されなかった．
統合元メソッドのメソッド間の類似度の中央値は，$t = -2$付近では約83\%から85\%であるが，$t = 0$に近づくにつれて上昇し，$t = 0$では100\%に達した．

図~\ref{fig:boxplot-absorber}に示すように，統合先メソッドのメソッド間の類似度の中央値は，統合前（$t = -16$から$t = 0$）では80\%から90\%であるのに対し，統合後（$t = 1$以降）では80\%未満に低下した．したがって，メソッドの削除が起こる前段階で，統合されるメソッドはメソッド間の類似度（中央値）が上昇し，統合先メソッドはメソッド間の類似度（中央値）が減少する．

\noindent\textbf{メソッド数の推移}

図~\ref{fig:areaplot-deletion}の統合元メソッドの数の推移を示す．横軸は相対時間，縦軸はメソッドの数を示す．橙色は統合元メソッド，薄橙色は統合元メソッド（類似度なし），赤色は削除メソッド，薄赤色は削除メソッド（類似度なし）を示す．
$t = 0$の時点では，類似メソッドを持つ統合メソッドが11,232件存在している．一方，$t = -1$の時点では，類似メソッドを持つメソッドが3,663件存在していた．
つまり，7,569件（$11,232 - 3,663$）のメソッドは$t = -1$と$t = 0$の間で出現し，それらのメソッドが統合されたことがわかる．
さらに，$t = -1$の時点では，類似するメソッドを持たない統合元メソッドは1,334件であり，$t = 0$の時点では，類似するメソッドを持たない統合元メソッドは1,500件であった．
類似するメソッドを持たない統合元メソッドの増加が僅か166（$1,500 - 1,334$）件であることを考えると，$t = -1$と$t = 0$の間で出現したメソッドの多くは，類似度が70\%を超える状態で追加されたメソッドであるということがわかる．

% さらに，新規追加メソッドの59.7\%はメソッド間の類似度が100\%であった．
% また，これらのメソッド名には\texttt{f}，\texttt{wrapper}，\texttt{inner}が多く，49.5\%はテストファイルに含まれていた．

また，図~\ref{fig:areaplot-absorber}に示すように，$t = 0$の時点で775件のメソッドが統合先となったが，次のバージョンでは半数以下の362件に減少した．

\begin{screen}
RQ2の回答：統合元メソッドでは統合前にメソッド間の類似度の上昇が観察された．一方，削除前にはメソッド間の類似度の変化は観察されなかった．
\end{screen}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{考察}
\label{sec:discussion}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\ref{sec:case-study}章のRQの結果を踏まえ，ソフトウェア再構成の観点からメソッドの削除指標について考察する．

%%%%%%%%%%%%%%%%%%%%%%%%%卒論
% \subsection{メソッド削除における2つのパターン}

% RQ1では，類似するコードの有無は削除率に統計的な差がないが中程度の効果量を持つことが示された．この結果について，類似するコードの有無が機能に対する需要に関係している可能性を議論する．

% 同一プロジェクト内に類似するコードを持つメソッドが複数存在することは，その類似するコードが複数の文脈で必要とされていることを意味する．すなわち，類似するコードを持つメソッドは，プロジェクト内で繰り返し利用される実装パターンを表しており，そのパターンに対する需要が存在する限り削除されにくい．

% 一方，類似するコードを持たないメソッドは，特定の用途に限定された機能である可能性が高い．例えば，後方互換性を維持するためのラッパーメソッドや，一時的なテスト補助関数などは，他に類似するメソッドを持たず，その用途が不要になれば削除対象となりうる．

% さらに，類似するコードを持つメソッドの中でも，より高類似（$90\% \leq Sim$）なコードを含むメソッドの削除率が低類似（$70\% \leq Sim < 90\%$）なコードを含むメソッドの削除率を上回っていた点について考察する．類似度が90\%を超えるコードを持つメソッドは，ほぼ同一のコードを含む別メソッドが存在することを意味し，機能の重複を示す指標と解釈できる．一方，70\%から90\%類似するコードを含むメソッドは，共通する基盤を持ちながらも各メソッドが固有の役割を担っている可能性が高く，単純な統合対象にはなりにくい．

% 以上より，メソッドの削除には少なくとも2つの異なるパターンが存在すると考えられる．第一に，類似するコードを持たないメソッドが機能自体の廃止に伴い削除される「\textbf{機能廃止型}」の削除である．第二に，高類似なコードを含むメソッドが重複整理のために一方が削除される「\textbf{冗長性解消型}」の削除である．両者は，いずれも削除率を高める方向に寄与しており，RQ1で観察された非単調なパターン（類似するコードなしが最も高く，次いで高類似なコードあり，低類似なコードありが最も低い）を説明する．
%%%%%%%%%%%%%%%%%%%%%%%%%卒論

%%%%%%%%%%%%%%%%%%%%%%%%%卒論
% \subsection{メソッド統合の予兆としての類似度上昇}
% \label{sec:developer-behavior}

% RQ2の結果は，統合と削除における開発者の行動パターンに質的な違いがあることを示唆している．

% 最終的に削除されたメソッドでは，削除に向けてメソッド間の類似度に大きな変化が観察されなかった．これは，削除がコードレベルの段階的な変化を伴わず，ある時点で突然決定されることを意味する．この行動パターンは，削除がAPIポリシーの見直しやメジャーバージョンのリリース，依存ライブラリのバージョン更新，破壊的変更といったプロジェクトレベルの意思決定に起因することと整合する．

% 一方，統合元メソッドでは，メソッド間の類似度が統合時点に近づくにつれて急激に上昇する傾向が観察された．このような類似度の上昇は，偶然ではなく，開発者がリファクタリングの過程でメソッドを意図的に近づけていくプロセスを反映していると考えられる．すなわち，メソッドの統合は一度の変更で完了するのではなく，計画的に進められる段階的なプロセスであることが示唆される．開発者は，類似するメソッドのロジックを少しずつ共通化し，十分にメソッド間の類似度が高まった段階で最終的な統合を実施するという行動パターンが読み取れる．

% \subsection{統合における2つのパターン}
%%%%%%%%%%%%%%%%%%%%%%%%%%%卒論

統合元メソッド数の推移に基づいて，メソッドの統合には2つのパターンが存在すると考えられる．
一つ目のパターンは，\textbf{一時的複製型}の統合である．新規追加メソッドの約半数は少なくとも類似度100\%を持っているということの中央値は，メソッド間の類似度が100\%であり，具体的には\texttt{f}や\texttt{wrapper}などのメソッド名であった．これらは開発過程で一時的に導入された内部関数やラッパー関数であり，メソッド作成時点で次バージョンでのリネームやファイル移動が計画されていた可能性がある．実際の開発履歴を確認したところ，これらのメソッドは，次のリリース後に削除されていた．このようなメソッドは開発プロセスの過程で暫定的に導入されるものであり，意図的なリファクタリングとは性質が異なる．したがって，ソフトウェア再構成に取り組む開発者は，このような一時的複製型メソッドをメソッド名から削除メソッドの候補として容易に検出できるが，他のメソッドとの類似度を計測することで削除理由も容易に特定することが期待できる．


%%%%%%%%%%%%%%%%%%%%%%%卒論用
% \begin{table}[ht]
%   \centering
%   \caption{一時複製型のメソッド（頻度数順）}
%   \label{tab:method_frequency}
%   \begin{tabular}{lr}
%     \hline
%     メソッド名 & 頻度 \\
%     \hline
%     \texttt{f}                           & 236 \\
%     \texttt{wrapper}                     & 208 \\
%     \texttt{inner}                       & 41  \\
%     \texttt{\_check}                     & 38  \\
%     \texttt{TestHDFStore.check}          & 36  \\
%     \texttt{wrapper\_1}                  & 28  \\
%     \texttt{TestTake.\_test\_dtype\_1}   & 28  \\
%     \texttt{wrapper\_2}                  & 27  \\
%     \texttt{TestIntIndex.\_check\_case}  & 25  \\
%     \texttt{CheckIndexing.test\_comp}    & 25  \\
%     \texttt{TestTake.\_test\_dtype\_2}   & 25  \\
%     \texttt{TestExpressions.testit\_1}   & 23  \\
%     \texttt{TestExpressions.testit\_2}   & 23  \\
%     \texttt{TestTSPlot.\_test}           & 22  \\
%     \texttt{\_convert\_listlike}         & 22  \\
%     \hline
%   \end{tabular}
% \end{table}
%%%%%%%%%%%%%%%%%%%%%%%%卒論用
二つ目のパターンは，\textbf{段階的収束型}の統合である．統合元群の$t = 0$において，類似度が急上昇する一時的複製型メソッドに加え，2バージョン以上にわたりメソッド間の類似度が段階的上昇した後に統合される事例を確認した．このような事例は，開発者がメソッドの削除に向けて計画的に同じ機能を有するメソッドを作成したことも考えられるが，開発の過程で類似していったことも考えられる．今後は，段階的収束型メソッドが削除候補として判定するための類似度の推移や閾値の特徴を明らかにする分析に取り組む．
%%%%%%%%%%%%%%%%%%%%%%%%%卒論
% \subsection{段階的収束型メソッドの特徴}

% 段階的収束型の統合元メソッド3,663件の定量的特徴を，一時的複製型の統合元メソッド7,569件と対比して考察する．

% 段階的収束型メソッドは，平均6.3バージョン（中央値5）にわたって追跡されたのちに統合されたメソッドである．統合時点でのメソッド間の類似度の中央値は87\%であり，一時的複製型の100\%と比較して低い．
% また，段階的収束型メソッドの約32\%（1,175/3,663）が統合直前の時点で類似度が100\%であったのに対し，一時的複製型メソッドの約64\%（4,872/7,569）が統合直前の時点での類似度が100\%であった．
% この差は，段階的収束型のメソッドが完全なコピーではなく，コードが徐々に近づいた結果として統合に至ったことを示唆している．

% さらに，メソッドの生存期間（lifetime）と統合時点の類似度の関係を調査した．
% lifetime=10のメソッド（162件）について，$t = -9$の時点での類似度の中央値は84\%であり，そのうち類似度が100\%のメソッドは17件存在する（lifetime=10のメソッド全体のうち，10\%）一方，$t = -2$の時点での類似度の中央値は85\%であり，そのうち類似度が100\%のメソッドが21件存在する（lifetime=10のメソッド全体の12\%）．
% つまり，統合が近づくにつれ，類似度の中央値が上昇し，そのうち類似度が100\%のメソッド数も増加していることがわかる．

% また，lifetime=2のメソッド（748件）の$t = -2$での類似度の中央値は87\%であり，そのうち類似度が100\%のメソッドは238件存在する（lifetime=2のメソッド全体のうち，31\%）．
% lifetimeが長いメソッドほど，低い類似度から段階的に収束していることがわかる．この傾向は，統合予測の観点から重要な示唆を持つ．すなわち，複数バージョンにわたり70\%から90\%の類似度を維持するメソッドペアは，将来の統合候補として早期に検出できる可能性がある．一方，一時的複製型のメソッドは1バージョンで消滅するため，予測対象としての意義は限定的である．したがって，統合の予測指標を構築する際には，段階的収束型に特化した分析が有効であると考えられる．
%%%%%%%%%%%%%%%%%%%%%%%%%%%卒論

%%%%%%%%%%%%%%%%%%%%%%%%%%%ここ微妙(多分間違えてる．間に合わんかったら消す)
% \subsection{誤って統合元メソッドと判定されるケース}

% 本研究の手法では，バージョン間でメソッドを類似度により追跡し，最も類似度の高い候補メソッドが既に他のメソッドと対応付けられている場合に「統合」と判定する．しかし，統合元と判定された11,745件のうち，最終時点で類似するメソッドを持たないメソッドが757件（6.4\%）存在した．これらは統合ではなく，リファクタリングによるコード抽出の結果として誤判定された可能性がある．

% 具体的な誤判定の例として，\texttt{DataFrame.\_\_init\_\_}メソッドが挙げられる．このメソッドは25バージョンにわたりシグネチャマッチで追跡されたpandasの中核メソッドである．v1.2.0からv1.3.0への遷移時に，\texttt{construction.py}内の\texttt{sanitize\_masked\_array}に類似度0.84でマッチされ，統合元と判定された．しかし実際には，\texttt{DataFrame.\_\_init\_\_}はv1.3.0以降も存在し続けている．初期化ロジックの一部が\texttt{sanitize\_masked\_array}として抽出されたことで，類似度マッチにより誤って別メソッドに対応付けられたものと考えられる．

% クローンを持たない統合元757件のうち，648件は2バージョン以上追跡されたメソッドであり，そのlifetimeの中央値は7であった．また，これらの65.6\%がテストファイルに含まれていた．テストファイルではリファクタリングに伴うテストメソッドの再構成が頻繁に行われるため，誤判定が生じやすいと考えられる．ただし，誤判定率は全体の6.4\%であり，RQ1およびRQ2の統計的結論に大きな影響を与えない可能性が高い．
%%%%%%%%%%%%%%%%%%%%%%%%%%%%ここ微妙

%%%%%%%%%%%%%%%%%%卒論
% \subsection{統合先メソッドが統合前にメソッド間の類似度が上昇しない理由}

% 図~\ref{fig:boxplot-absorber}に示すように，統合先メソッドのメソッド間の類似度は統合前には上昇せず，統合後に低下する傾向が観察された．統合先メソッドが統合前に類似度が上昇する傾向がみられない理由を以下で考察する．

% メソッドは生存期間に複数回統合先となる可能性がある．したがって，図~\ref{fig:boxplot-absorber}では，メソッドが最後に統合先となった時点を$t = 0$としているため，過去の統合時点ではメソッド間の類似度が上昇していた可能性がある．
% しかし，メソッドによっては$t = 0$より前の時点での統合のタイミングが様々であるため，過去の統合時点での類似度上昇が埋もれてしまい，図~\ref{fig:boxplot-absorber}では観察されなかったと考えられる．

% また，統合先メソッドの類似度低下については，統合元メソッドのコードが統合先に取り込まれた結果，統合先メソッドの構造が変化し，他の類似メソッドとの類似度が低下したためと考えられる．
%%%%%%%%%%%%%%%%%%卒論


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{妥当性の脅威}
\label{sec:threat-to-validity}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

本章では，本研究における結果の信頼性に影響を及ぼす可能性のある要因を，内的妥当性および外的妥当性の観点から述べる．

\subsection{内的妥当性}

本研究で使用したコードクローンの検出ツールは閾値でコードクローンを判定しているため，閾値によっては，メソッドの分類件数が異なる可能性がある．類似度を判定するための閾値に関しては，従来研究で検証されている0.7を使用することで信頼性を担保した．

% 全てのコミット間隔ではなく，マイナーバージョンの間隔に絞って分析しているため，バージョン間で生成・削除された短命メソッドについては，見逃してしまう．
% しかし，これら短命のメソッドは開発者が一時的に導入するメソッドであるため，ソフトウェアにとって負債となり得ない．
% \iida{少し危ない表現な気がする，ある程度の規模の変更がないと捉えられないみたいなのにしない？パッチリリースで負債が蓄積しないということの従来研究あれば今のままでもいい}
全てのコミット間隔ではなく，マイナーバージョンの間隔に絞って分析しているため，パッチリリース程度の小規模な変更に伴うメソッドの生成・削除については捕捉できない．ただし，本研究はバージョン間の構造的な変化に着目しており，マイナーバージョン単位の分析粒度はこの目的に対して妥当であると考える．

\subsection{外的妥当性}
本研究はPythonのpandasプロジェクトのみを対象としている．データサイエンス分野に特化したライブラリ特有の進化パターンが存在する可能性がある．
しかし，他のドメイン（例：Webフレームワーク，組み込みシステム）や他のプログラミング言語（例：Java, C++）で開発されたプロジェクトにおいても同様の削除パターンやコードクローン整理の傾向が見られるかは不明である．今後はより多様なOSSプロジェクトを対象とした大規模な調査が求められる．

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{おわりに}
\label{sec:conclusion}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

本研究では，ソフトウェア再構成において，メソッド間の類似度が削除の判断指標として機能するかを検証した．Pythonライブラリpandasの43,308件のメソッドを対象に，2つのRQに基づき分析を行った．

% RQ1の分析では，メソッド間の類似度の高低が次バージョンでの削除に関連し，機能自体が廃止される機能廃止型と高類似なコードの重複を解消する冗長解消型といった2つの異なるパターンが存在することを明らかにした．\iida{ここで「機能廃止型」「冗長解消型」「一時的複製型」「段階的収束型」と名前つけてるなら結果とか考察のとこでも言及した方が良さそう}
RQ1の分析では，メソッド間の類似度の高低が次バージョンでのメソッドの削除に関連し，特に，類似度の高いメソッドは統合されやすいことを示した．
RQ2の分析では，メソッドの統合直前にメソッド間の類似度が急上昇する一時的複製型と段階的に類似度が上昇する段階的収束型といった異なる2つのパターンが存在することを明らかにした．
以上の結果から，メソッド間の類似度の段階的な変化はメソッド統合の予測指標として有効であるが，メソッド削除の予測には不十分であり，削除はプロジェクトレベルの意思決定に依存していることが示唆された．

今後の展望として，メソッド間の類似度上昇をもとに，統合対象となるメソッドを予測する指標を作成する．メソッドの統合を事前に予測することで，ソフトウェアの肥大化を防止することに貢献する．
近年では，AIによるソースコード生成の普及に伴い，不要コードがソフトウェアに混入する機会が増加している．したがって，ソフトウェアを再構成し，できる限り小さく保つための判断を支援する定量的な指標の重要性は今後さらに高まると考えられる．

\section*{謝辞}
本研究はJSPS科研費 25K15058の助成を受けたものです。

\bibliographystyle{junsrt}
\bibliography{@IPSJ_SIGSE202603_Yoshida/yoshida_refs}
% \bibliographystyle{ipsjunsrt}
% \bibliography{yoshida_refs}

\end{document}
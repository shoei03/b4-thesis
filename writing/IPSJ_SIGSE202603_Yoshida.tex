
\documentclass[submit,techrep,noauthor]{ipsj}

\usepackage[dvipdfmx]{graphicx}
\usepackage{latexsym}
\usepackage{url}
\usepackage{xcolor}
\usepackage{listings}
\usepackage{amsmath,amssymb}
\usepackage{tabularx}
\usepackage{stfloats}
\usepackage{booktabs}
\usepackage{threeparttable}
\usepackage{caption}

\newcounter{patternID}

% コード例を載せるためのあれこれ
\definecolor{lightred}{RGB}{255,230,230}
\definecolor{lightgreen}{RGB}{230,255,230}

\lstset{
  basicstyle=\small\ttfamily,
  abovecaptionskip=0pt,
  captionpos=b,
  frame=tb,
  framexleftmargin=2em,
  numbers=left,
  numberstyle={\scriptsize},
  xleftmargin=\parindent,
  escapechar=|
}

%ListingのキャプションがFigureになってしまうのをListingに直すコマンド
\usepackage{caption}
\makeatletter
\let\MYcaption\@makecaption
\makeatother
\usepackage{caption}
\makeatletter
\let\@makecaption\MYcaption
\makeatother

\newcommand{\todo}[1]{\colorbox{yellow}{{\bf TODO}:}{\color{red} {\textbf{[#1]}}}}
\newcommand{\memo}[1]{\colorbox{magenta!30}{{\bf MEMO}:}{\color{red!50} {\textbf{[#1]}}}}
\newcommand{\ihara}[1]{\colorbox{green}{{\bf IHARA}:}{\color{blue} {\textbf{[#1]}}}}
\newcommand{\iida}[1]{\colorbox{cyan}{{\bf Iida}:}{\color{red} {\textbf{[#1]}}}}

\def\Underline{\setbox0\hbox\bgroup\let\\\endUnderline}
\def\endUnderline{\vphantom{y}\egroup\smash{\underline{\box0}}\\}
\def\|{\verb|}
%

\def\Underline{\setbox0\hbox\bgroup\let\\\endUnderline}
\def\endUnderline{\vphantom{y}\egroup\smash{\underline{\box0}}\\}
\def\|{\verb|}

\begin{document}

\title{ソフトウェア再構成における\\
  メソッド削除の判断指標の検討
}

\affiliate{WU}{和歌山大学\\
Wakayama University, 930 Sakaedani, Wakayama 640--8510, Japan}

\author{吉田 将衛}{Yoshida Shoei}{WU}[s276296@wakayama-u.ac.jp]
\author{伊原 彰紀}{Ihara Akinori}{WU}[ihara@wakayama-u.ac.jp]
\author{飯田 智輝}{Iida Tomoki}{WU}[s266016@wakayama-u.ac.jp]

\begin{abstract}
  \todo{デブロートという単語をどこかに入れる}
  ライブラリは，機能追加や削除を繰り返しながら進化を続けている．その進化の過程で規模が拡大し，不要なコードが蓄積する．この問題に対処するため，開発者はソフトウェア再構成の一環としてメソッドの削除を行うことがある．
  しかし，削除するメソッドを客観的に判断することは容易ではなく，最終的に開発者の経験に依存せざるを得ない．本研究では，メソッド間のクローン類似度に着目し，類似度がメソッド削除の判断指標として機能するかを検証する．具体的には，クローンの有無および類似度の高低と削除率の関係，ならびにメソッドが削除・統合に至る過程でのクローン類似度の推移を分析する．
  ケーススタディとして，広く利用されるPythonライブラリ1件における削除されたメソッド7,636件を対象に分析した結果，クローンを持たないメソッドの削除率がクローンを持つメソッドより高いこと，メソッド統合前にはクローン類似度が段階的に上昇する一方，削除前にはそのような変化が見られないことを明らかにした．以上より，クローン類似度はメソッド統合の予測に有効であるが，削除の予測には他の指標との組合せが必要であることが示唆される．
\end{abstract}

\maketitle

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{はじめに}
\label{sec:background}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% 現代のソフトウェア開発はソフトウェア部品の組み合わせで行われる\cite{liblary-reuse}．ソフトウェア部品は再利用可能な形でまとめられ，ライブラリと呼ばれる．ライブラリの利用によって，ソフトウェア開発者はソフトウェアの開発工程を大幅に削減することができる\cite{reduce-productivity}．ライブラリ開発者は，さらに上流のライブラリを使用することもあり，ソフトウェアエコシステム\cite{software-wcosystem}を形成する\iida{ライブラリもライブラリを使って制作しているよといいたい？依存関係の波及とかの話いる？削除時の影響の話があるなら書いてもいいと思う}．

多くのソフトウェア開発は，ソフトウェア部品の組み合わせで行われる\cite{liblary-reuse}．特に，特定の機能を再利用可能な形でまとめられたライブラリの利用によってソフトウェアの開発工程を大幅に削減している\cite{reduce-productivity}．
% \memo{ソフトウェアの規模が大きくなる→課題→（従来研究）→本研究での目的}
したがって，ライブラリも多くのソフトウェアと同様に，ライブラリの機能性を向上するための進化を続けている．ただし，その進化の過程で，「ライブラリが外部へ公開しているAPIの名称変更」や「引数の変更」など，既存機能の変更や削除によって後方互換性を損失することがある\cite{detect-backward-compatibility}\cite{Brito2018WhyAH}．
% ため，破壊的変更を引き起こす可能性がある．「ライブラリが外部へ公開しているAPIの名称変更」や「引数の変更」など，様々な要因によって，破壊的変更が引き起こされる\todo{引用}\cite{detect-backward-compatibility}．
その中でも特に，ライブラリAPIの削除はクライアントソフトウェア（以降，クライアント）に甚大な影響を及ぼす．削除によって当該機能を使用するクライアントは同一の機能を継続して運用するために，代替APIへ切り替え，自身で実装，機能廃止などの選択が迫られる\cite{client-action-on-deprecation}．その一方で，ライブラリにとっては，ライブラリの再利用性，軽量化のために効果的な方法であるため，ライブラリ開発者は，クライアントへの影響範囲も危惧しつつ，不要なソースコードを削除する方法を検討している\cite{Vzquez2019SlimmingJA}．

% APIの削除という大きな変更に関しては，急に行うと，ソフトウェアエコシステム全体に負荷がかかる．したがって，多くのライブラリでは，セマンティックバージョニング\footnote{\url{https://semver.org}}という戦略を採用している．セマンティックバージョニングに従っているライブラリは一般的にメジャーバージョンのリリース時のみで破壊的変更を加える．この仕組みによって，クライアントはメジャーバージョンのアップデート時には，破壊的変更の対策を取ることができる．また，APIの削除は急に行われるわけではなく，削除よりも一定期間前から非推奨という警告を出し，クライアントが十分に対策を行える猶予を作った上で，削除を行うという仕組みが備わっている\iida{引用}．

% \iida{本題のここまでが遠い，上の内容は一部2章に持って行ってもいいのでは？また下のデッドコードも2章で軽く触れて結果で再登場くらいで良さそう}
% 多くのソフトウェアには，不要と考えられるソースコードが含まれる\todo{引用}．しかし，開発者が膨大なソースコードの中から不要コードを見つけることができても，それを削除することは難しい．なぜなら不要コードには，様々な種類があるからである．そこで、従来研究では、不要なソースコードを検出する手法がいくつか提案されている\todo{引用}．

従来研究では，デッドコード，未使用変数/関数，到達不能コードなどの不要なソースコード（以降，不要コード）を検出する手法が提案されている\cite{detect-dead-code}．しかし，多くのソフトウェアには不要コードが含まれているにもかかわらず，実際に削除されるのは一部に限られる．不要コードの削除は，機能の必要性やクライアントへの影響など多様な要因に依存しており，最終的には経験豊富な開発者の判断に依存している．\todo{メイン・対抗馬の研究を数行で紹介}

% \todo{従来の研究を軽く入れる}
% 一つ目は，ソースコード中から不要コードを見つけ出す手法である．例えば，プログラム中で到達することができないプログラムはデッドコードと呼ばれ，不要コードと考えられる．デッドコードに関しては，静的解析と動的解析を組み合わせることでおおよそ検出ができる．静的解析では，動的な依存関係を取得することが難しいため，見逃しが発生してしまう．また，動的解析では，エッジケースの入力や年に1回だけ実行されるようなケースを誤って陽性と判断してしまう．このように，デッドコードの検出は，まだまだ課題が残っている．\iida{課題が残るというと吉田研究で取り組むみたいにみえるけど，取り組むの？}

% 二つ目は，ソースコードの変更履歴における削除に着目する方法である．変更履歴において，削除されたコードは不要であると考える．そこで、変更履歴から削除されたコードを収集し，共通する特徴を抽出するという方法である．\iida{抽出で終わり？}しかし，この分析方法では，ノイズが多く混ざってしまう．例えば，リファクタリングの一環として開発者がソースコードを移動した場合，履歴上では，削除と追加という変更として記録されてしまう．したがって，本質的な削除のみを抽出する手法が必要である．
% そこで，RefactoringMiner\cite{Alikhanifard:TOSEM:2024:RefactoringMiner3.0}のようなリファクタリング検出手法によりノイズを減らす工夫がされている．しかし，RefactoringMinerは全ての変更コミットを探索するため，大規模なOSSで適用するには非常に計算コストがかかってしまう．また，リファクタリングが複数コミットに渡る場合，RefactoringMinerでも検出ができなくなる．

本研究では，メソッド間のクローン類似度に着目し，類似度がメソッド削除の判断指標として機能するかを検証する．具体的には，N-gramに基づくクローン検出ツールNIL\cite{NIL}を用い，同一プロジェクト内のメソッド間の類似度を算出し，クローンの有無および類似度の高低とメソッドの削除率の関係，ならびにメソッドが削除・統合に至る過程での類似度の推移を分析する．

% \iida{本研究では，〜〜することで、〜〜を実現or要因を見つけるみたいに１文目は書きたい}
% \todo{サクッと一文で言い切ってから，その詳細を書くイメージにする}
% そこで，本研究では，バージョンごとにソフトウェア中に存在するメソッドを全て抽出し，バージョン間で同じシグネチャのメソッドが存在せず，かつ，類似するメソッドが存在しなかった場合に削除されたメソッドであると判定する．バージョンごとのコミットだけに着目することで計算コストを削減し，類似メソッドで削除を判定することで，複数コミットにわたるリファクタリングも検出できるようになる．さらに，一時的に追加されたコードクローンが削除されるケースも発生するため，コードクローンに関連するケースについても検出する．

以降，本論文では，\ref{sec:deletecode}章で不要コードの背景と関連研究，本研究の研究課題を述べる．\ref{sec:approach}章では，本研究の分析手法を述べ，\ref{sec:case-study}章では，設定したRQにおけるそれぞれの，結果を述べる．続く，\ref{sec:discussion}章では，本研究の分析による考察を述べ，\ref{sec:thread-to-validity}章では，本研究の妥当性の脅威を述べる．最後に\ref{sec:conclusion}章で本論文をまとめる．

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{不要コード}
\label{sec:deletecode}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{不要コードの種類}
ソフトウェアにとっての不要コードはステークホルダやタイミングによって異なる．クライアントにとって必要な機能であってもライブラリ開発者にとっては保持したくないソースコードもある．例えば，後方互換性を維持するだけのソースコードはライブラリにとっては不要であるが，古いバージョンを使用するクライアントにとっては必要である．また，頻繁に使用されるライブラリのAPIであっても，より効率的な代替APIが登場すれば不要とみなされることがある．

不要コード\cite{static-analysis}\cite{increase-maintainability}の代表例として，デッドコード\cite{static-analysis}\cite{dynamic-analysis}\cite{decrease-readability}と未実行コード\cite{static-analysis}\cite{increase-maintainability}が挙げられる．デッドコードはプログラム中で到達不可能なソースコードであり，未実行コードは観測期間において一度も実行されないソースコードである．

しかし，開発者がコードを削除する理由はデッドコードや未実行コードに限らない．例えば，Pythonのpandas-dev/pandas\footnote{\url{https://github.com/pandas-dev/pandas}}プロジェクトでは，v0.25.0における\texttt{pandas/io/common.py}内のメソッド\texttt{\textunderscore stringify\textunderscore path}が，他のファイルから呼び出されていたにもかかわらず，io関連メソッドの非公開化に伴い削除されていた\footnote{\url{https://github.com/pandas-dev/pandas/commit/0df8858752}}．このように，機能的に使用されているメソッドであっても，APIポリシーの変更やモジュールの再構成といったプロジェクトレベルの判断によって削除されることがある．

本研究では，不要コードの中でも特に，開発者の判断に基づいて削除されたメソッドに着目し，その削除に関わる定量的特徴量を調査する．

\subsection{不要コードが引き起こす問題}
不要コードがコードベースに蓄積することは，保守性と可読性の両面で問題を引き起こす．Ederら\cite{increase-maintainability}は，不要コードが保守コストの増加を引き起こすことを示している．ソースコードの修正時に，未使用のソースコードも同時に修正する必要があるため，無駄なコストが発生する．また，Romanoら\cite{decrease-readability}は，コードベースを理解する際に不要コードを読んでしまうことで，ソースコード理解の有効性や効率が低下することを示している．
したがって，開発者がコード削除を適切に判断するための定量的な指標が求められる．

\subsection{関連研究}

\subsubsection{不要コードの検出手法}
不要コードの検出手法として，動的解析と静的解析に基づく手法が提案されている．

動的解析に基づく手法として，観測期間において実行されていないソースコードを検出し，自動で削除する手法が提案されている\cite{dynamic-analysis}．この手法では，ソフトウェア中のさまざまなコンポーネントにログを組み込み，実環境で一定期間運用することで実行状況のログを取得する．その後，実行履歴がないコンポーネントを不要コードと判定する．ただし，エラー処理や復旧用のソースコードのように，観測期間において実行されなくとも必要なコードが不要コードとして誤検出される場合がある．

静的解析に基づく手法として，依存関係に着目し，他との依存関係を持たないデッドコードを検出する手法が提案されている\cite{detect-dead-code}．この手法では，プログラムの制御フローや依存グラフを解析し，到達不可能なコードを特定する．ただし，リフレクションのように動的に依存関係が決まる場合には，依存関係を持たないと誤判定される可能性がある．

これらの手法は，実行状況や依存関係に基づいて不要コードを検出することを目的としている．しかし，機能的には使用されているが開発者の判断で削除対象となるコード（例えば，APIポリシーの変更や機能統合による削除）は，これらの手法では検出できない．

\subsubsection{削除コードの実証分析}
削除されたコードの特徴を事後的に分析する研究も行われている．Haasら\cite{static-analysis}は，削除ファイルの特徴を分析し，「最近変更されておらず，依存の中心にいない特徴を持つファイル」が「生存するファイル」に比べ有意に差があることを発見した．

Bhattaら\cite{study-of-test-deletion}は，テストコードの削除に着目し，削除されたテストメソッドの83.2\%はテストクラスごと削除され，7\%は冗長なテストであったことを明らかにした．さらに，削除されたテストメソッドの91.4\%はプロダクションコードの廃止による副次的な削除であった．

Sawantら\cite{why-deprecated}は，メソッドが非推奨になる理由をコミット履歴やイシュートラッカーを基に調査・分類した．その結果，「新機能の導入」「機能上の欠陥」「デザインパターン」の3種類で全体の約72\%を占めていた．

これらの研究は，削除の理由や特徴を事後的に分析している．しかし，メソッドの定量的なコード特徴量から削除を事前に予測可能かという問いについては未解明である．

\subsubsection{コードクローンと類似度分析}
コードクローンとは，ソースコード中に存在する同一または類似するコード断片のことである\cite{code-clone-survey}．コードクローンの存在は，保守コストの増加や不整合の原因となるため，クローンの検出やリファクタリング支援に関する研究が活発に行われている．

本研究で用いるNIL\cite{NIL}は，N-gramの逆インデックスとLCS（最長共通部分列）を組み合わせることで，大規模コードベースにおいても効率的にクローンを検出する手法である．特に，コピー後に多くの変更が加えられた大差分クローン（large-variance clone）の検出に優れている．

コードクローンと削除の関係について，類似機能を持つメソッドが同一プロジェクト内に複数存在する場合，開発者が機能の統合・整理のために一方を削除する可能性がある．逆に，クローンを持たない独立したメソッドは，機能自体の廃止によって削除される可能性がある．しかし，クローン類似度がメソッドの削除とどのように関連するかについては，従来研究では調査されていない．

\subsection{研究課題}

前節で述べたように，従来研究では不要コードの検出手法や削除理由の事後分析が行われてきた．しかし，メソッドの定量的なコード特徴量，特にクローン類似度が，削除の判断指標として機能するかは明らかにされていない．

本研究では，「開発者が削除した」という確定した事実をGround Truthとし，クローン類似度とメソッド削除の関係を定量的に分析する．実行履歴や依存関係に基づく検出ではなく，開発者が削除を行ったメソッドを対象とすることで，プロジェクトレベルの判断を含む多様な削除要因を包括的に捉える．

具体的には，類似するメソッドを持つか否か，および類似度の高低が，メソッドの削除にどのように関係するかを調査する．クローン類似度が単独で削除の判断指標として十分であるか，あるいは他の要因との組合せが必要であるかを含めて検証する．

以上に基づき，本研究では以下のリサーチクエスチョン（Research Questions）を設定する．
\begin{itemize}
  \item RQ1: メソッド間の類似度は，次バージョンにおける削除率とどのように関連しているか
  \item RQ2: メソッドが削除・統合される前に，メソッド間の類似度はどのように変化するか
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{アプローチ}
\label{sec:approach}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{概要}
本章では，OSSプロジェクトの進化過程において，メソッドの削除を分析するための手法を述べる．
まず，\ref{sec:detect-delete-method}節では，対象プロジェクトの特定バージョンからメソッドを抽出し，隣接バージョン間でメソッドを追跡することで，削除されたメソッドを特定する手法を説明する．
次に，\ref{sec:clone-analysis}節では，同一バージョン内のクローン類似度と削除率の関係を分析する手法を述べる．
最後に，\ref{sec:temporal-tracking}節では，メソッドが削除・統合に至るまでのクローン類似度の時系列変化を追跡する手法を述べる．

\begin{figure}[ht]
  \centering
  \includegraphics[width=1.0\linewidth]{./Yoshida_fig/approach}
  \caption{削除メソッドの特定過程\todo{まだ未完成}}
  \label{fig:placeholder}
\end{figure}

\subsection{削除メソッドの特定方法}
\label{sec:detect-delete-method}

\noindent\emph{1. 解析対象バージョンの選定}

対象とするOSSのGitHub\footnote{\url{https://github.com/}}リポジトリから，全てのタグを取得する．取得したタグのうち，セマンティックバージョニングの命名規則に従うもののみを抽出する．
さらに，末尾に「rc」や「dev」といったプレリリース識別子を含むタグは正規表現で除外する．
また，本研究では，メジャーおよびマイナーバージョンの変遷に着目するため，パッチバージョンが0であるタグ（例：v1.2.0）のみを対象とする．パッチバージョン間隔では削除メソッドが0件となる場合があり，十分な変更量を確保するためにパッチバージョンを除外している．
これらのフィルタリングにより，メジャーおよびマイナーバージョンのタグを時系列順にK個抽出する．
% \iida{一旦K個て書いてる？}説明の都合上，K個って書いてます．

\noindent\emph{2. メソッドのシグネチャとボディの取得}

取得したバージョンへ順次チェックアウトを行い，当該バージョンに含まれる全てのPythonファイル（.py）を対象に抽象構文木（Abstract Syntax Tree; 以降，AST）へパースする．このASTからメソッドのシグネチャを取得し，メソッドの一意な識別子を構成する（「ファイルパス，クラス名.メソッド名，引数，戻り値」という形式）．
同時にメソッドのボディもASTから取得し，トークン列に分割してリストとして保存する．

\noindent\emph{3. メソッドのN-gram化}

バージョン $k$ ($1 \le k < K$) における $M$ 個のメソッドの集合を $V_{k} = \{c_1, c_2, \dots, c_M\}$ とする．
各メソッド $c_m \in V_k$ に対して N-gram 化を行い，抽出された N-gram の集合を $G(c_m)$ と表す．
本研究では，従来研究と同様に 5-gram を採用する\cite{NIL}．

\noindent\emph{4. 同一メソッドの追跡と分類}

隣接するバージョン間でメソッドを追跡し，各メソッドの状態を分類する．追跡は以下の二段階で行う．

\noindent\emph{4a. シグネチャによる同一メソッドの判定}

隣接するバージョン$V_{k}$と$V_{k+1}$の間でシグネチャが完全に一致するメソッドを同一と見なし，共通のIDを割り当てる．

\noindent\emph{4b. 類似度による同一メソッドの判定}

手順4aでは，メソッドの中身やロジックが同一であっても，リネームやファイルの移動を受けたメソッドは同一と判定できない．
そこで，手順4aで対応が見つからなかったメソッドに対し，コードクローン検出器NILを用いてバージョン間の類似度を計算する．
$V_{k}$における各メソッド$c_i$に対し，$V_{k+1}$における全てのメソッド$c_j$との類似度を計測する．
この際，類似度が閾値を超えたメソッドをクローン候補メソッドとする．従来研究と同様に類似度の閾値は0.7を使用する．
$V_{k}$における特定のメソッドに対し，$V_{k+1}$における複数のメソッドが閾値を超えた場合は，最大の類似度をもつメソッドを候補メソッドとする．

NILによる詳細な類似度計算（検証フェーズ）では，以下の式を用いる．
\begin{equation}
  \text{Sim}_{\text{verif}}(c_i, c_j) = \frac{\text{LCS}(c_i, c_j)}{\min(|c_i|, |c_j|)}
\end{equation}
ここで，
\begin{description}
  \item[$c_i, c_j$:] 比較対象となる2つのメソッドのトークン列
  \item[$|c_i|, |c_j|$:] 各トークン列の長さ
  \item[$\text{LCS}(c_i, c_j)$:] 2つのトークン列間で、順序を保ったまま一致している最長共通部分列（Longest Common Subsequence）の長さ
\end{description}

本手法の特徴は，分母に最小値（$\min$）を用いている点にある．
これにより，一方がもう一方を包含している場合に類似度が高く算出される．
例えば，片方のメソッドに大量の新しいコードが追加されて全体の長さが大きく変化した場合でも，元のロジックが保存されていればクローンとして検出可能である．

しかし，LCSによる類似度計算は計算コストが非常に高いため，以下の式を用いたフィルタリングフェーズを導入し，明らかに異なるメソッド対を事前に除外する．
\begin{equation}
  \text{Sim}_{\text{filt}}(c_i, c_j) = \frac{|G(c_i) \cap G(c_j)|}{\min(|G(c_i)|, |G(c_j)|)}
\end{equation}
ここで，$G(c)$はメソッド$c$のN-gram集合を表し，$|G(c_i) \cap G(c_j)|$は$c_i$と$c_j$で共通するN-gramの要素数を表す．
このフィルタリングにより，類似度が0.1未満のメソッド対に対するLCS計算を省略し，全体の実行時間を削減している．

\noindent\textbf{メソッドの分類}

以上の追跡結果に基づき，$V_k$に存在する各メソッドを以下の3つに分類する．
\begin{description}
  \item[生存メソッド: ] 手順4aにより，$V_{k+1}$にシグネチャが一致するメソッドが存在するもの．
  \item[統合メソッド: ] 手順4aでは対応が見つからないが，手順4bにより，$V_{k+1}$にクローン候補メソッドが存在するもの．すなわち，リネーム，ファイル移動，または他のメソッドへの吸収・統合が行われたと判定されるメソッドである．
  \item[削除メソッド: ] 手順4a・4bのいずれでも$V_{k+1}$に対応するメソッドが見つからないもの．
\end{description}
同様に，$V_{k+1}$で初めて出現したIDを持つメソッドを「追加メソッド」とする．

\subsection{クローンの有無・類似度と削除の関係分析}
\label{sec:clone-analysis}

\ref{sec:detect-delete-method}節ではバージョン間の類似度を用いてメソッドの追跡を行ったが，本節では同一バージョン内のメソッド間のクローン関係に着目する．
各バージョン$V_k$に対し，コードクローン検出器NILを用いて同一バージョン内の全メソッド間の類似度を算出する．算出結果に基づき，あるバージョン内で一つ以上のクローン相手を持つメソッドを「クローンあり」，それ以外を「クローンなし」と定義する．ここで，あるメソッドが複数のクローン相手を持つ場合，そのメソッドの代表類似度$Sim$は，全てのクローン相手との類似度の中央値として定義する．

次に，\ref{sec:detect-delete-method}節の手法により，各メソッドを隣接バージョン$V_k$と$V_{k+1}$の間で追跡し，「生存メソッド」または「削除メソッド」にラベル付けする．以上より，メソッドを（クローンあり/なし）$\times$（生存/削除）の4群に分け，バージョンごとの削除数・生存数・削除率の分布差を検定する．ここで，各バージョン遷移における削除率は，削除メソッド数を当該群の総メソッド数で除した値として定義する．

さらに，「クローンあり」群に限り，高類似度群（$90\% \leq Sim$）と低類似度群（$70\% \leq Sim < 90\%$）に分け，削除率の分布が異なるかを検定する．

本データはバージョン遷移を単位とした対応のある構造を持つため，群間差の検定にはノンパラメトリックな対応あり検定であるウィルコクソンの符号付順位検定を用いる．同検定は順位に基づく手法であり，分布の非正規性や外れ値に頑健である．効果量としては，順位に基づく効果量（matched-pairs rank-biserial correlation：$r_{\mathrm{rb}}$）を用いる．

\subsection{メソッドの状態分類と類似度の時系列追跡}
\label{sec:temporal-tracking}

RQ1では，単一のバージョン遷移におけるクローン類似度と削除の関係を静的に分析する．RQ2では，メソッドが削除や統合に至る過程におけるクローン類似度の変化を時系列で追跡する．

\ref{sec:detect-delete-method}節の手順4では，各バージョン遷移においてメソッドを生存・統合・削除の3つに分類した．本節では，各メソッドの最終的な結末に基づき，以下の3群に分類する．

\begin{description}
  \item[生存群（Survived）: ] 追跡対象期間の最終バージョン遷移において，生存メソッドと判定されたメソッド．すなわち，観測期間の最後まで削除されなかったメソッドである．
  \item[統合群（Merged）: ] 最終バージョン遷移において，統合メソッドと判定されたメソッド．すなわち，そのメソッドのコードが他のメソッドに吸収・統合されたと考えられるメソッドである．
  \item[削除群（Deleted）: ] 最終バージョン遷移において，削除メソッドと判定されたメソッド．すなわち，プロジェクトから消滅したメソッドである．
\end{description}

次に，各メソッドの全バージョン遷移にわたる履歴を相対時間で正規化する．メソッドが結末（生存/統合/削除）を迎えたバージョン遷移を$t = 0$とし，そこから過去方向へ$t = -1, -2, \dots$と遡る．各時点$t$において，当該メソッドの同一バージョン内に存在するクローン相手との類似度（中央値）を記録する．この正規化により，異なるバージョンで結末を迎えたメソッド同士でも，「結末の何バージョン前か」という統一的な時間軸で類似度の推移を比較できる．

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{ケーススタディ}
\label{sec:case-study}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{データセット}

\subsubsection{対象プロジェクトの選定}
Python言語で開発されたプロジェクトの中から，以下の5つの基準に基づいて対象プロジェクトを選定した．

\begin{description}
  \item[基準1: 大規模であること．]
    統計的に有意な分析を行うためには，十分な数のメソッドが存在する必要がある．特に，RQ1で用いるウィルコクソンの符号付順位検定では，各バージョン遷移における削除数・生存数が十分に確保される必要があるため，数千以上のメソッドを持つプロジェクトが望ましい．
  \item[基準2: ユーザが多数存在すること．]
    多くのクライアントに利用されるプロジェクトでは，メソッドの削除がクライアントへ与える影響を考慮して慎重に判断される．このようなプロジェクトを対象とすることで，開発者の意図的な判断に基づく削除を分析できる．
  \item[基準3: 開発年数が長期であること．]
    RQ2では，メソッドが削除・統合に至るまでのクローン類似度の時系列変化を追跡する．十分な数のバージョン遷移（10以上）が必要であり，長期間にわたって継続的に開発されているプロジェクトが求められる．
  \item[基準4: メジャーリリースが2つ以上存在すること．]
    セマンティックバージョニングにおいて，破壊的変更はメジャーバージョンの変更時に行われるのが一般的である．メジャーバージョン遷移を複数含むことで，APIの廃止や機能統合に伴うメソッド削除を十分に観測できる．
  \item[基準5: 明確な非推奨ポリシーが存在すること．]
    本研究は開発者の意図的な判断に基づくメソッド削除を対象としているため，非推奨化から削除に至るプロセスが文書化されているプロジェクトが望ましい．非推奨ポリシーが明確であれば，メソッドの削除が計画的に行われていると判断できる．
\end{description}

\subsubsection{分析対象データの概要}

表~\ref{tab:dataset-summary}に，pandasプロジェクトの分析対象データの概要を示す．分析対象期間はv0.4.0（2011年9月）からv2.3.0（2025年6月）までの約14年間であり，セマンティックバージョニングに従うメジャーおよびマイナーバージョン（パッチバージョンが0のタグ）を抽出した結果，32バージョンが対象となった．メソッド数はv0.4.0の1,303件からv2.3.0の21,392件へと約16倍に増加しており，全バージョンにわたって追跡された一意なメソッドは40,264件である．

\begin{table}[ht]
  \centering
  \caption{分析対象データの概要}
  \label{tab:dataset-summary}
  \scalebox{0.9}{
    \begin{tabular}{l|r}
      \toprule
      項目 & 値 \\
      \midrule
      分析期間 & 2011年9月 -- 2025年6月（約14年間） \\
      対象バージョン数 & 32 \\
      メジャーバージョン遷移 & 2回（0.x$\to$1.x, 1.x$\to$2.x） \\
      初期メソッド数（v0.4.0） & 1,303 \\
      最終メソッド数（v2.3.0） & 21,263 \\
      一意なメソッド総数 & 40,264 \\
      削除メソッド数 & 7,636 \\
      統合メソッド数 & 11,723 \\
      生存メソッド数 & 20,905 \\
      \bottomrule
    \end{tabular}
  }
\end{table}

\subsection{RQ1: メソッド間の類似度は，次バージョンにおける削除率とどのように関連しているか}

\subsubsection{概要}
ソフトウェアの規模拡大を抑制する手段の一つに，類似機能を持つメソッドの整理・統合がある．一方で，独自の機能を持つメソッドも機能自体の廃止に伴い，削除される可能性がある．本節では，メソッドが持つ類似度という静的な特徴が，これら異なる要因による削除とどのように関連しているかを調査する．

具体的には，メソッドを「クローンなし」「低類似度」「高類似度」に分類し，それぞれの削除率の傾向を比較分析する．

\subsubsection{結果}

\begin{table*}[ht]
  \centering
  \caption{ウィルコクソンの符号付き順位検定を用いた，メソッドの類似度と削除/生存の関係}
  % \scalebox{1.0}{
  \begin{tabular}{l|rrcc|rrcc}
    \toprule
    & クローンなし & クローンあり & p値 & $r_{\mathrm{rb}}$ & 低類似度 & 高類似度 & p値 & $r_{\mathrm{rb}}$ \\
    \midrule
    平均削除数 & 155 & 92 & $6.52 \times 10^{-9}$ & 0.73 & 69 & 23 & $8.79 \times 10^{-6}$ & 0.80 \\
    平均生存数 & 5,464 & 4,286 & $9.31 \times 10^{-10}$ & 0.77 & 3,475 & 810 & $9.31 \times 10^{-10}$ & 1.10 \\
    平均削除率 & 0.033 & 0.025 & $1.45 \times 10^{-4}$ & 0.48 & 0.024 & 0.029 & $3.38 \times 10^{-2}$ & 0.38 \\
    \bottomrule
  \end{tabular}
  % }
  \label{tab:test-clone}
\end{table*}

表~\ref{tab:test-clone}は，隣接バージョン遷移を単位として，削除数・生存数・削除率の平均を群別に算出し，ウィルコクソンの符号付順位検定で群間差を検定した結果である．

まず，削除率に着目する．クローンなし群の平均削除率（0.033）はクローンあり群（0.025）を有意に上回っており（$p < 0.01$，$r_{\mathrm{rb}} = 0.48$，中程度の効果量），クローンを持たないメソッドの方が削除されやすい傾向が確認された．なお，削除数・生存数の絶対値についても，クローンなし群がクローンあり群を有意に上回っていた（$r_{\mathrm{rb}} = 0.73, 0.77$，大きな効果量）．

さらに，クローンあり群内で高類似度群（$90\% \leq Sim$）と低類似度群（$70\% \leq Sim < 90\%$）を比較すると，高類似度群の平均削除率（0.029）が低類似度群（0.024）を有意に上回っていた（$p < 0.05$，$r_{\mathrm{rb}} = 0.38$，中程度の効果量）．

以上の結果から，クローンを持たないメソッドが最も削除されやすく，クローンを持つメソッドの中では類似度が高いほど削除されやすいという傾向が確認された．この知見の解釈は第\ref{sec:discussion}章で議論する．

\subsection{RQ2: メソッドが削除・統合される前に，メソッド間の類似度はどのように変化するか}

\subsubsection{概要}

RQ1では，ある時点でのクローン類似度の高低が削除に関係することを示した．本節では，メソッドが最終的に削除・統合・生存のいずれの結末を迎えるかによって，その過程におけるクローン類似度の推移に特徴的な差異が存在するかを調査する．具体的には，\ref{sec:temporal-tracking}節の手法を用い，3群（生存群・統合群・削除群）のクローン類似度を相対時間軸で可視化し，比較する．

\subsubsection{結果}

図~\ref{fig:deletion-survival}は，3群（生存群・統合群・削除群）におけるクローン類似度の時系列推移を示す．上段の箱ひげ図は各相対時間におけるクローン類似度の分布を群別に示し，下段は各時点のサンプル数を示す．横軸の相対時間$t = 0$はメソッドが結末を迎えた時点を表し，負の値ほど過去に遡る．

% 分析対象のデータは40,264件の一意なメソッドから構成される．生存群は20,905件（平均類似度79.9\%），削除群は7,636件（平均類似度83.8\%），統合群は11,723件（平均類似度92.5\%）である．

\begin{figure*}[ht]
  \centering
  \includegraphics[width=1.0\linewidth]{./Yoshida_fig/deletion_survival_boxplot}
  \caption{各相対時間でのクローン類似度の分布を箱ひげ図で示す．}
  \label{fig:deletion-survival}
  \includegraphics[width=1.0\linewidth]{./Yoshida_fig/deletion_survival_lineplot}
  \caption{各群のサンプル数．$t = 0$はメソッドが結末を迎えた時点を表す．}
  \label{fig:deletion-survival-sample}
\end{figure*}

\noindent\textbf{知見1: 統合群は結末に近づくにつれクローン類似度が上昇する}

統合群のクローン類似度の中央値は，$t = -10$付近では約83\%から85\%であるが，$t = 0$に近づくにつれて上昇し，$t = 0$では約95\%から100\%に達する．この傾向は，メソッドが他のメソッドに吸収・統合される前に，当該メソッドとクローン相手の間でコードの収束が進んでいることを示唆する．すなわち，開発者がリファクタリングや機能統合を段階的に進める過程で，メソッド間の類似度が徐々に高まり，最終的に統合に至るというパターンが読み取れる．

\noindent\textbf{知見2: 削除群と生存群のクローン類似度は同様の推移を示す}

削除群と生存群のクローン類似度は，いずれも約75\%から85\%の範囲で安定して推移しており，結末に向けた明確な変化傾向は観察されない．この結果は，クローン類似度の水準だけでは，削除されるメソッドと生存するメソッドを区別できないことを意味する．

以上より，RQ2に対する回答として，メソッドの統合前にはクローン類似度の上昇が観察される一方，削除前にはそのような類似度の変化は観察されないことがわかった．このことから，クローン類似度の動的な変化は統合の予測指標として有効であるが，削除の予測指標としては不十分であることが示唆される．

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{考察}
\label{sec:discussion}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{クローン類似度と削除・統合の関係}

RQ1では，クローンを持たないメソッドの方が削除されやすく，クローンを持つメソッドの中でも高類似度群（$90\% \leq Sim$）の方が低類似度群よりも削除されやすいことを示した．一方，RQ2では，削除群と生存群のクローン類似度の時系列推移には顕著な差が見られなかった．

この一見矛盾する結果は以下のように解釈できる．RQ1の結果は，ある時点のスナップショットにおいて高類似度であることが削除と相関していることを示すものであるが，RQ2が示すように，削除群の類似度が時間経過とともに上昇するわけではない．すなわち，削除されるメソッドはもともと高い類似度を持っていた可能性があり，類似度の変化が削除の原因ではなく，類似度の水準が削除の条件の一つであると考えられる．

さらに，削除群と生存群の類似度分布が類似していることから，メソッドの削除は類似度だけでは説明できず，APIポリシーの変更，モジュールの廃止，依存関係の整理など，プロジェクトレベルの意思決定に依存していると推察される．

一方，統合群ではクローン類似度が結末に近づくにつれ上昇する傾向が確認された．この知見は，開発者がリファクタリングを計画的に実施していることを示唆する．すなわち，類似するメソッドを段階的に近づけていき，十分に類似度が高まった段階でメソッドの統合を実行するというパターンである．プロジェクト内でクローン類似度が継続的に上昇しているメソッドを監視することで，将来の統合候補を早期に特定できる可能性がある．

\subsection{\memo{もう一節考察入れたい}}

\todo{}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{妥当性の脅威}
\label{sec:thread-to-validity}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

本章では，本研究における結果の信頼性に影響を及ぼす可能性のある要因を，内的妥当性および外的妥当性の観点から述べる．

\subsection{内的妥当性}

本研究で使用したコードクローンの検出ツールは閾値でコードクローンを判定しているため，閾値によっては，メソッドの分類件数が異なる可能性がある．類似度を判定するための閾値に関しては，従来研究で検証されている0.7を使用することを信頼性を担保した．

全てのコミット間隔ではなく，マイナーバージョンの間隔に絞って分析しているため，バージョン間で生成・削除された短命メソッドについては，見逃してしまう．しかし，これら短命のメソッドは開発者が一時的に導入するメソッドであるため，ソフトウェアにとって負債となり得ない．

\subsection{外的妥当性}
本研究はPythonのpandasプロジェクトのみを対象としている．データサイエンス分野に特化したライブラリ特有の進化パターンが存在する可能性があり，他のドメイン（例：Webフレームワーク，組み込みシステム）や他のプログラミング言語（例：Java, C++）で開発されたプロジェクトにおいても同様の削除パターンやクローン整理の傾向が見られるかは不明である．今後はより多様なOSSプロジェクトを対象とした大規模な調査が求められる．

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{おわりに}
\label{sec:conclusion}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

本研究では，メソッド間のクローン類似度がメソッド削除の判断指標として機能するかを検証した．Pythonライブラリpandasの40,264件のメソッドを対象に，2つのリサーチクエスチョンに基づき分析を行った．

RQ1の分析では，クローンを持たないメソッドの削除率（3.3\%）がクローンを持つメソッド（2.5\%）より有意に高く，クローンを持つメソッドの中では高類似度群ほど削除されやすいことを示した．RQ2の分析では，メソッドの統合前にはクローン類似度が段階的に上昇する一方，削除前にはそのような変化が観察されないことを明らかにした．

以上の結果から，クローン類似度の動的な変化はメソッド統合の予測指標として有効であるが，メソッド削除の予測には単独では不十分であり，削除はAPIポリシーの変更やモジュールの廃止といったプロジェクトレベルの意思決定に依存していることが示唆された．

今後の課題として，クローン類似度に加え，依存関係や変更頻度などの他のメトリクスとの組合せによる削除指標の精緻化，および対象プロジェクトの多様化による知見の一般性の検証が挙げられる．近年，AIによるコード生成の普及に伴い，不要コードがソフトウェアに混入する機会が増加しており，メソッド削除の判断を支援する定量的な指標の重要性は今後さらに高まると考えられる．

% \bibliographystyle{junsrt}
% \bibliography{@IPSJ_SIGSE202603_Yoshida/yoshida_refs}
\bibliographystyle{ipsjunsrt}
\bibliography{yoshida_refs}

\end{document}

\documentclass[submit,techrep,noauthor]{ipsj}

\usepackage[dvipdfmx]{graphicx}
\usepackage{latexsym}
\usepackage{url}
\usepackage{xcolor}
\usepackage{listings}
\usepackage{amsmath,amssymb}
\usepackage{tabularx}
\usepackage{stfloats}
\usepackage{booktabs}
\usepackage{threeparttable}
\usepackage{caption}

\newcounter{patternID}

% コード例を載せるためのあれこれ
\definecolor{lightred}{RGB}{255,230,230}
\definecolor{lightgreen}{RGB}{230,255,230}

\lstset{
  basicstyle=\small\ttfamily,
  abovecaptionskip=0pt,
  captionpos=b,
  frame=tb,
  framexleftmargin=2em,
  numbers=left,
  numberstyle={\scriptsize},
  xleftmargin=\parindent,
  escapechar=|
}

%ListingのキャプションがFigureになってしまうのをListingに直すコマンド
\usepackage{caption}
\makeatletter
\let\MYcaption\@makecaption
\makeatother
\usepackage{caption}
\makeatletter
\let\@makecaption\MYcaption
\makeatother

\newcommand{\todo}[1]{\colorbox{yellow}{{\bf TODO}:}{\color{red} {\textbf{[#1]}}}}
\newcommand{\memo}[1]{\colorbox{magenta!30}{{\bf MEMO}:}{\color{red!50} {\textbf{[#1]}}}}
\newcommand{\ihara}[1]{\colorbox{green}{{\bf IHARA}:}{\color{blue} {\textbf{[#1]}}}}
\newcommand{\iida}[1]{\colorbox{cyan}{{\bf Iida}:}{\color{red} {\textbf{[#1]}}}}

\def\Underline{\setbox0\hbox\bgroup\let\\\endUnderline}
\def\endUnderline{\vphantom{y}\egroup\smash{\underline{\box0}}\\}
\def\|{\verb|}
%

\def\Underline{\setbox0\hbox\bgroup\let\\\endUnderline}
\def\endUnderline{\vphantom{y}\egroup\smash{\underline{\box0}}\\}
\def\|{\verb|}

\begin{document}

\title{ソフトウェア再構成における\\
  メソッド削除の判断指標の検討
}

\affiliate{WU}{和歌山大学\\
Wakayama University, 930 Sakaedani, Wakayama 640--8510, Japan}

\author{吉田 将衛}{Yoshida Shoei}{WU}[s276296@wakayama-u.ac.jp]
\author{伊原 彰紀}{Ihara Akinori}{WU}[ihara@wakayama-u.ac.jp]
\author{飯田 智輝}{Iida Tomoki}{WU}[s266016@wakayama-u.ac.jp]

\begin{abstract}
  \todo{「デブロート」ってどこかで使う．}
  ライブラリは，機能追加や削除を繰り返しながら進化を続けている．その進化の過程で，その結果，多くのライブラリは規模が拡大している．この問題を解決するためのソフトウェア再構成として，類似する機能を持つメソッドを削除することがある．しかし，削除するメソッドを客観的に判断することは容易ではなく，最終的に開発者の経験に依存せざるを得ない．
  本研究では，\todo{XXを用いてXXすることで，}削除されたメソッドの特徴を明らかにする．具体的には，同じバージョンに含まれる複数のメソッド間で類似度が高いと片方\todo{または両方？}が削除されたメソッドの\todo{XX}を調査する．ケーススタディとして広く利用されるPythonライブラリ1件における削除されたメソッド6,537件を対象に\todo{XXを分析した}結果，類似度が高いメソッド間において片方が削除されることを明らかにした\todo{この結論ではダメなので，あとで直す}．
\end{abstract}

\maketitle

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{はじめに}
\label{sec:background}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% 現代のソフトウェア開発はソフトウェア部品の組み合わせで行われる\cite{liblary-reuse}．ソフトウェア部品は再利用可能な形でまとめられ，ライブラリと呼ばれる．ライブラリの利用によって，ソフトウェア開発者はソフトウェアの開発工程を大幅に削減することができる\cite{reduce-productivity}．ライブラリ開発者は，さらに上流のライブラリを使用することもあり，ソフトウェアエコシステム\cite{software-wcosystem}を形成する\iida{ライブラリもライブラリを使って制作しているよといいたい？依存関係の波及とかの話いる？削除時の影響の話があるなら書いてもいいと思う}．

多くのソフトウェア開発は，ソフトウェア部品の組み合わせで行われる\cite{liblary-reuse}．特に，特定の機能を再利用可能な形でまとめられたライブラリの利用によってソフトウェアの開発工程を大幅に削減している\cite{reduce-productivity}．
% \memo{ソフトウェアの規模が大きくなる→課題→（従来研究）→本研究での目的}
したがって，ライブラリも多くのソフトウェアと同様に，ライブラリの機能性を向上するための進化を続けている．ただし，その進化の過程で，「ライブラリが外部へ公開しているAPIの名称変更」や「引数の変更」など，既存機能の変更や削除によって後方互換性を損失することがある\cite{detect-backward-compatibility}\cite{Brito2018WhyAH}．
% ため，破壊的変更を引き起こす可能性がある．「ライブラリが外部へ公開しているAPIの名称変更」や「引数の変更」など，様々な要因によって，破壊的変更が引き起こされる\todo{引用}\cite{detect-backward-compatibility}．
その中でも特に，ライブラリAPIの削除はクライアントソフトウェア（以降，クライアント）に甚大な影響を及ぼす．削除によって当該機能を使用するクライアントは同一の機能を継続して運用するために，代替APIへ切り替え，自身で実装，機能廃止などの選択が迫られる\cite{client-action-on-deprecation}．その一方で，ライブラリにとっては，ライブラリの再利用性，軽量化のために効果的な方法であるため，ライブラリ開発者は，クライアントへの影響範囲も危惧しつつ，不要なソースコードを削除する方法を検討している\cite{Vzquez2019SlimmingJA}．

% APIの削除という大きな変更に関しては，急に行うと，ソフトウェアエコシステム全体に負荷がかかる．したがって，多くのライブラリでは，セマンティックバージョニング\footnote{\url{https://semver.org}}という戦略を採用している．セマンティックバージョニングに従っているライブラリは一般的にメジャーバージョンのリリース時のみで破壊的変更を加える．この仕組みによって，クライアントはメジャーバージョンのアップデート時には，破壊的変更の対策を取ることができる．また，APIの削除は急に行われるわけではなく，削除よりも一定期間前から非推奨という警告を出し，クライアントが十分に対策を行える猶予を作った上で，削除を行うという仕組みが備わっている\iida{引用}．

% \iida{本題のここまでが遠い，上の内容は一部2章に持って行ってもいいのでは？また下のデッドコードも2章で軽く触れて結果で再登場くらいで良さそう}
% 多くのソフトウェアには，不要と考えられるソースコードが含まれる\todo{引用}．しかし，開発者が膨大なソースコードの中から不要コードを見つけることができても，それを削除することは難しい．なぜなら不要コードには，様々な種類があるからである．そこで、従来研究では、不要なソースコードを検出する手法がいくつか提案されている\todo{引用}．

従来研究では，デッドコード，未使用変数/関数，到達不能コードなどの不要なソースコード（以降，不要コード）を検出する手法が提案されている\todo{引用}．多くのソフトウェアは不要コードが含まれ，開発者はそれを認識していても，それぞれ異なる理由で\todo{$\leftarrow$少しもやっと書いてるので治したい}削除まで至るのは一部である．したがって，ソースコードを削除するのは経験豊富な開発者の決定に依存している．X(メイン，対抗馬で引用する研究を数行程度で紹介)らは．．．

% \todo{従来の研究を軽く入れる}
% 一つ目は，ソースコード中から不要コードを見つけ出す手法である．例えば，プログラム中で到達することができないプログラムはデッドコードと呼ばれ，不要コードと考えられる．デッドコードに関しては，静的解析と動的解析を組み合わせることでおおよそ検出ができる．静的解析では，動的な依存関係を取得することが難しいため，見逃しが発生してしまう．また，動的解析では，エッジケースの入力や年に1回だけ実行されるようなケースを誤って陽性と判断してしまう．このように，デッドコードの検出は，まだまだ課題が残っている．\iida{課題が残るというと吉田研究で取り組むみたいにみえるけど，取り組むの？}

% 二つ目は，ソースコードの変更履歴における削除に着目する方法である．変更履歴において，削除されたコードは不要であると考える．そこで、変更履歴から削除されたコードを収集し，共通する特徴を抽出するという方法である．\iida{抽出で終わり？}しかし，この分析方法では，ノイズが多く混ざってしまう．例えば，リファクタリングの一環として開発者がソースコードを移動した場合，履歴上では，削除と追加という変更として記録されてしまう．したがって，本質的な削除のみを抽出する手法が必要である．
% そこで，RefactoringMiner\cite{Alikhanifard:TOSEM:2024:RefactoringMiner3.0}のようなリファクタリング検出手法によりノイズを減らす工夫がされている．しかし，RefactoringMinerは全ての変更コミットを探索するため，大規模なOSSで適用するには非常に計算コストがかかってしまう．また，リファクタリングが複数コミットに渡る場合，RefactoringMinerでも検出ができなくなる．

本研究では，ソフトウェアを構成するソースコード間の類似度の変化過程を調査し，当該ソフトウェアの開発者が削除するタイミングとその要因を明らかにする．ソースコード間の類似度にはN-gramを元にしたツールNIL\cite{NIL}を用い，開発者が削除すると判断した決定要因を定量的に示す．\todo{本手法はコードクローンとは違うとも言いたい}\todo{必要に応じて，ここでRQも書く．}

% \iida{本研究では，〜〜することで、〜〜を実現or要因を見つけるみたいに１文目は書きたい}
% \todo{サクッと一文で言い切ってから，その詳細を書くイメージにする}
% そこで，本研究では，バージョンごとにソフトウェア中に存在するメソッドを全て抽出し，バージョン間で同じシグネチャのメソッドが存在せず，かつ，類似するメソッドが存在しなかった場合に削除されたメソッドであると判定する．バージョンごとのコミットだけに着目することで計算コストを削減し，類似メソッドで削除を判定することで，複数コミットにわたるリファクタリングも検出できるようになる．さらに，一時的に追加されたコードクローンが削除されるケースも発生するため，コードクローンに関連するケースについても検出する．

以降，本論文では，\ref{sec:deletecode}章で不要コードの種類と不要コードが与える影響，関連研究と本研究の位置付けを述べる．\ref{sec:approach}章では，本研究の分析手法を述べ，\ref{sec:case-study}章では，設定したRQにおけるそれぞれの分析手法，結果，考察を述べる．続く\ref{sec:thread-to-validity}章では，本研究の妥当性の脅威を述べる．最後に\ref{sec:conclusion}章で本論文をまとめる．

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{不要コード}
\label{sec:deletecode}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{不要コードの種類}
ソフトウェアにとっての不要なコードはステークホルダやタイミングによって異なる．クライアントにとって必要な機能であってもライブラリ開発者にとっては，保持したくないソースコードもある．例えば，後方互換性を維持するだけのソースコードはライブラリにとっては保持したくない不要なソースコードであるが，古いバージョンを使用するクライアントにとっては必要である．他にも，頻繁に使用されるライブラリのAPIは必要であるが，より効率的な実装の代替APIが登場すれば，現状のAPIは不要とみなされることがある．
不要なソースコード（以降，不要コードと呼ぶ）\cite{static-analysis}\cite{increase-maintainability}の代表例として，1つ目にデッドコード\cite{static-analysis}\cite{dynamic-analysis}\cite{decrease-readability}が挙げられる．デッドコードはプログラム中で到達不可能なソースコードのことを指す．2つ目に未実行コード\cite{static-analysis}\cite{increase-maintainability}が挙げられる．未実行コードは観測期間において，一度も実行されないソースコードのことを指す．
本研究では，不要コードの中でも削除されたコードに着目する．

% \begin{table}[t]
%     \centering
%     \caption{不要コードの分類\iida{不要コードの分類に不要コードあるのは粒度が違うから違和感，定義が正しい？}}
%     \scalebox{0.9}{
%     \begin{tabular}{l|p{5.3cm}|l} \hline
%         種類 & 定義 & 関連研究 \\ \hline
%         デッドコード & プログラム中で到達不可能なソースコード & \cite{static-analysis}\cite{dynamic-analysis}\cite{decrease-readability} \\
%         未実行コード & 観測期間において，実行されないソースコード & \cite{static-analysis}\cite{increase-maintainability} \\
%         不要コード & システムの目的を果たすために必要ではないソースコード & \cite{static-analysis}\cite{increase-maintainability} \\
%         削除コード & 削除されたソースコード \\ \hline
%     \end{tabular}
%     }
%     \label{tab:unnecessary-code}
% \end{table}

\subsection{不要コードが引き起こす問題}
不要コードがコードベースに蓄積することは様々な問題を引き起こす．\iida{されているとは言えない？下の文章でも少しインパクトが小さく見えてしまう}Sebastianら\cite{increase-maintainability}の研究では，不要コードは保守コストの増加を引き起こすと言われている．ソースコードの修正時に，未使用のソースコードも同時に修正する必要があるため，無駄なコストを作り出してしまう．また，Simoneら\cite{decrease-readability}の研究では，コードベースを理解する際に，不要コードを読んでしまうことで，ソースコード理解の有効性や効率を下げてしまうと言われている．
したがって，不要コードは検出し，削除することで，コードベースから取り除く必要がある．
\todo{保守コストの増大とかが起こった結果，どういう問題になるのかみたいなことを入れたい．この結果，こういう大惨事になったよっていう事例とかがあると良いかも}

\subsection{関連研究}

\subsubsection{動的解析による不要コードの特定}
不要コードの検出を行う研究は複数存在している．１つ目に，未実行コードを検出する手法が提案されている．
観測期間において，実行されていないソースコードを検出し，自動で削除する研究が提案されている\cite{dynamic-analysis}．この手法では，ソフトウェア中のさまざまなコンポーネントにログを組み込み，実環境で一定期間運用することで実行状況のログを取得する．その後，実行状況のログの中で実行履歴がないコンポーネントを不要コードと判定する．
% しかし，ソフトウェアの使用状況に基づく不要コードの検出では，偽陽性が発生する．
例えば，エラー処理のソースコードや復旧用のソースコード，移行のためのソースコードは観測期間において，実行されていなければ，不要コードであると検出される．本研究では，削除されたかどうかに着目している．
% このようなソースコードは実行されていなくとも，他のコンポーネントとの依存関係があるので，削除してはいけない．したがって，実行状況の監視と共に依存関係の取得も必要である．

\subsubsection{静的解析による不要コードの特定}
依存関係に着目し，他との依存関係を持たないデッドコードを静的に検出する手法が提案されている\cite{detect-dead-code}．\todo{デッドコードの検出手法の説明}
例えば，リフレクションのように動的に依存関係が決まる場合，依存関係を持たないと判定され，削除候補となる．

これらの研究は使用されていないソースコードを検出することを目的としている．本研究では，削除されたソースコードの特徴を分析することを目的としている．\iida{最終的に広い概念で見た結果どう違うのか主張できそう？}

\subsubsection{削除コードの実証分析}
\iida{不要コードの検出とどう違うかが難しい，要因調査の研究？}
削除ファイルの特徴を分析した研究では，「最近変更されておらず，依存の中心にいない特徴を持つファイル」が「生存するファイル」に比べ，有意に差があるということを発見した\cite{static-analysis}．

テストコードの削除に着目した研究\cite{study-of-test-deletion}では，削除されたテストメソッドの83.2\%はテストクラスごと削除され，7\%は冗長なテストであった．さらに，削除されたテストメソッドの91.4\%はプロダクションコードの廃止による副次的な削除であることがわかった．

Ashokら\cite{why-deprecated}は，メソッドが非推奨になる理由をコミット履歴やイシュートラッカーなどを基に調査，分類した．その結果，「新機能の導入」，「機能上の欠陥」，「デザインパターン」の3種類で全体の約72\%を占めていた．\todo{この辺の研究の課題を入れる}

\todo{自分の研究に近い研究を入れる}

% \subsubsection{自動削除の研究}
% \todo{Meta\cite{dynamic-analysis}やUberの自動削除の研究}\memo{書くか迷っている}

\subsection{動機}
Pythonのpandas-dev/pandas\footnote{\url{https://github.com/pandas-dev/pandas}}プロジェクトを対象に，削除されたメソッドについて，目視調査を実施した．

v0.25.0における\texttt{pandas/io/common.py}内のメソッド\texttt{\textunderscore stringify\textunderscore path}はioに関するプライベートメソッドである．これは削除直前までは，他のファイルから呼び出されていた．しかし，0df8858752のコミットにおいて，削除されている\footnote{\url{https://github.com/pandas-dev/pandas/commit/0df8858752}}．このコミットに関しては，Pull Requestのタイトルで，io関連のメソッドを非公開化する趣旨の内容が記載されていた．

このような非公開による削除の事例から，開発者がメソッドを削除する理由はデッドコードだけに留まらないことがわかった．\iida{結果の例はこれでいいの？}

\iida{話が下で飛びからここでクローンに着目する理由が必要．非公開化の事例→狭義の不要コード以外もあるよ→（その要因はクローンと，B，Cでした？）→だからRQはいかになります．のように書いたほうがいいと思う．}

\subsection{本研究の位置付け}

\vspace{5pt}
\noindent\emph{開発者の判断に基づく削除履歴への着目}
\vspace{5pt}

本研究では，「開発者が削除した」という確定した事実をGround Truthとし，分析対象とする．実行履歴や依存関係がなくても削除されていなければ，分析対象ではない．

\vspace{5pt}
\noindent\emph{類似度を用いたメソッドの比較}
\vspace{5pt}

類似するメソッドを持つか否か，さらに，類似度の高低によってメソッドの削除にどのように関係するかを明らかにする．

以上の示唆に基づき，本研究では，以下のリサーチクエスチョン（Research Questions）を設定する．
\begin{itemize}
  \item RQ1: \todo{後で書く}
  \item RQ2: \todo{後で書く}
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{アプローチ}
\label{sec:approach}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{概要}
本章では，OSSプロジェクトの進化過程において，削除されたメソッドを特定する．
手順1から3は，対象プロジェクトの特定バージョンからメソッドを抽出し，抽象構文木を用いてシグネチャとボディを取得する．手順4で，隣接するバージョン間で同一メソッドを紐づける．

\begin{figure}[ht]
  \centering
  \includegraphics[width=1.0\linewidth]{./Yoshida_fig/approach}
  \caption{削除メソッドの特定過程}
  \label{fig:placeholder}
\end{figure}

\subsection{削除メソッドの特定方法}
\label{sec:detect-delete-method}

\noindent\emph{1. 解析対象バージョンの選定}

対象とするOSSのGitHub\footnote{\url{https://github.com/}}リポジトリから，タグを含むコミットを全て取得する．タグを含むコミットからセマンティックバージョニングを使用しているコミット\iida{どういったバージョンのことか教えてもらう}のみをフィルタリングする．
さらに，セマンティックバージョニングの末尾に「rc」や「dev」といったプレリリースが含まれるタグについては，正規表現で排除する．
また，本研究では，メジャーおよびマイナーバージョンの変遷に着目するため，パッチバージョンが「0」であるタグ（例：「v1.2.0」）のみを対象とする．パッチバージョン間隔では，削除されたメソッドが0件になる場合があるため，ある程度の期間を持たせるためにパッチバージョンを無視している．
これらの操作によって，マイナーバージョン，メジャーバージョンのタグとそのコミットのみを時系列順にK個抽出する．
% \iida{一旦K個て書いてる？}説明の都合上，K個って書いてます．

\noindent\emph{2. メソッドのシグネチャとボディの取得}

取得したバージョンへ順次チェックアウトを行い，当該バージョンに含まれる全てのPythonファイル（.py）を対象に抽象構文木（Abstract Syntax Tree）へパースする（以降，ASTとする）．このASTからメソッドのシグネチャを取得し，一意のメソッド名を構築する（「ファイルパス，クラス名.メソッド名，引数，戻り値」という形式）．
同時にメソッドのボディもASTから取得しておき，トークンで分割し，リストとして保存する．

\noindent\emph{3. メソッドのN-gram化}

バージョン $k$ ($1 \le k < K$) における $M$ 個のメソッドの集合を $V_{k} = \{c_1, c_2, \dots, c_M\}$ とする．
各メソッド $c_m \in V_k$ に対して N-gram 化を行い，抽出された N-gram の集合を $G(c_m)$ と表す．
本研究では，従来研究と同様に 5-gram を採用する\cite{NIL}．

\noindent\emph{A. バージョン間でのシグネチャの一致}

隣接するバージョン$V_{k}$と$V_{k+1}$の間でシグネチャが完全に一致するメソッドを同一と見なし，共通のIDを割り当てる．

\noindent\emph{B. バージョン間での類似度の計算}

コードクローン検出器 NIL を使用して，バージョン間でのクローンメソッドを検出する．
$V_{k}$ における各メソッド $c_i$ に対し，$V_{k+1}$ における全てのメソッド $c_j$ との類似度を計測する．
この際，類似度が閾値を超えたメソッドをクローン候補メソッドとする．従来研究と同様に類似度の閾値は 0.7 を使用する．
$V_{k}$ における特定のメソッドに対し，$V_{k+1}$ における複数のメソッドが閾値を超えた場合は，最大の類似度をもつメソッドを候補メソッドとする．
% し，同一IDを割り当てる．\iida{つまり同じメソッドだよねと言いたいだけ？それともクローン判別の話？同一IDとは}

NIL による詳細な類似度計算（検証フェーズ）では，以下の式を用いる．
\begin{equation}
  \text{Sim}_{\text{verif}}(c_i, c_j) = \frac{\text{LCS}(c_i, c_j)}{\min(|c_i|, |c_j|)}
\end{equation}
ここで，
\begin{description}
  \item[$c_i, c_j$:] 比較対象となる2つのメソッドのトークン列
  \item[$|c_i|, |c_j|$:] 各トークン列の長さ
  \item[$\text{LCS}(c_i, c_j)$:] 2つのトークン列間で、順序を保ったまま一致している最長共通部分列（Longest Common Subsequence）の長さ
\end{description}

本手法の特徴は，分母に最小値（$\min$）を用いている点にある．
これにより，一方がもう一方を包含している場合に類似度が高く算出される．
例えば，片方のメソッドに大量の新しいコードが追加されて全体の長さが大きく変化した場合でも，元のロジックが保存されていればクローンとして検出可能である．

しかし，LCS による類似度計算は計算コストが非常に高いため，以下の式を用いたフィルタリングフェーズを導入し，明らかに異なるメソッド対を事前に除外する．
\begin{equation}
  \text{Sim}_{\text{filt}}(c_i, c_j) = \frac{|G(c_i) \cap G(c_j)|}{\min(|G(c_i)|, |G(c_j)|)}
\end{equation}
ここで，$G(c)$ はメソッド $c$ の N-gram 集合を表し，$|G(c_i) \cap G(c_j)|$ は $c_i$ と $c_j$ で共通する N-gram の要素数を表す．
このフィルタリングにより，類似度が 0.1 未満のメソッド対に対する LCS 計算を省略し，全体の実行時間を削減している．

\noindent\emph{4. 同一メソッドの追跡}

まず，Aを用いて，同一メソッドを判定する．このとき，メソッドの中身やロジックは同一でも，リネームや，ファイルの移動を受けたメソッドは同一メソッドと判定できない．
したがって，Aによる同一メソッドの判定後に残ったメソッドについて，Bを用いることで同一メソッドを判定する．これによって，リネームやファイル移動したメソッドでも追跡することができる．
このIDの変遷を比較することで，メソッドを以下の3つに分類する．$V_{k+1}$で初めて出現したIDを持つメソッドを「追加メソッド」，$V_{k}$と$V_{k+1}$の両方に存在するIDを「生存メソッド」，$V_{k}$のみに存在するIDを「削除メソッド」とする．

\subsection{類似度に基づく削除メソッドの件数分析}
各バージョン$V_k$に対し，コードクローン検出器NILを用いて全メソッド間の類似度を算出する．算出結果に基づき，あるバージョン内で少なくとも一つ以上のクローン相手を持つメソッドを「クローンあり」，それ以外を「クローンなし」と定義する．

次に，\ref{sec:detect-delete-method}節の手法により，各メソッドを隣接バージョン$V_k$と$V_k+1$の間で追跡し，「生存メソッド」または「削除メソッド」にラベル付けする．以上より，メソッドを（クローンあり/なし）$\times$（生存/削除）の4群に分け，バージョンごとの削除数・生存数の分布差を検定する．

さらに，「クローンあり」群に限り，削除されたメソッドと生存したメソッドでクローン類似度の分布が異なるかを検定する．

\subsection{メソッドの削除パターンの分類}

まず，バージョン$V_{k}$内において，メソッド間のコードクローン検出を行う．コードクローンは通常，2つのメソッドのペアとして検出されるため，これらのペアに対して推移律（メソッドaとb，bとcがクローンであれば，aとcも同一グループとする）を適用し，クローン集合（以降，クローンセットとする）を構築する．
次に，各クローンセットに属するメソッドの$V_{k+1}$における生存状況を確認し，以下の3つに分類する．

\begin{description}
  \item[全削除: ] あるクローンセットに含まれる全てのメソッドが，$V_{k+1}$において，「削除メソッド」と判定された場合．これは，クローンセットが提供していた機能自体がプロジェクトから消滅したことを意味する．
\end{description}

\begin{description}
  \item[部分削除: ] あるクローンセットに含まれるメソッドのうち，一部が$V_{k+1}$ で「削除メソッド」となり，少なくとも1つ以上のメソッドが「生存メソッド」として残っている場合．この場合，削除されたメソッドは「部分削除」，生存したメソッドは「部分生存」と定義する．これは，重複していたコードが統合されたり，特定の箇所のみが不要になったりする「リファクタリング」に近い挙動を示していると考えられる．
\end{description}

\begin{description}
  \item[独立削除: ] バージョン$V_{k}$において，他のどのメソッドともクローン関係にない（すなわち，どのクローンセットにも属さない）メソッドが $V_{k+1}$ で削除された場合．これは，そのメソッドが担っていた固有の機能がプロジェクトから取り除かれたことを示す．
\end{description}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{ケーススタディ}
\label{sec:case-study}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{データセット}
GitHub\footnote{\url{https://github.com}}上でソースコードが公開されているpandas-dev/pandas\footnote{\url{https://github.com/pandas-dev/pandas}}プロジェクトを使用した．プロジェクトの選定方法は以下である．

\begin{itemize}
  \item Pythonのプロジェクトであること．
  \item 大規模なライブラリであり，ユーザが多数存在すること．
  \item 開発年数が長期であること．
  \item メジャーリリースが2つ以上存在すること．
\end{itemize}

\subsection{RQ1: 同一バージョン内でクローンを持つことは，次バージョンでの生存/削除にどの程度関係するか}

\subsubsection{概要}
ソフトウェアの規模拡大を抑制する手段の一つに，類似機能を持つメソッドの整理・統合がある．本節では，メソッド間の類似度が削除にどの程度寄与しているかを調査する．\iida{事前分析で前振りが欲しい}具体的には，メソッドが同一バージョン内に類似するメソッドを有しているか否かに着目し，類似メソッドの存在がメソッドの削除・生存の判断指標となり得るかを検討する．

\subsubsection{結果}

\begin{figure}[ht]
  \centering
  \includegraphics[width=1.0\linewidth]{./Yoshida_fig/boxplot_academic_final}
  \caption{メソッドのバージョン間での分類タイプの件数を表す箱ひげ図}
  \label{fig:method-classification}
\end{figure}

% \begin{table}[ht]
%   \centering
%   \caption{メソッドの状態分類におけるクローンの有無}
%   \begin{tabular}{c|ccccc}
%     \hline
%     & 追加 & 削除 & 分割 & 統合 & 変更 \\
%     \hline
%     クローンなし & 26,108 & 5,472 & 2,614 & 2,668 & 166,318 \\
%     クローンあり & - & 3,228 & 71,364 & 73,656 & 302,525 \\
%     \hline
%   \end{tabular}
%   \label{tab:has-clone}
% \end{table}

\begin{table*}[ht]
  \centering
  \caption{ウィルコクソンの符号付き順位検定を用いた，メソッドの類似度と削除/生存の関係}
  % \scalebox{1.0}{
  \begin{tabular}{l|cccc|cccc}
    \toprule
    & クローンなし & クローンあり & p値 & $r_{\mathrm{rb}}$ & 低類似度 & 高類似度 & p値 & $r_{\mathrm{rb}}$ \\
    \midrule
    平均削除数 & $1.5 \times 10^{2}$ & $9.1 \times 10$ & $6.52 \times 10^{-9}$ & 0.73 & $6.9 \times 10$ & $2.2 \times 10$ & \todo{X} & \todo{X} \\
    平均生存数 & $5.4 \times 10^{3}$ & $4.2 \times 10^{3}$ & $9.31 \times 10^{-10}$ & 0.77 & $3.4 \times 10^{3}$ & $8.1 \times 10^{2}$ & \todo{X} & \todo{X} \\
    平均削除率 & $3.3 \times 10^{-2}$ & $2.5 \times 10^{-2}$ & $1.45 \times 10^{-4}$ & 0.48 & $2.4 \times 10^{-2}$ & $2.9 \times 10^{-2}$ & $3.56 \times 10^{-2}$ & 0.38 \\
    \bottomrule
  \end{tabular}
  % }
  \label{tab:test-clone}
\end{table*}

図~\ref{fig:method-classification}は隣接するバージョン遷移（$V_k \to V_{k+1}$）ごとに，当該遷移で観測されたメソッド数を（クローンなし/あり）$\times$（削除/生存）の分類別に箱ひげ図で示す．
箱ひげ図の各点は1つの隣接バージョン遷移に対応し，その遷移における各分類のメソッド数を表す．
分布のばらつきが大きいため，縦軸は対数スケールで可視化している．

次に，隣接バージョン遷移を単位として，類似度の違いによる件数分布の差を検定した結果が表\ref{tab:test-clone}である．
本データは対応のある構造を持つため，群間差の検定にはノンパラメトリックな対応あり検定であるウィルコクソンの符号付順位検定を用いた．
これは，順位に基づいて検定するものであり，件数分布の非正規性や外れ値の影響を受けにくい．
効果量としては，順位に基づく効果量（matched-pairs rank-biserial correlation：$r_{\mathrm{rb}}$）を用いた．

表~\ref{tab:test-clone}はバージョン遷移における削除数の平均，生存数の平均，削除率の平均を「クローンなし」，「クローンあり」の2群に分けて，算出した結果である．
どの群においても，クローンなしの平均の数が多くなっていた．さらに，ウィルコクソンの符号付き順位検定を用いた結果，p値は0.01を下回っていたため，「クローンなし」のメソッドの方が「クローンあり」のメソッドに比べ，削除数，生存数，削除率が高いことがわかった．さらに，効果量から，削除数，生存数に関しては，大きい程度を持ち，削除率に関しては，中程度を持っていることがわかった．

さらに，表~\ref{tab:test-clone}における，削除率を高類似度群（$90 \leq Sim$）と低類似度群（$70 \leq Sim < 90$）に分けて，算出した結果，高類似度群の方が，低類似度群よりも削除率が高かった．ウィルコクソンの符号付き順位検定を用いた結果，p値は0.01を下回っていたため，「高類似度群」の方が「低類似度群」のメソッドよりも統計的に削除されやすいことがわかった．効果量に関しては，中程度である．

つまり，類似メソッドを持つメソッドの中でも，90\%以上の類似度を持っている場合，90\%未満の類似メソッドを持つメソッドに比べて，削除されやすいことがわかる． \iida{考察は書かない？ここから何は読み取れるかが欲しい.統合と分割を生存としているから下がっている気もする.類似メソッドがあると消しにくい理由とか考察できそうかな？}

\subsection{RQ2: クローンセットは，次バージョンでどのような削除パターンを取るか}

\subsubsection{概要}

本研究では，削除されたメソッドのうち，クローンを持つメソッドはどのように削除されるかを調査する．そのため，メソッドがクローンセットと共に削除されるかを分類する．

% \subsubsection{メソッドの削除パターン}

% 表~\ref{tab:pattern-method}は，各バージョン遷移において，削除されたメソッドの数と生存したメソッドの数を表している．さらに，削除件数に関しては，全削除，部分削除，独立削除の3パターンで独立に集計しており，生存件数に関しても，部分生存，独立生存で独立に集計している．

% \begin{table}[ht]
%   \centering
%   \caption{メソッドの変遷パターン}
%   \begin{tabular}{l|rrr|rr}
%     \toprule
%     & \multicolumn{3}{c}{削除} & \multicolumn{2}{c}{生存} \\
%     バージョン & 全削除 & 部分削除 & 独立削除 & 部分生存 & 独立生存 \\
%     \midrule
%     v0.4.0 & 6 & 0 & 18 & 428 & 852 \\
%     v0.5.0 & 4 & 1 & 15 & 505 & 1029 \\
%     v0.6.0 & 41 & 7 & 150 & 540 & 962 \\
%     v0.7.0 & 56 & 11 & 129 & 670 & 1202 \\
%     v0.8.0 & 16 & 2 & 11 & 973 & 1724 \\
%     v0.9.0 & 33 & 8 & 130 & 1040 & 1756 \\
%     v0.10.0 & 33 & 8 & 143 & 1169 & 1836 \\
%     v0.11.0 & 7 & 3 & 12 & 1281 & 2031 \\
%     v0.12.0 & 15 & 11 & 44 & 1430 & 2195 \\
%     v0.13.0 & 20 & 18 & 113 & 2335 & 3452 \\
%     v0.14.0 & 35 & 15 & 57 & 2571 & 3853 \\
%     v0.15.0 & 8 & 8 & 33 & 3035 & 4177 \\
%     v0.16.0 & 19 & 10 & 43 & 3123 & 4405 \\
%     v0.17.0 & 13 & 17 & 50 & 4032 & 4787 \\
%     v0.18.0 & 87 & 11 & 168 & 4248 & 4940 \\
%     v0.19.0 & 168 & 64 & 383 & 4694 & 5187 \\
%     v0.20.0 & 32 & 8 & 58 & 4643 & 5757 \\
%     v0.21.0 & 0 & 1 & 3 & 4919 & 6071 \\
%     v0.22.0 & 113 & 1 & 353 & 4636 & 5769 \\
%     v0.23.0 & 121 & 14 & 496 & 4892 & 6138 \\
%     v0.24.0 & 82 & 12 & 394 & 5662 & 7019 \\
%     v0.25.0 & 57 & 6 & 472 & 5642 & 7045 \\ \midrule
%     v1.0.0 & 36 & 10 & 250 & 5964 & 7422 \\
%     v1.1.0 & 62 & 12 & 166 & 6409 & 7947 \\
%     v1.2.0 & 49 & 7 & 214 & 6824 & 8498 \\
%     v1.3.0 & 62 & 12 & 156 & 7384 & 9442 \\
%     v1.4.0 & 26 & 15 & 87 & 7699 & 10250 \\
%     v1.5.0 & 122 & 7 & 404 & 8142 & 10469 \\ \midrule
%     v2.0.0 & 67 & 17 & 133 & 8665 & 10783 \\
%     v2.1.0 & 20 & 11 & 96 & 9364 & 11077 \\
%     v2.2.0 & 2 & 6 & 11 & 9935 & 11313 \\ \midrule
%     合計 & 1,412 & 333 & 4,792 & 132,854 & 169,388 \\
%     \bottomrule
%   \end{tabular}
%   \label{tab:pattern-method}
% \end{table}

% 例えば，v1.0.0のリリース時は，グループの全削除が57件，独立削除が472件起こっている．さらに，v2.0.0のメジャーバージョンのリリース時にも全削除が122件，独立削除が404件起こっている．これは，メジャーバージョンのv1.0.0においては，最大の削除数となっている．
% このことから，メジャーバージョンのリリース時には，多くのメソッドが削除されることがわかる．

\begin{figure*}[ht]
  \centering
  \includegraphics[width=1.0\linewidth]{./Yoshida_fig/deletion_survival}
  \caption{メソッドの類似度の変遷}
  \label{fig:deletion-survival}
\end{figure*}

% \subsubsection{クローンセットの部分削除\memo{この節はなくても良いかも}}

% pandasプロジェクトにおいて，v0.19.0がリリースされた時点でのメソッドの例をListing~\ref{lis:include-deprecated-API}とListing~\ref{lis:include-inplace-API}に示す．これら二つのメソッドはコードクローン検出器によると類似度\todo{〇〇\%}となっており，コードクローンタイプ3である．どちらもPanelオブジェクトを生成しているという点では類似している．

% %----------------------------------
% \vspace{10pt}
% \begin{lstlisting}[caption=非推奨な記述方法を含むメソッド（次バージョンで削除）, label=lis:include-deprecated-API, captionpos=t, columns=flexible]
% def test_backwards_compat_without_term_object(self):
%     with ensure_clean_store(self.path) as store:

%         wp = Panel(np.random.randn(2, 5, 4), items=['Item1', 'Item2'],
%                    major_axis=date_range('1/1/2000', periods=5),
%                    minor_axis=['A', 'B', 'C', 'D'])
%         store.append('wp', wp)
%         with assert_produces_warning(expected_warning=FutureWarning,
%                                      check_stacklevel=False):
%             result = store.select('wp', [('major_axis>20000102'),
%                                          ('minor_axis', '=', ['A', 'B'])])
%         expected = wp.loc[:,
%                           wp.major_axis > Timestamp('20000102'),
%                           ['A', 'B']]
%         assert_panel_equal(result, expected)
% \end{lstlisting}
% \vspace{10pt}
% %----------------------------------
% Listing~\ref{lis:include-deprecated-API}は，古い形式のクエリの書き方が後方互換性を維持し，かつ，正しく動作するかを検証するメソッドである．
% コード内で\texttt{wp = Panel(...)}とある．ここでは，条件を\texttt{('カラム名','演算子','値')}というタプルのリストで渡している．そして，\texttt{with assert\textunderscore produces\textunderscore warning(FutureWarning)}を使って，「この記述方法が将来的に消える」という警告が出ることをテストしている．

% %----------------------------------
% \vspace{10pt}
% \begin{lstlisting}[caption=推奨APIを含むメソッド（次バージョンで生存）, label=lis:include-inplace-API, captionpos=t, columns=flexible]
% def test_panel_assignment(self):
%     # GH3777
%     wp = Panel(
%         randn(2, 5, 4), items=['Item1', 'Item2'],
%         major_axis=date_range('1/1/2000', periods=5),
%         minor_axis=['A', 'B', 'C', 'D'])
%     wp2 = Panel(
%         randn(2, 5, 4), items=['Item1', 'Item2'],
%         major_axis=date_range('1/1/2000', periods=5),
%         minor_axis=['A', 'B', 'C', 'D'])

%     # TODO: unused?
%     # expected = wp.loc[['Item1', 'Item2'], :, ['A', 'B']]

%     def f():
%         wp.loc[['Item1', 'Item2'], :, ['A', 'B']] = wp2.loc[
%             ['Item1', 'Item2'], :, ['A', 'B']]

%     self.assertRaises(NotImplementedError, f)
% \end{lstlisting}
% \vspace{10pt}
% %----------------------------------

% Listing~\ref{lis:include-inplace-API}は，まだ実装されていない操作に対して，適切にエラーを発生させているかを検証するテストメソッドである．
% 実行したい処理を内部関数\texttt{f()}の中で，\texttt{wp.loc[...] = wp2.loc[...]}という代入処理を記述している．そして，\texttt{self.assertRaises(NotImplementedError, f)}により関数\texttt{f()}を実行した際に，未実装のエラーが発生することをテストしている．

% Listing~\ref{lis:include-deprecated-API}における\texttt{test\textunderscore backwards\textunderscore compat\textunderscore without\textunderscore term\textunderscore object}メソッドは，v0.20.0リリース時には削除された．つまり，v0.19.0の時点では必要であったメソッドがv0.20.0の時点では不要であったため，削除されたと言える．
% 一方，Listing~\ref{lis:include-inplace-API}における\texttt{test\textunderscore panel\textunderscore assignment}メソッドはv0.20.0の時点でも削除されずに生存していたため，v0.20.0の時点では不要ではなく，必要なメソッドであると考えられる．その後，メジャーバージョンであるv1.0.0リリース直前のv0.25.0において不要となり，削除された．

% この結果から，v0.20.0では，\texttt{store.select}メソッドの古い形式の記述方法のサポートが終了したため，それを利用している側のコードが削除されたと考えられる．さらに，v0.25.0においては，\texttt{Panel}オブジェクトが削除されたため，それを呼び出しているメソッドも削除されたと考えられる．

% \subsubsection{クローンセットの全てのメソッドが削除\memo{この節はなくても良いかも}}
% v0.18.0がリリースされた時点において，クローンセットの全てのメソッドが削除された事例をListing~\ref{lis:test-get-options-data}とListing~\ref{lis:test-get-data-with-list}に示す．

% \vspace{10pt}
% \begin{lstlisting}[caption=v0.18.0における取引機能のテストメソッド（次バージョンで削除）, label=lis:test-get-options-data, captionpos=t, columns=flexible]
% @network
% def test_get_options_data(self):
%     # regression test GH6105
%     self.assertRaises(ValueError, self.aapl.get_options_data, month=3)
%     self.assertRaises(ValueError, self.aapl.get_options_data, year=1992)

%     try:
%         options = self.aapl.get_options_data(expiry=self.expiry)
%     except RemoteDataError as e:
%         raise nose.SkipTest(e)
%     self.assertTrue(len(options) > 1)

% \end{lstlisting}
% \vspace{10pt}

% Listing~\ref{lis:test-get-options-data}はオプション取引データの取得機能が正しく動作するかを検証するためのメソッドである．まず，\texttt{self.assertRaises(ValueError, ...)}によって，\texttt{self.aapl.get\textunderscore options\textunderscore data}メソッドに不正な引数を指定した場合に，正しくエラーが発生することを確認している．さらに，その後の\texttt{try...except...}句内で実際にデータを取得し，\texttt{self.assertTrue}によって，取得したデータが1以上であることを確認している．

% \vspace{10pt}
% \begin{lstlisting}[caption=v0.18.0におけるデータ一括取得のテストメソッド（次バージョンで削除）, label=lis:test-get-data-with-list, captionpos=t, columns=flexible]
% @network
% def test_get_data_with_list(self):
%     try:
%         data = self.aapl.get_call_data(expiry=self.aapl.expiry_dates)
%     except RemoteDataError as e:
%         raise nose.SkipTest(e)
%     self.assertTrue(len(data) > 1)

% \end{lstlisting}
% \vspace{10pt}

% Listing~\ref{lis:test-get-data-with-list}は，複数のリストをまとめて指定し，データを一括取得できるかを検証するテストコードである．\texttt{self.appl.get\textunderscore call\textunderscore data(expiry=self.aapl.expiry\textunderscore dates)}によって，データのリストを引数にいれ，データを取得する．そして，\texttt{try...except...}句内で実際にデータを取得し，\texttt{self.assertTrue}によって，取得したデータが1以上であることを確認している．

% Listing~\ref{lis:test-get-options-data}とListing~\ref{lis:test-get-data-with-list}は互いに，クローンと判定されたメソッドであり，類似度は\todo{X}\%である．これらは，v0.19.0で削除された．これらのメソッドのパスは\texttt{/pandas/io/tests/test\textunderscore data.py}に存在している．このパスに注目すると，v0.18.0においては，存在しているが，v0.19.0においては存在していなかった．つまり，これらのクローンメソッド群はファイル自体が削除されたことによって，同時にクローンセットごと削除されたと判定されたことがわかる．

% 次に，クローンセットの全てが削除された別の事例をListing~\ref{lis:median}とListing~\ref{lis:f}に示す．

% \vspace{10pt}
% \begin{lstlisting}[caption=v0.6.0における上位メソッド（次バージョンで削除）, label=lis:median, captionpos=t, columns=flexible]
% def median(self, axis='major', skipna=True):
%     def f(arr):
%         mask = common.notnull(arr)
%         if skipna:
%             return _tseries.median(arr[mask])
%         else:
%             if not mask.all():
%                 return np.nan
%             return _tseries.median(arr)
%     return self.apply(f, axis=axis)

% \end{lstlisting}
% \vspace{10pt}

% Listing~\ref{lis:median}は，内部に関数を定義し，それを\texttt{apply}メソッド用いることで，指定した軸に適用している．

% \vspace{10pt}
% \begin{lstlisting}[caption=v0.6.0における下位メソッド（次バージョンで削除）, label=lis:f, captionpos=t, columns=flexible]
% def f(arr):
%     mask = common.notnull(arr)
%     if skipna:
%         return _tseries.median(arr[mask])
%     else:
%         if not mask.all():
%             return np.nan
%         return _tseries.median(arr)

% \end{lstlisting}
% \vspace{10pt}

% Listing~\ref{lis:f}は，Listing~\ref{lis:median}の内部で定義されている関数である．つまり，関数の内部で関数が定義されている場合，それらの構造は類似しているとコードクローン検出器では，判定される．したがって，上位の関数が削除された場合，下位の関数も同時に削除される．

% これらの結果より，クローンと判定されたメソッド群が同時に削除される事例は上位概念の削除による副次的作用であることがわかる．

% \memo{この辺から大事かも}
% さらに，追加分析として，ファイル削除に伴うクローンセットの削除について分析した．\iida{結果の票なくなった？}プロジェクト上で削除されたことのあるファイルパスを収集し，クローンセットの削除が行われたメソッドが存在しているファイルパスと対応させた．その結果，33\% \memo{多少数字は変わるかも}ほどのクローンセットごと削除されたメソッドは，上位のファイルが削除されたことによる副次的作用であることが判明した．

% このように削除時点ではクローン関係が確認されない事例が多く観測されたことから，削除に至るまでの過程においてクローン関係がどのように変化しているのかを明らかにする必要がある．

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{考察}
\label{sec:discussion}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{クローン有無が削除の判断指標になり得る条件/ならない条件}
\todo{書く}

\iida{こんなにさらっと書いていいの？考察で熱く語るかもしれないけど。}
\iida{統合した時と分割したときは，k+1でもととなったKでのメソッドが削除されているのではないでしょうか(生存と書いているけど...)？単純な削除だけでないという主張からそちらもしっかり触れるべきだと思う}

バージョンごとの平均削除メソッド数246.32件に対し，バージョンごとの平均生存メソッド数9749.74件である．したがって，バージョンごとの平均メソッド数9,996件に対し，平均削除率は2.4\%となる．さらに，削除されたメソッド246.32件のうち，60.94件のメソッドはクローンを持っている．したがって，削除されたメソッドのうち，約24.7\%はクローンを持っていることになる．

一方，削除されたメソッドは約37\%がクローンを持つ．この理由として，クローンを持つメソッドの場合，削除時の影響範囲が拡大するため，メソッドはクローンを持たない方が削除されやすいという結果になったと考えられる．

削除されたメソッドの中でもクローンを持つメソッドとクローンを持たないメソッドでは，異なる特徴を持つことがわかる．
クローンセットの一部が削除されるという事例から，機能の移行期間では，一時的に類似機能を作成し，完全な移行が完了した時点で古いメソッドを削除するというパターンがあることがわかった．
クローンセットが同時に削除されるという事例から，削除パターンの一つとして，上位概念の削除による副次的削除が含まれることがわかる．\todo{クローンを持たずに削除されたメソッドの事例も述べるべきか？}

% クローンセットの一部が削除されるということは，削除されたメソッドは，より品質の低いメソッドであり，生存したメソッドは，より品質の高いメソッドであると考えられる．このような品質の低いメソッドを学習し，同じような特徴を持つメソッドを検出できれば，ソフトウェアの品質を向上させられる可能性がある．

%%%%%%%%%%%%%%%%%%%%%%%%

\todo{要検討}
% \memo{分割，統合されたメソッドのほとんどはクローンを持っていた．分割や統合がされた後に，メソッドのクローンは解消されたのかどうかを確認したい．}\memo{クローンが解消されていた場合→クローンが解消されてからメソッドが削除}\memo{クローンが解消されていなかった場合→変更の過程でクローンが解消orクローンを持ったままRQ1のような削除}

% \memo{変更と分類されたメソッドが，最終的に，分割や統合に向かっているのか，あるいは削除に向かっているのかを確認したい．}
% 図~\ref{fig:method-classification}の分類はメソッド単位で頻度を計測したものである．削除や分割，統合といった変更はファイルレベルやフォルダレベルで行われ，結果として，頻度が増大している可能性がある．したがって，メソッドレベルより，大きなレベルで変更を捉える必要がある．

\subsection{メソッド追跡手法の妥当性}
\iida{手法を後で聞く，ここまで}
本研究では，NILを用いてバージョン間の類似度を測定することで，メソッドの追加，削除，生存（分割，統合，変更）を捉えた．本手法の妥当性を検証するため，本手法で追加，削除，生存と判定されたそれぞれのメソッドについて，バージョン間でのファイルパスとメソッド名の完全一致について調査した．

追加と判定されたメソッドのファイルパスとメソッド名が前バージョンで存在していれば不正解，削除と判定されたメソッドのファイルパスとメソッド名が次バージョンで存在していれば不正解，生存と判定されたメソッドのファイルパスとメソッド名が次バージョンで存在していれば正解，というように判定した結果が表~\ref{tab:evaluation-classification}である．追加，削除，生存のどの分類においても正解率が0.79を超えている．したがって，本手法での誤検出が小さいと言える．

\begin{table}[ht]
  \centering
  \caption{メソッド追跡手法における分類ごとの正解率}
  \begin{tabular}{c|ccc}
    \hline
    & 追加 & 削除 & 生存  \\
    \hline \hline
    正解 & 24,905 & 6,757 & 414,945\\
    不正解 & 420 & 1,752 & 107,336 \\
    \hline
    正解率 & 0.98 & 0.79 & 0.79 \\
    \hline
  \end{tabular}
  \label{tab:evaluation-classification}
\end{table}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{妥当性の脅威}
\label{sec:thread-to-validity}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

本章では，本研究における結果の信頼性に影響を及ぼす可能性のある要因を，内的妥当性および外的妥当性の観点から述べる．

\subsection{内的妥当性}

本研究で使用したコードクローンの検出ツールは閾値でコードクローンを判定しているため，閾値によっては，メソッドの分類件数が異なる可能性がある．類似度を判定するための閾値に関しては，従来研究で検証されている0.7を使用することを信頼性を担保した．

クローンセットの一部のメソッドが削除された事例に関しては，目視で数件を確認しているため，この結果が全てのメソッドに当てはまるとは限らない．クローンセットの全メソッドが削除された事例に関しても，ファイルごと削除，内部メソッドの削除という事例は，あくまで一例である．したがって，分類された全てのメソッドに対して当てはまるとは言えない点は注意すべきである．

全てのコミット間隔ではなく，マイナーバージョンの間隔に絞って分析しているため，バージョン間で生成・削除された短命メソッドについては，見逃してしまう．しかし，これら短命のメソッドは開発者が一時的に導入するメソッドであるため，ソフトウェアにとって負債となり得ない．

\subsection{外的妥当性}
本研究はPythonのpandasプロジェクトのみを対象としている．データサイエンス分野に特化したライブラリ特有の進化パターンが存在する可能性があり，他のドメイン（例：Webフレームワーク，組み込みシステム）や他のプログラミング言語（例：Java, C++）で開発されたプロジェクトにおいても同様の削除パターンやクローン整理の傾向が見られるかは不明である．今後はより多様なOSSプロジェクトを対象とした大規模な調査が求められる．

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{おわりに}
\label{sec:conclusion}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\todo{後で書く}\todo{AIによる不要コードの生成が問題になっていることを書く}

% \bibliographystyle{junsrt}
% \bibliography{@IPSJ_SIGSE202603_Yoshida/yoshida_refs}
\bibliographystyle{ipsjunsrt}
\bibliography{yoshida_refs}

\end{document}
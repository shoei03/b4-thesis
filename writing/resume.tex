%
% 卒論レジュメフォーマット Ver.2.0 pLaTeX版
%
\documentclass[twocolumn]{jarticle} % 2段組のスタイルを用いている

\usepackage{wuse_resume}
\usepackage{url}	% \url{}コマンド用．URLを表示する際に便利
\usepackage[dvipdfmx]{graphicx}  % ←graphicx.styを用いてEPSを取り込む場合有効にする
			% 他のパッケージ・スタイルを使う場合には適宜追加

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%
%% タイトル，学生番号，氏名などを設定する
%%

\タイトル{類似コードを有するメソッドの削除に関する実証分析}
\研究室{ソーシャルソフトウェア工学}
\学生番号{60276296}
\氏名{吉田 将衛}

\概要{%
ライブラリは，機能追加や削除を繰り返しながら進化を続けている．その進化の過程でソフトウェアの規模が拡大し，不要なコードが蓄積する．この問題に対処するため，開発者はソフトウェア再構成の一環としてメソッドの削除を行うことがある．メソッドの削除には，機能としてのサポート終了に伴うものだけでなく，リファクタリングにおける機能統合の結果として行われる場合もある．機能統合によるメソッド削除の場合，統合直後に削除が行われるとは限らず，一定期間にわたり，削除予定のメソッドと統合先のメソッドに類似するソースコードが共存すると考えられる．そこで本研究では，ソフトウェアのメソッドが削除に至るまでの過程を追跡し，類似するソースコードを有する他のメソッドの有無，およびそれらメソッドとの類似度の推移を調査する．ケーススタディを通して，開発者がメソッドの削除判断に関する特徴を明らかにする．
}

\キーワード{メソッド削除}
\キーワード{コードクローン}
\キーワード{ソフトウェア保守}
\キーワード{最長共通部分列}
\キーワード{抽象構文木}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% 以下の3行は変更しない

\begin{document}
\maketitle
\thispagestyle{empty} % タイトルを出力したページにもページ番号を付けない

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%
%% 本文 - ここから
%%

\section{はじめに}

多くのソフトウェア開発は，ソフトウェア部品の組み合わせで行われる\cite{liblary-reuse}．特に，特定の機能を再利用可能な形でまとめられたライブラリの利用によってソフトウェアの開発工程を大幅に削減している\cite{reduce-productivity}．ライブラリは機能の追加や変更を繰り返しながら進化を続けるが，その過程でソフトウェアの規模が拡大し，不要なコードが蓄積する．従来研究では，デッドコードや未実行コードなどの不要コードを検出する手法が提案されている\cite{detect-dead-code}．しかし，機能として使用されているメソッドであっても，リファクタリングにおける機能統合の結果として削除される場合がある．機能統合によるメソッド削除の場合，統合直後に削除が行われるとは限らず，一定期間にわたり，削除予定のメソッドと統合先のメソッドに類似するソースコードが共存すると考えられる．

そこで本研究では，ソフトウェアのメソッドが削除に至るまでの過程を追跡し，類似するコードを有する他のメソッドの有無，およびそれらメソッドとの類似度の推移を調査する．具体的には，N-gramに基づくコードクローン検出ツールNIL\cite{NIL}を用い，同一プロジェクト内のメソッド間の類似度を算出する．本研究では次の2つのRQを設定する．

\noindent\textbf{RQ1:} 類似するソースコードを持つメソッドと持たないメソッドで削除率に差があるか

\noindent\textbf{RQ2:} メソッドが削除・統合される前に，メソッド間の類似度はどのように変化するか

\section{アプローチ}

%--------------
\begin{figure}[ht]
  \centering
  \includegraphics[width=1.0\linewidth]{@Bachelor2025_Yoshida/Yoshiba_fig/classify-method-all.pdf}
  \caption{バージョン間におけるメソッドの生存/統合/削除の分類}
  \label{fig:classify-method}
\end{figure}
%--------------

本研究では，OSSのバージョン更新に伴いメソッドを追跡する．対象はGitHubで公開されているOSSプロジェクトのうち，セマンティックバージョニングに従うメジャーおよびマイナーバージョン（パッチバージョンが0のタグ）を分析対象とする．

\noindent\textbf{メソッドの抽出と追跡}\hspace{1zw}各バージョンのPythonファイルを抽象構文木に変換し，各メソッドの「ファイルパス，クラス名.メソッド名，引数，戻り値の型」からなるシグネチャとボディのトークン列を取得する．隣接バージョン間でシグネチャが一致するメソッドは同一と見なし，生存と判定する（図~\ref{fig:classify-method}ケース1参照）．シグネチャが一致しない場合でも，コードクローン検出器NIL\cite{NIL}を用い，N-gramの逆インデックスと最長共通部分列（LCS）に基づくメソッド間の類似度が0.7以上であれば，生存と判定する（図~\ref{fig:classify-method}ケース2参照）．

\noindent\textbf{メソッドの分類}\hspace{1zw}追跡結果に基づき，各メソッドを3種類に分類する．（1）\textbf{生存メソッド}：次バージョン以降も存続するメソッド（図~\ref{fig:classify-method}ケース1, 2参照）．（2）\textbf{統合メソッド}：バージョン更新後にシグネチャの異なる類似メソッドに統合されるメソッド．複数メソッドが単一メソッドに統合される場合を含む（図~\ref{fig:classify-method}ケース4, 5参照）．（3）\textbf{削除メソッド}：次バージョンに対応メソッドが見つからないメソッド（図~\ref{fig:classify-method}ケース6参照）．

\noindent\textbf{バージョン内の類似度分析}\hspace{1zw}同一バージョン内の全メソッド間で類似度を算出する．類似度0.7以上のメソッドを「類似あり」，それ以外を「類似なし」と定義する．さらに，「類似あり」を高類似度群（$90\% \leq Sim$）と低類似度群（$70\% \leq Sim < 90\%$）に分け，削除率・統合率の分布差をウィルコクソンの符号順位検定で分析する．

\section{ケーススタディ}

\subsection{データセット}
PythonライブラリPandas（v0.4.0からv2.3.0の約14年間，32バージョン）を対象とする．一意に識別されるメソッド数は43,308件であり，そのうち生存20,874件，統合12,732件，削除9,702件であった．

\subsection{RQ1の結果}
バージョン内に類似メソッドを有するメソッド（平均4,240件）の平均統合率（0.110）は，類似メソッドが存在しないメソッド（平均5,755件）の平均統合率（0.008）より統計的に有意に高かった（$p < 0.05$，$r_{\mathrm{rb}} = -1.00$）．一方，平均削除率については，類似有り（0.031）と類似無し（0.037）で有意差は見られなかった（$p > 0.05$）．さらに，高類似度群の平均統合率（0.320）は低類似度群（0.044）より有意に高く（$p < 0.05$），類似度が高いほど統合されやすいことが示された．

\subsection{RQ2の結果}

%--------------
\begin{figure}[t]
  \centering
  \includegraphics[width=1.0\linewidth]{@Bachelor2025_Yoshida/Yoshiba_fig/deletion_survival_boxplot_deletion.pdf}
  \caption{統合元/削除メソッドの類似度推移}
  \label{fig:boxplot-deletion}
\end{figure}
%--------------

図\ref{fig:boxplot-deletion}は，メソッドが統合あるいは削除されるまでの類似度（中央値）の推移を示す．横軸は相対時間（削除・統合の1つ前のバージョンを$t = 0$とする），縦軸はメソッド間の類似度の中央値である．削除メソッドの類似度は約75\%から85\%の範囲で安定して推移しており，削除に向けた明確な変化は観察されなかった．一方，統合元メソッドの類似度は$t = 0$に近づくにつれて上昇し，$t = 0$では100\%に達した．

\section{考察}

統合元メソッド数の推移に基づき，メソッドの統合には2つのパターンが存在すると考えられる．1つ目は\textbf{一時的複製型}であり，開発過程で一時的に導入された内部関数やラッパー関数が，次のリリースでリネームやファイル移動により統合されるパターンである．2つ目は\textbf{段階的収束型}であり，2バージョン以上にわたりメソッド間の類似度が段階的に上昇した後に統合されるパターンである．段階的収束型メソッドは，削除候補として判定するための類似度推移の特徴を今後明らかにする必要がある．

\section{おわりに}

本研究では，ソフトウェア再構成において，メソッド間の類似度が削除の判断指標として機能するかを検証した．PythonライブラリPandasの43,308件のメソッドを対象に分析した結果，類似度の高いメソッドほど統合されやすいこと（RQ1），統合元メソッドでは統合前にメソッド間の類似度が上昇する一方，削除メソッドではそのような変化が見られないこと（RQ2）を明らかにした．以上の結果から，メソッド間の類似度の段階的な変化はメソッド統合の予測指標として有効であるが，メソッド削除の予測にはプロジェクトレベルの意思決定を含む他の要因も考慮する必要があることが示唆された．

%%
%% 本文 - ここまで
%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%
%% 参考文献
%%

\begin{thebibliography}{9}

\bibitem{liblary-reuse}
R.~G.~Kula, D.~M.~German, A.~Ouni, T.~Ishio, and K.~Inoue,
``Do developers update their library dependencies?,''
\textit{Empirical Software Engineering}, vol.~23, no.~1, pp.~384--417, 2018.

\bibitem{reduce-productivity}
R.~Abdalkareem, O.~Nourry, S.~Wehaibi, S.~Mujahid, and E.~Shihab,
``Why do developers use trivial packages? An empirical case study on npm,''
in \textit{Proc.\ ESEC/FSE}, pp.~385--395, 2017.

\bibitem{detect-dead-code}
I.~Malavolta, K.~Nirghin, G.~L.~Scoccia, S.~Romano, S.~Lombardi, G.~Scanniello, and P.~Lago,
``JavaScript dead code identification, elimination, and empirical assessment,''
\textit{IEEE Trans.\ Softw.\ Eng.}, vol.~49, no.~7, pp.~3692--3714, 2023.

\bibitem{NIL}
T.~Nakagawa, Y.~Higo, and S.~Kusumoto,
``NIL: Large-scale detection of large-variance clones,''
in \textit{Proc.\ ESEC/FSE}, pp.~830--841, 2021.

\end{thebibliography}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\end{document}
